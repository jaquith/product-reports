{"title":"Version 2020.11.04.0723","privacy_management":{"useTemplate":"true"},"datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","email":"caleb.jaquith@tealium.com","customizations":{"10":{"status":"active","constructor":"","scope":"preload","advExecOption":"alr","codeDevData":{"promotedSnippets":{"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"name":"prod","code":"/**\n *  Scope       : Pre Loader\n *  Condition   : n/a\n *  Description : CMP 1/2 - Preloader component - prevent TiQ from loading if no consent, queue implicitly consented events to retrigger (for new tags only) if explicit decision is made.\n */\n\n/**\n  * @module extension-1\n  *\n  * @description The 'Pre Loader' extension component of the CMP integration, responsible for stopping Tealium iQ from loading/running as appropriate, and making certain\n  * window-scoped functions available to the other components.\n  */\n\n// Tealium iQ runs Pre Loader extensions in global scope, which would make all variables global. We don't want to do that.\n(function avoidGlobalScopeUnlessExplicit () {\n  // set names for key objects and variables to make them easy to change if needed\n\n  var version = 'v0.10-beta'\n\n  // for the consent information in the b object\n  var nameOfVendorOptInArray = 'usercentrics_services_with_consent'\n  var nameOfConsentTypeString = 'usercentrics_consent_type'\n\n  // for the name in the queue\n  var nameOfImplicitConsentArray = '_usercentrics_services_already_processed'\n\n  // name to use when calling utag.handler.trigger to indicate a consent polling call\n  var nameOfConsentPollingEvent = 'tiq_usercentrics_consent_polling'\n\n  var consentTimeoutInterval = 400 // setTimeout interval in MS - rate to poll for new (explicit) consent decision or correctly formed object\n\n  // check for the Tealium Debug cookie, see https://docs.tealium.com/platforms/javascript/debugging/\n  var tiqInDebugMode = /utagdb=true/.test(document.cookie)\n  var tealiumEnvironment = getTealiumEnvironment() || 'prod' // fall back to prod (stops logging) if something goes wrong with the function\n\n  /**\n   * A window-scoped (global) object used to expose selected functionality.\n   *\n   * @namespace tealiumCmpIntegration\n   * @type {object}\n   * @memberof! &lt;global&gt;\n   */\n  window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\n\n  /**\n   * The name of the CMP (&quot;Usercentrics Vanilla App&quot; in this case).\n   * @name cmpName\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.cmpName = 'Usercentrics Vanilla App'\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link ServiceToTagMap ServiceToTagMap}\n   * @name map\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  var map = window.tealiumCmpIntegration.map || {}\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link TagToServiceMap TagToServiceMap}\n   * @name tagBasedMap\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  generateTagBasedMap() // populates the window-level object for you as well\n\n  /**\n   * The Service Name for Tealium iQ in Usercentrics (used to decide if the TMS is allowed to run).  Uses the Usercentrics standard name if not provided.\n   * @name tiqServiceName\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   * @default 'Tealium iQ Tag Management'\n   * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.tiqServiceName = &quot;Tealium iQ Tag Management&quot;\n   */\n  var tiqServiceName = window.tealiumCmpIntegration.tiqServiceName || 'Tealium iQ Tag Management' // use the standard name here if not set\n\n  /**\n   * The current version designation.\n   * @name version\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.version = version\n\n  /**\n   * A [logger helper function]{@link module:extension-1~logger}, to help Tealium iQ users understand and troubleshoot this CMP integration without unneeded logging in production.\n   * @name logger\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.logger = logger\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentConsentDecision} that returns the current [ConsentDecision]{@link ConsentDecision}.\n   * @name getCurrentConsentDecision\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentConsentDecision = getCurrentConsentDecision\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentUsercentricsSettingsId} that returns the current Usercentrics settingsId.\n   * @name getCurrentUsercentricsSettingsId\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentUsercentricsSettingsId = getCurrentUsercentricsSettingsId\n\n  /**\n   * Records the status of the [noview]{@link https://docs.tealium.com/platforms/javascript/settings/#noview} setting on page load.\n   * @name isNoviewSet\n   * @type {boolean}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.isNoviewSet = window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noview === true\n\n  /**\n   * The name to use for the [ConsentDecision]{@link ConsentDecision} array when adding it to Tealium's b object on each event.\n   * @name nameOfVendorOptInArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfVendorOptInArray = nameOfVendorOptInArray\n\n  /**\n   * The name to use for the current [ConsentDecision]{@link ConsentDecision}'s 'type' attribute when adding it to Tealium's b object on each event.\n   * @name nameOfConsentTypeString\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfConsentTypeString = nameOfConsentTypeString\n\n  /**\n   * The name to use for the array of implicit tags (which have already been fired) in the 'data' property of {@link QueuedEvent QueuedEvent} objects.\n   * @name nameOfImplicitConsentArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfImplicitConsentArray = nameOfImplicitConsentArray\n\n  /**\n   * A [helper function]{@link module:extension-1~overrideUtagFunctions} that overrides certain utag functions to allow tags to be blocked based on CMP response.\n   *\n   * Must be called directly after the '##UTGEN##' reference by [editing]{@link https://community.tealiumiq.com/t5/iQ-Tag-Management/Managing-Tag-Templates/ta-p/21713} the 'utag loader' template, as shown in the example.\n   * @name overrideUtagFunctions\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   * @example\n// ... utag loader template ...\n\n##UTGEN##\n// override two utag functions for the Usercentrics CMP Integration, to allow tags to be blocked as needed\nwindow.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions()\n\n// ... utag loader template continues...\n\n   */\n  window.tealiumCmpIntegration.overrideUtagFunctions = overrideUtagFunctions\n\n  /**\n   * A queue for any events that Tealium iQ processes with IMPLICIT consent (to allow those events to be re-processed for new Services in the event of an EXPLICIT consent choice by the user).\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name implicitEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n\n  /**\n   * A queue for any events that are triggered before Tealium iQ AND Usercentrics have both loaded.\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name earlyEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n\n  /**\n   * Allows us to make sure we don't log certain messages more than once, especially useful while polling to avoid overwhelming the user.\n   * @function messageNotLoggedYet\n   * @param {*} messageId a string or number to uniquely identify a message for the purposes of deduplication\n   * @returns {boolean} 'true' if the message hasn't been logged yet (and should be logged), otherwise 'false'\n   */\n  var alreadyLoggedMessageIds = {}\n  function messageNotLoggedYet (messageId) {\n    var output = false\n    if (typeof alreadyLoggedMessageIds[messageId] === 'undefined') {\n      alreadyLoggedMessageIds[messageId] = true\n      output = true\n    }\n    return output\n  }\n\n  // if noload is set to 'true', don't interfere, just return to exit this function and allow that setting to stop TiQ load as usual.\n  if (window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noload === true) return false\n\n  logger('CMP integration active - Usercentrics/TiQ' + (tiqInDebugMode ? &quot;\\n\\nDEBUGGING TIP: Use /SENDING|\\\\*\\\\*\\\\*\\\\*/ in the browser console as the 'filter' to show only CMP and tag send notifications.&quot; : '\\n\\nActivate TiQ Debug Mode for more details: https://docs.tealium.com/platforms/javascript/debugging/'), true)\n  var cmpResponse = cmpConsentCheck()\n  // core business/GDPR logic, decides if TiQ should load at all\n  reactToCmpResponse(cmpResponse)\n\n  /**\n   * The core CMP integration logic, which decides if Tealium iQ should be allowed to run, or if it needs to be stopped\n   * until an understandable response that includes permission for Tealium iQ to run is found.\n   *\n   * @function reactToCmpResponse\n   * @param {object} cmpResponse The response from the Usercentrics Vanilla App\n   */\n  function reactToCmpResponse (cmpResponse) {\n    var usercentricsFound = typeof cmpResponse === 'object'\n    var foundWellFormedConsentDecision = checkForWellFormedDecision(cmpResponse)\n    var tagBasedMap = generateTagBasedMap()\n    var foundMapEntryForActiveSetting = Object.keys(tagBasedMap).length &gt; 0\n    var foundExplicitConsent = checkForExplicitConsentDecision(cmpResponse)\n    var tiqIsAllowedToFire = checkForTiqConsent(cmpResponse)\n    var tiqIsLoaded = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!usercentricsFound) {\n      /**\n       * CASE A1: no Usercentrics CMS found\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(1)) logger('No Usercentrics CMP found on page.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundMapEntryForActiveSetting) {\n      /**\n        * CASE A7: No map found for the current settingsId\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(2)) logger('No map found for current Usercentrics Setting ID.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    } else if (!foundWellFormedConsentDecision) {\n      /**\n       * CASE A2: Usercentrics CMS found but consent response wasn't well-formed/complete/understandable\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(3)) logger('Found Usercentrics CMP and got response, but didn\\'t understand the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!tiqIsAllowedToFire) {\n      /**\n       * CASE A3: Usercentrics CMS found and consent response was well-formed, BUT TiQ didn't have an opt-in\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(4)) logger('Found Usercentrics CMP and got well-formed response, but TiQ isn\\'t allowed to run based on the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundExplicitConsent) {\n      /**\n       * CASE A4: Usercentrics CMS found AND response was understandable (AND includes an implicit TiQ consent), BUT the user hasn't made an explicit decision yet\n       *\n       * ALLOW TO LOAD for any 'default opt-in' tags (filter logic in Extension B)\n       * RETRY after a delay (in case there's an explicit decision, since implicit decisions usually mean the prompt is displayed)\n       */\n      if (messageNotLoggedYet(5)) logger('Found Usercentrics CMP and got well-formed IMPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on IMPLICIT consent.\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else if (foundExplicitConsent) {\n      /**\n       * CASE A5: Usercentrics CMS found AND response was understandable, AND the user has made an explicit consent decision AND TiQ is allowed\n       *\n       * ALLOW TO LOAD for any opted-in tags (filter logic in Extension B), do not retry.\n       */\n      if (messageNotLoggedYet(6)) logger('Found Usercentrics CMP and got well-formed EXPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on EXPLICIT consent.\\n\\nNo further polling.')\n      // only call if we've been polling (on initial load, it will load automatically)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n        processImplicitQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else {\n      /**\n        * CASE A6: Something went wrong with this extension.\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(7)) logger('Something unexpected went wrong.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    }\n  }\n\n  /**\n   * Override utag.loader.initdata and utag.handler.trigger to allow Tealium iQ Tags to be blocked if the user hasn't consented.\n   *\n   * @function overrideUtagFunctions\n   * @returns {boolean} 'true' if the function was overridden successfully by this request, 'false' if not (because it was already overridden)\n   */\n  function overrideUtagFunctions () {\n    // don't override more than once, assume that if one function has been overridden, both have\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    // the initial view is handled differently than subsequent events\n    // this is safe to to override even if noview is set (because it will never be called in that case)\n    window.utag.loader.initdata_old = window.utag.loader.initdata\n    window.utag.loader.initdata = newUtagLoaderInitdata\n\n    window.utag.handler.trigger_old = window.utag.handler.trigger\n    window.utag.handler.trigger = newUtagHandlerTrigger\n    logger('Overrode utag functions!')\n\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * An overridden version of the Tealium iQ function utag.loader.initdata.\n   *\n   * Calls the original function, respects possible noview settings, rechecks the user consent, and calls queueEventWithoutFiringImplicitServices\n   * if only an IMPLICIT consent is found (after recording the IMPLICIT services, to avoid double-firing).\n   *\n   * That same event can then be re-processed for any new Services if an EXPLICIT consent decision later made.\n   *\n   * @function newUtagLoaderInitdata\n   */\n  function newUtagLoaderInitdata () {\n    window.utag.loader.initdata_old()\n    // make sure we don't queue this initial page load twice, and respect the configured noview setting\n    if (!window.tealiumCmpIntegration.isNoviewSet &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n      window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n      var consentedServices = getCurrentConsentDecision()\n      if (consentedServices.type === 'implicit') {\n        window.tealiumCmpIntegration.implicitServices = consentedServices\n        // we don't need to fire implicit services in this case, because TiQ's loading process will fire them\n        queueEventWithoutFiringImplicitServices({\n          event: 'view',\n          data: window.utag.handler.C(window.utag.data)\n        })\n      }\n    }\n  }\n\n  /**\n   * Refresh [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration.tagBasedMap} and return that new map, helps smooth out any timing issues between Usercentrics and Tealium iQ load.\n   *\n   * @function generateTagBasedMap\n   * @returns a [TagToServiceMap]{@link TagToServiceMap}\n   */\n  function generateTagBasedMap () {\n    var tagBasedMap = getTagBasedMap(map)\n    window.tealiumCmpIntegration.tagBasedMap = tagBasedMap\n    return tagBasedMap\n  }\n\n  /**\n   * Tealium iQ's utag.handler.trigger normally causes tags to fire. For this integration, we override that function to support blocking tags without consent.\n   *\n   * @function newUtagHandlerTrigger\n   *\n   * @param {*} a can be an object or a string\n   * @param {*} b\n   * @param {*} c\n   */\n  function newUtagHandlerTrigger (a, b, c) {\n    /**\n     * Trigger CASES (utag.handler.trigger override)\n     *\n     * We need to queue the events if we only have implicit consent, to allow a selective retrigger if/when we get an explicit decision.\n     */\n    var isPureConsentEvent = (a === nameOfConsentPollingEvent &amp;&amp; !b &amp;&amp; !c)\n    var isNoviewSet = window.tealiumCmpIntegration.isNoviewSet || true // assume noview if something went wrong with the global, to avoid firing tracking in error\n\n    var consentedServices = getCurrentConsentDecision()\n    var consentType = (consentedServices &amp;&amp; consentedServices.type) || 'none'\n\n    var isUsercentricsReady = consentType === 'implicit' || consentType === 'explicit'\n    var isTealiumReady = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!isPureConsentEvent) {\n      logger('utag.handler.trigger called with:\\n\\n' + JSON.stringify(arguments, null, 2))\n    }\n\n    if (!isUsercentricsReady &amp;&amp; !isTealiumReady) {\n      consentedServices.type = 'tealium-and-usercentrics-loading'\n      logger('Waiting for Usercentrics and Tealium to be ready, queueing early event.')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isUsercentricsReady) {\n      consentedServices.type = 'usercentrics-loading'\n      logger('Usercentrics is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isTealiumReady) {\n      consentedServices.type = 'tealium-still-loading'\n      logger('Tealium iQ is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    }\n\n    // if an array of tagUids is passed, that forces them to fire regardless of load rules\n    // or consent, so we need to filter that array before allowing it to be processed\n    var hasTagUidArray = c &amp;&amp; typeof c === 'object' &amp;&amp; c.uids &amp;&amp; c.uids &amp;&amp; window.utag.ut.typeOf(c.uids) === 'array'\n    var uidMap = generateTagBasedMap()\n    var allowedTagUids = []\n    var blockedTagUids = []\n    var serviceName\n    var tagUid\n    if (hasTagUidArray) {\n      for (var i = 0; i &lt; c.uids.length; i++) {\n        tagUid = c.uids[i]\n        serviceName = uidMap[tagUid] || '(missing)'\n        // only push consented services into the new array\n        if (consentedServices.indexOf(serviceName) !== -1) {\n          allowedTagUids.push(tagUid)\n        } else {\n          blockedTagUids.push(tagUid)\n        }\n      }\n      // replace the original with the filtered array (can also be empty, if none of them were allowed)\n      logger('Call included tagUid array:\\n\\n' + JSON.stringify(c.uids) + '\\n\\nwhich was replaced by the filtered version:\\n\\n' + JSON.stringify(allowedTagUids))\n      c.originalUids = c.uids.slice() // make a shallow copy\n      c.uids = allowedTagUids\n      c.blockedTagUids = blockedTagUids\n    }\n\n    if (consentType === 'explicit') {\n      /**\n       * CASE T2: expected globals are populated, consent is EXPLICIT\n       *\n       * FIRE allowed tags (explicit)\n       * utag.handler.trigger override PROCESSES the queue, which will include any queued events from CASE A4, making sure not to re-fire any default\n       *   opt-in tags that were already fired for the queued events\n       */\n      // make sure TiQ loads\n      processEarlyQueue()\n      processImplicitQueue()\n      triggerTiqLoad()\n      // fire the current event if it's not just a polling event\n      if (!isPureConsentEvent) {\n        return window.utag.handler.trigger_old(a, b, c)\n      }\n    } else if (consentType === 'implicit') {\n      /**\n       * CASE T3: expected globals are populated, consent is IMPLICIT\n       *\n       * FIRE allowed tags (implicit)\n       * utag.handler.trigger override KEEPS a queue/record that includes\n       *  - the event(s) that were processed based on implicit consent\n       *  - which tags were allowed to process each event (are set to implicit opt-in)\n       */\n      processEarlyQueue()\n      // fire the initial view if appropriate, and queue it\n      triggerTiqLoad()\n      window.tealiumCmpIntegration.implicitServices = consentedServices\n\n      // queue the initial 'view' on pageload if appropriate\n      if (!isNoviewSet &amp;&amp; isTealiumReady &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n        window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n        queueEventAndFireImplicitServices('view', window.utag.handler.C(window.utag.data))\n      }\n      // queue the current event if it exists (and this isn't just consent polling)\n      if (!isPureConsentEvent) {\n        return queueEventAndFireImplicitServices(a, b, c)\n      }\n    } else if (consentType === 'missing-map') {\n      logger('Something went wrong - all tags were blocked because no consent map was found for the active setting ID.')\n      return false\n    } else if (consentType === 'missing-tiq-consent') {\n      logger('Something went wrong - all tags were blocked because no consent was found for &quot;' + tiqServiceName + '&quot;, configured Tealium iQ name.\\n\\nConsent found: ' + JSON.stringify(consentedServices, null, 2))\n      return false\n    } else {\n      /**\n       * CASE T1: expected variables not populated (misconfiguration/error case)\n       *\n       * STOP and fire nothing at all. Do not retry or queue the event.\n       */\n      logger('Something went wrong - all tags were blocked because the consent response was not understood.')\n      return false\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the early event queue]{@link tealiumCmpIntegration.earlyEventQueue} (can include pageviews) for any currently-consented Services.\n   *\n   * Intended to be called first understandable implicit consent.\n   *\n   * @function processEarlyQueue\n   */\n  function processEarlyQueue () {\n    var queuedEvent\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    while (window.tealiumCmpIntegration.earlyEventQueue.length &gt; 0) {\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.earlyEventQueue.shift()\n      logger('Processing queued early event for currently consented tags: ' + JSON.stringify(queuedEvent, null, 2))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the global queue]{@link tealiumCmpIntegration.implicitEventQueue} (can include pageviews) for any newly-consented Services.\n   *\n   * Intended to be called on new EXPLICIT consent decision - queued events have already had IMPLICTLY consented tags fired, so those need to be excluded.\n   *\n   * @function processImplicitQueue\n   */\n  function processImplicitQueue () {\n    var alreadyLogged = false\n    var queuedEvent\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    while (window.tealiumCmpIntegration.implicitEventQueue.length &gt; 0) {\n      if (!alreadyLogged) {\n        alreadyLogged = true\n        logger('Explicit consent tracking request received - processing past implicitly tracked events (' + window.tealiumCmpIntegration.implicitEventQueue.length + ') for any new explicit tags.')\n      }\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.implicitEventQueue.shift()\n      logger('Triggering event for explicitly-consented tags: ' + JSON.stringify(queuedEvent))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the early queue]{@link tealiumCmpIntegration.earlyEventQueue}, without firing any tags.\n   *\n   * Intended to be called for events that triggered before we get an understandable response from Usercentrics.\n   *\n   * @function queueEarlyEvent\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEarlyEvent (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    // nothing will be allowed to fire\n    a.data[nameOfImplicitConsentArray] = []\n\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    window.tealiumCmpIntegration.earlyEventQueue.push(a)\n    logger('Queued early event!')\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration.implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for the initial pageview on load, since the load process will have already fired the implicit services.\n   *\n   * @function queueEventWithoutFiringImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventWithoutFiringImplicitServices (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    a.data[nameOfImplicitConsentArray] = window.tealiumCmpIntegration.implicitServices || []\n\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    window.tealiumCmpIntegration.implicitEventQueue.push(a)\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration~implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for all events other than the initial page load.\n   *\n   * @function queueEventAndFireImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventAndFireImplicitServices (a, b, c) {\n    // fire the implicit tags\n    window.utag.handler.trigger_old(a, b, c)\n    logger('Implicit consent tracking request fired (or queued, if utag hasn\\'t loaded).')\n    return queueEventWithoutFiringImplicitServices(a, b, c)\n  }\n\n  /**\n   * Generate a {@link TagToServiceMap TagToServiceMap} based on a {@link ServiceToTagMap ServiceToTagMap}\n   *\n   * @function getTagBasedMap\n   * @param {object} map a {@link ServiceToTagMap ServiceToTagMap} object\n   * @return {object} a {@link TagToServiceMap TagToServiceMap}\n   */\n  function getTagBasedMap (map) {\n    // generate a lookup based on the tagUid\n    if (typeof map !== 'object') return {}\n    var settingsId = getCurrentUsercentricsSettingsId() || ''\n    if (typeof settingsId !== 'string' || settingsId === '') return {}\n    var settingSpecificMap = map[settingsId] || {}\n    var serviceNames = Object.keys(settingSpecificMap)\n    var uidMap = {}\n    for (var i = 0; i &lt; serviceNames.length; i++) {\n      for (var j = 0; j &lt; settingSpecificMap[serviceNames[i]].length; j++) {\n        uidMap[settingSpecificMap[serviceNames[i]][j]] = serviceNames[i]\n      }\n    }\n    return uidMap\n  }\n\n  /**\n   * Get the current Usercentrics settingsId from the page.\n   *\n   * @returns {string} the Usercentrics settingsId, defaults to an empty string if none is found\n   */\n  function getCurrentUsercentricsSettingsId () {\n    return (window.usercentrics &amp;&amp; window.usercentrics.settingsId) || ''\n  }\n\n  /**\n   * Trigger the core logic with an up-to-date array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   * @function recheckForCmpAndConsent\n   */\n  function recheckForCmpAndConsent () {\n    var newConsentResponse = cmpConsentCheck()\n    reactToCmpResponse(newConsentResponse)\n  }\n\n  /**\n   * Call [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents} to get the current consent decision.\n   * @function cmpConsentCheck\n   */\n  function cmpConsentCheck () {\n    if (!window.usercentrics || typeof window.usercentrics.getConsents !== 'function') return false\n    var cmpConsentArray = window.usercentrics.getConsents()\n    return cmpConsentArray\n  }\n\n  /**\n   * Indicates if Usercentrics has loaded and returned a well-formed indication of user consent.\n   * @function checkForWellFormedDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is well-formed, otherwise 'false'\n   */\n  function checkForWellFormedDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; typeof cmpConsentArray[0].dataProcessingService === 'string') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if the user has made an EXPLICIT decision\n   * @function checkForExplicitConsentDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is EXPLICIT otherwise 'false'\n   */\n  function checkForExplicitConsentDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; cmpConsentArray[0].updatedBy === 'explicit') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if Tealium iQ has permission to run (and fire tags).\n   * @function checkForTiqConsent\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if TiQ is allowed to run, otherwise 'false'\n   */\n  function checkForTiqConsent (cmpConsentArray) {\n    var foundOptIn = false\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // check vendors if there's an object, look for at least one\n    cmpConsentArray.forEach(function (tagInfo) {\n      if (tagInfo.consentStatus === true &amp;&amp; tagInfo.dataProcessingService === tiqServiceName) {\n        foundOptIn = true\n      }\n    })\n    return foundOptIn\n  }\n\n  /**\n   * Create an instance of\n   * @param {array} cmpConsentArray the array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   */\n  function getVendorConsentsFromCmpConsentArray (cmpConsentArray) {\n    var vendorArray = []\n\n    var isWellFormed = checkForWellFormedDecision(cmpConsentArray)\n\n    if (!isWellFormed) {\n      vendorArray.type = 'missing-well-formed-response'\n      return []\n    }\n\n    var tagBasedMap = generateTagBasedMap()\n\n    // if there is no mapping for the settings id, we need to change the console output\n    var currentSettingsIdHasMapping = (typeof tagBasedMap === 'object' &amp;&amp; Object.keys(tagBasedMap).length &gt; 0)\n\n    if (!currentSettingsIdHasMapping) {\n      vendorArray.type = 'missing-map'\n      return []\n    }\n\n    cmpConsentArray &amp;&amp; cmpConsentArray.forEach(function (tagConsent) {\n      if (tagConsent.consentStatus === true) {\n        vendorArray.push(tagConsent.dataProcessingService)\n      }\n    })\n    vendorArray.type = checkForExplicitConsentDecision(cmpConsentArray) ? 'explicit' : 'implicit'\n\n    if (checkForTiqConsent(cmpConsentArray) === false) {\n      // change the consent type, but leave the array for debugging purposes\n      vendorArray.type = 'missing-tiq-consent'\n    }\n\n    return vendorArray\n  }\n\n  /**\n   * Get the current consent decision from the CMP for the active Setting\n   * @function getCurrentConsentDecision\n   * @returns a {@link ConsentDecision ConsentDecision}\n   */\n  function getCurrentConsentDecision () {\n    var freshConsent = cmpConsentCheck()\n\n    return getVendorConsentsFromCmpConsentArray(freshConsent)\n  }\n\n  /**\n   *  A conditional logging function - we can't use utag.DB directly because some of our logic needs to be preloader, but we can mimic the same logic so that our logging only displays when TiQ is in debug mode and/or not in Prod, or is explicitly forced.\n   * @function logger\n   * @param {string} message the message to be conditionally shown\n   * @param {boolean} showOutsideDebugMode if 'true', forces the message to shown outside of debug mode, except on Prod\n   */\n  function logger (message, showOutsideDebugMode) {\n    if (typeof tealiumEnvironment === 'undefined' || tealiumEnvironment === 'prod') {\n      // don't allow anything outside of debug mode on prod (disable this flag)\n      showOutsideDebugMode = false\n    }\n\n    if (showOutsideDebugMode || tiqInDebugMode) {\n      message = '\\n' + message + '\\n'\n      var formattedArr = []\n      formattedArr.push('****************')\n      var messageArr = message.split('\\n')\n      messageArr.forEach(function (messageLine) {\n        formattedArr.push('*  ' + messageLine)\n      })\n      formattedArr.push('****************')\n      var outputString = formattedArr.join('\\n')\n      console.log(outputString)\n    }\n  }\n\n  /**\n   * Stops Tealium iQ from loading (the TMS will not load tags or set a cookie if this function is called in Pre Loader), using the {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} setting\n   * @function stopTiq\n   */\n  function stopTiq () {\n    // logger(&quot;stopTiq function fired&quot;)\n    window.utag_cfg_ovrd = window.utag_cfg_ovrd || {}\n    window.utag_cfg_ovrd.noload = true\n  }\n\n  /**\n   * Allows TiQ to finish loading, intended to be called when a well-formed consent response is received, and that response allows Tealium iQ to run.\n   *\n   * Works by setting {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} to 'false' and calling Tealium iQ's utag.loader.PINIT method.\n   *\n   * If noload was 'true' and this function runs it must've been set to true by our own {@link module:extension-1~stopTiq stopTiq} function, because otherwise Tealium iQ wouldn't have been allowed to load/poll in the first place.\n   * @function triggerTiqLoad\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function triggerTiqLoad () {\n    // if usercentrics is ready on the first request, TiQ won't have loaded yet at all - let it load naturally\n    if (!window.utag) {\n      return true\n    }\n    // if TiQ has already loaded but these flags aren't truthy, we've interrupted the load and should retrigger it\n    // initial load / view (noview logic handled in utag.handler.trigger function itself)\n    if (!window.utag.handler || !window.utag.handler.iflag) {\n      // we don't need to reload actually, just allow it to finish loading\n      window.utag.cfg.noload = false // safe because this code only runs if it was set to false originally\n      window.utag.loader.PINIT()\n      return true\n    }\n    // already loaded\n    return false\n  }\n\n  /**\n   * If Tealium iQ hasn't loaded, load it (calling utag.handler.trigger in the process), otherwise call utag.handler.trigger.\n   * @function triggerOrQueue\n   */\n  function triggerOrQueue () {\n    var successfullyTriggeredLoadIfNeeded = triggerTiqLoad()\n    if (!successfullyTriggeredLoadIfNeeded) {\n      // explicit consent from polling, but load has already been triggered\n      return window.utag.handler.trigger(nameOfConsentPollingEvent)\n    }\n  }\n  /**\n   * Get the the current Tealium iQ environment.\n   *\n   * Since this runs in Pre Loader, it needs to use regex to recognize the utag.js file in the DOM and read the environment from the file name (there are no utag functions or objects at this point in the load).\n   *\n   * NOTE: This doesn't work correctly when using the the Environment Switcher (because the original script is added to the DOM instead of the new one, and the 307 redirect that's used to pull the new file(s) only changes the response, not the script element itself).\n   *\n   * If you're using the Environment Switcher on Prod and would like to see console output, set the [debug cookie]{@link https://docs.tealium.com/platforms/javascript/debugging/}.\n   *\n   * @function getTealiumEnvironment\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function getTealiumEnvironment () {\n    var allScripts = document.getElementsByTagName('script')\n    var re = /\\/([^/]*)\\/utag\\.js(\\?.*)*$/\n    for (var i = 0; i &lt; allScripts.length; i++) {\n      var result = re.exec(allScripts[i].src) // can be null\n      if (result &amp;&amp; result[1]) { // [1] is the result of the match\n        return result[1]\n      }\n    }\n    return 'prod' // default to guessing we're in prod, just in case we're actually in prod (to avoid logging in Prod)\n  }\n})()\n\n// Document key data structures here for clarity.\n\n/**\n * An array of Usercentrics Service Names that have permission to run (uses the 'dataProcessingService' property from [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}).\n *\n * Also includes a 'type' property that indicates whether the consent decision is IMPLICIT or EXPLICT.\n *\n * @static\n * @type {array}\n * @name ConsentDecision\n * @memberof! &lt;global&gt;\n * @property {string} type the type of consent, will be either 'implicit' or 'explicit'\n * @example\nvar exampleConsentDecision = window.tealiumCmpIntegration.getCurrentConsentDecision()\n\nJSON.stringify(exampleConsentDecision)\n// [&quot;Google Analytics&quot;,&quot;Another Tag&quot;,&quot;Tealium iQ Tag Management&quot;]\n\nexampleConsentDecision.type\n// &quot;explicit&quot;\n\nexampleConsentDecision.length\n// 3\n */\n\n/**\n * Assigns Tealium iQ Tags to Usercentrics Service Names. Each service can have multiple tags, but each tag can only have one service.  If the same tag UID appears in multiple Service arrays, only one will be used.\n *\n * The keys for the main object are Setting-IDs from Usercentrics, inside that are key/value pairs where the key is a Service Name from Usercentrics, and the value is an array of TagUIDs from Tealium iQ.\n *\n * This needs to be provided as per the example below, in [tealiumCmpIntegration.map]{@link namespace:tealiumCmpIntegration~map}.\n *\n * An [example Tealium iQ extension]{@link module:example-map} is provided as well.\n *\n * @static\n * @type {object}\n * @name ServiceToTagMap\n * @memberof! &lt;global&gt;\n * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n  'yPyIAIIxY': {\n    'Google Analytics': [6, 8, 10],\n    'Mouseflow': [7, 9],\n    'Another Tag': [11]\n  }\n}\n */\n\n/**\n * A simple lookup, with Tealium iQ tag UIDs as keys and the associated Usercentrics service name as strings as values. Each service can be associated with multiple tags, but each tag can be associated with one service.\n *\n * The example is based on the {@link ServiceToTagMap ServiceToTagMap} example, where the Usercentrics settingsId on the active page is 'yPyIAIIxY'.\n *\n * This object is automatically generated by the [getTagBasedMap]{@link module:extension-1~getTagbasedMap} method, and made available globally in [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration~tagBasedMap} for debugging and use within the extensions.\n *\n * @static\n * @type {object}\n * @name TagToServiceMap\n * @memberof! &lt;global&gt;\n * @example\n{\n  6: 'Google Analytics',\n  7: 'Mouseflow',\n  8: 'Google Analytics',\n  9: 'Mouseflow',\n  10: 'Google Analytics',\n  11: 'Another Tag'\n}\n */\n\n/**\n * An object from the [implicitEventQueue]{@link tealiumCmpIntegration.implicitEventQueue} or [earlyEventQueue]{@link tealiumCmpIntegration.earlyEventQueue}, which represents a Tealium iQ tracking event that's been processed based on an IMPLICIT [ConsentDecision]{@link ConsentDecision}\n *\n * Heavily based on the argument passed to [utag.track]{@link https://community.tealiumiq.com/t5/Tealium-iQ-Tag-Management/utag-track-method/td-p/24578}, since it's designed to be processed by that method.\n *\n * Initial pageviews (handled in the [utag.loader.initdata override]{@link module:extension-1~newUtagLoaderInitdata}) will NOT have metadata like cookies, qps, etc - utag.track calls (handled in the [utag.handler.trigger override]{@link module:extension-1~newUtagHandlerTrigger}) will. That's a byproduct of using utag.handler.trigger, which is later in the load - those metadata will be re-read when the queue is processed, and since this queue isn't persisted between pages, it should be fine like that - the only strange behavior will be that any metadata that aren't present on re-read will still be present after the re-read - only values that are still present will be replaced with new values.\n *\n * An alternative approach could be to manually remove 'cp.\\*', 'dom.\\*', 'ut.\\*', 'qp.\\*', 'meta.\\*' and possibly 'tealium_\\*' (except 'tealium_event') from the 'data' object before queueing - that hasn't been done so far.\n *\n * @static\n * @type {array}\n * @name QueuedEvent\n * @memberof! &lt;global&gt;\n * @property {string} event the type of tracking event, generally 'view' for pageviews or 'link' for other events\n * @property {object} data the Universal Data Object associated with the event (from utag_data or the b object)\n * @property {object} cfg an optional configuration object that can have a 'cb' property (for a callback function) and a 'uids' array, which is a list of tag UIDs that should be triggered by the event, regardless of whether load rules are met.\n * @example\n{\n  &quot;event&quot;: &quot;view&quot;,\n  &quot;data&quot;: {\n    &quot;page_type&quot;: &quot;test_virtual_view&quot;,\n    &quot;cp.utag_main_v_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;cp.utag_main__sn&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__se&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__ss&quot;: &quot;0&quot;,\n    &quot;cp.utag_main__st&quot;: &quot;1598990152209&quot;,\n    &quot;cp.utag_main_ses_id&quot;: &quot;1598988112353&quot;,\n    &quot;cp.utag_main__pn&quot;: &quot;3&quot;,\n    &quot;cp.utagdb&quot;: &quot;true&quot;,\n    &quot;dom.referrer&quot;: &quot;&quot;,\n    &quot;dom.title&quot;: &quot;Usercentrics Test&quot;,\n    &quot;dom.domain&quot;: &quot;solutions.tealium.net&quot;,\n    &quot;dom.query_string&quot;: &quot;&quot;,\n    &quot;dom.hash&quot;: &quot;&quot;,\n    &quot;dom.url&quot;: &quot;https://solutions.tealium.net/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.pathname&quot;: &quot;/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.viewport_height&quot;: 456,\n    &quot;dom.viewport_width&quot;: 1825,\n    &quot;ut.domain&quot;: &quot;tealium.net&quot;,\n    &quot;ut.version&quot;: &quot;ut4.46.202009011921&quot;,\n    &quot;ut.event&quot;: &quot;view&quot;,\n    &quot;ut.visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;ut.session_id&quot;: &quot;1598988112353&quot;,\n    &quot;ut.account&quot;: &quot;services-caleb&quot;,\n    &quot;ut.profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;ut.env&quot;: &quot;prod&quot;,\n    &quot;tealium_event&quot;: &quot;view&quot;,\n    &quot;tealium_visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;tealium_session_id&quot;: &quot;1598988112353&quot;,\n    &quot;tealium_session_number&quot;: &quot;4&quot;,\n    &quot;tealium_session_event_number&quot;: &quot;4&quot;,\n    &quot;tealium_datasource&quot;: &quot;&quot;,\n    &quot;tealium_account&quot;: &quot;services-caleb&quot;,\n    &quot;tealium_profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;tealium_environment&quot;: &quot;prod&quot;,\n    &quot;tealium_random&quot;: &quot;2085060854215077&quot;,\n    &quot;tealium_library_name&quot;: &quot;utag.js&quot;,\n    &quot;tealium_library_version&quot;: &quot;4.46.0&quot;,\n    &quot;tealium_timestamp_epoch&quot;: 1598988352,\n    &quot;tealium_timestamp_utc&quot;: &quot;2020-09-01T19:25:52.211Z&quot;,\n    &quot;tealium_timestamp_local&quot;: &quot;2020-09-01T21:25:52.211&quot;,\n    &quot;usercentrics_services_with_consent&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ],\n    &quot;usercentrics_consent_type&quot;: &quot;implicit&quot;,\n    &quot;_usercentrics_services_already_processed&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ]\n  },\n  &quot;cfg&quot;: {\n    &quot;cb&quot;: function myCallback () {console.log(&quot;Callback fired!&quot;)},\n    &quot;uids&quot;: [\n      11\n    ],\n    &quot;originalUids&quot;: [\n      7,\n      11\n    ],\n    &quot;blockedTagUids&quot;: [\n      11\n    ]\n  }\n}\n*/\n","promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202011040723","promotedDraftName":"extension-1.js"},"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"code":"/**\n *  Scope       : Pre Loader\n *  Condition   : n/a\n *  Description : CMP 1/2 - Preloader component - prevent TiQ from loading if no consent, queue implicitly consented events to retrigger (for new tags only) if explicit decision is made.\n */\n\n/**\n  * @module extension-1\n  *\n  * @description The 'Pre Loader' extension component of the CMP integration, responsible for stopping Tealium iQ from loading/running as appropriate, and making certain\n  * window-scoped functions available to the other components.\n  */\n\n// Tealium iQ runs Pre Loader extensions in global scope, which would make all variables global. We don't want to do that.\n(function avoidGlobalScopeUnlessExplicit () {\n  // set names for key objects and variables to make them easy to change if needed\n\n  var version = 'v0.10-beta'\n\n  // for the consent information in the b object\n  var nameOfVendorOptInArray = 'usercentrics_services_with_consent'\n  var nameOfConsentTypeString = 'usercentrics_consent_type'\n\n  // for the name in the queue\n  var nameOfImplicitConsentArray = '_usercentrics_services_already_processed'\n\n  // name to use when calling utag.handler.trigger to indicate a consent polling call\n  var nameOfConsentPollingEvent = 'tiq_usercentrics_consent_polling'\n\n  var consentTimeoutInterval = 400 // setTimeout interval in MS - rate to poll for new (explicit) consent decision or correctly formed object\n\n  // check for the Tealium Debug cookie, see https://docs.tealium.com/platforms/javascript/debugging/\n  var tiqInDebugMode = /utagdb=true/.test(document.cookie)\n  var tealiumEnvironment = getTealiumEnvironment() || 'prod' // fall back to prod (stops logging) if something goes wrong with the function\n\n  /**\n   * A window-scoped (global) object used to expose selected functionality.\n   *\n   * @namespace tealiumCmpIntegration\n   * @type {object}\n   * @memberof! &lt;global&gt;\n   */\n  window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\n\n  /**\n   * The name of the CMP (&quot;Usercentrics Vanilla App&quot; in this case).\n   * @name cmpName\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.cmpName = 'Usercentrics Vanilla App'\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link ServiceToTagMap ServiceToTagMap}\n   * @name map\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  var map = window.tealiumCmpIntegration.map || {}\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link TagToServiceMap TagToServiceMap}\n   * @name tagBasedMap\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  generateTagBasedMap() // populates the window-level object for you as well\n\n  /**\n   * The Service Name for Tealium iQ in Usercentrics (used to decide if the TMS is allowed to run).  Uses the Usercentrics standard name if not provided.\n   * @name tiqServiceName\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   * @default 'Tealium iQ Tag Management'\n   * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.tiqServiceName = &quot;Tealium iQ Tag Management&quot;\n   */\n  var tiqServiceName = window.tealiumCmpIntegration.tiqServiceName || 'Tealium iQ Tag Management' // use the standard name here if not set\n\n  /**\n   * The current version designation.\n   * @name version\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.version = version\n\n  /**\n   * A [logger helper function]{@link module:extension-1~logger}, to help Tealium iQ users understand and troubleshoot this CMP integration without unneeded logging in production.\n   * @name logger\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.logger = logger\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentConsentDecision} that returns the current [ConsentDecision]{@link ConsentDecision}.\n   * @name getCurrentConsentDecision\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentConsentDecision = getCurrentConsentDecision\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentUsercentricsSettingsId} that returns the current Usercentrics settingsId.\n   * @name getCurrentUsercentricsSettingsId\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentUsercentricsSettingsId = getCurrentUsercentricsSettingsId\n\n  /**\n   * Records the status of the [noview]{@link https://docs.tealium.com/platforms/javascript/settings/#noview} setting on page load.\n   * @name isNoviewSet\n   * @type {boolean}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.isNoviewSet = window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noview === true\n\n  /**\n   * The name to use for the [ConsentDecision]{@link ConsentDecision} array when adding it to Tealium's b object on each event.\n   * @name nameOfVendorOptInArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfVendorOptInArray = nameOfVendorOptInArray\n\n  /**\n   * The name to use for the current [ConsentDecision]{@link ConsentDecision}'s 'type' attribute when adding it to Tealium's b object on each event.\n   * @name nameOfConsentTypeString\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfConsentTypeString = nameOfConsentTypeString\n\n  /**\n   * The name to use for the array of implicit tags (which have already been fired) in the 'data' property of {@link QueuedEvent QueuedEvent} objects.\n   * @name nameOfImplicitConsentArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfImplicitConsentArray = nameOfImplicitConsentArray\n\n  /**\n   * A [helper function]{@link module:extension-1~overrideUtagFunctions} that overrides certain utag functions to allow tags to be blocked based on CMP response.\n   *\n   * Must be called directly after the '##UTGEN##' reference by [editing]{@link https://community.tealiumiq.com/t5/iQ-Tag-Management/Managing-Tag-Templates/ta-p/21713} the 'utag loader' template, as shown in the example.\n   * @name overrideUtagFunctions\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   * @example\n// ... utag loader template ...\n\n##UTGEN##\n// override two utag functions for the Usercentrics CMP Integration, to allow tags to be blocked as needed\nwindow.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions()\n\n// ... utag loader template continues...\n\n   */\n  window.tealiumCmpIntegration.overrideUtagFunctions = overrideUtagFunctions\n\n  /**\n   * A queue for any events that Tealium iQ processes with IMPLICIT consent (to allow those events to be re-processed for new Services in the event of an EXPLICIT consent choice by the user).\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name implicitEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n\n  /**\n   * A queue for any events that are triggered before Tealium iQ AND Usercentrics have both loaded.\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name earlyEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n\n  /**\n   * Allows us to make sure we don't log certain messages more than once, especially useful while polling to avoid overwhelming the user.\n   * @function messageNotLoggedYet\n   * @param {*} messageId a string or number to uniquely identify a message for the purposes of deduplication\n   * @returns {boolean} 'true' if the message hasn't been logged yet (and should be logged), otherwise 'false'\n   */\n  var alreadyLoggedMessageIds = {}\n  function messageNotLoggedYet (messageId) {\n    var output = false\n    if (typeof alreadyLoggedMessageIds[messageId] === 'undefined') {\n      alreadyLoggedMessageIds[messageId] = true\n      output = true\n    }\n    return output\n  }\n\n  // if noload is set to 'true', don't interfere, just return to exit this function and allow that setting to stop TiQ load as usual.\n  if (window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noload === true) return false\n\n  logger('CMP integration active - Usercentrics/TiQ' + (tiqInDebugMode ? &quot;\\n\\nDEBUGGING TIP: Use /SENDING|\\\\*\\\\*\\\\*\\\\*/ in the browser console as the 'filter' to show only CMP and tag send notifications.&quot; : '\\n\\nActivate TiQ Debug Mode for more details: https://docs.tealium.com/platforms/javascript/debugging/'), true)\n  var cmpResponse = cmpConsentCheck()\n  // core business/GDPR logic, decides if TiQ should load at all\n  reactToCmpResponse(cmpResponse)\n\n  /**\n   * The core CMP integration logic, which decides if Tealium iQ should be allowed to run, or if it needs to be stopped\n   * until an understandable response that includes permission for Tealium iQ to run is found.\n   *\n   * @function reactToCmpResponse\n   * @param {object} cmpResponse The response from the Usercentrics Vanilla App\n   */\n  function reactToCmpResponse (cmpResponse) {\n    var usercentricsFound = typeof cmpResponse === 'object'\n    var foundWellFormedConsentDecision = checkForWellFormedDecision(cmpResponse)\n    var tagBasedMap = generateTagBasedMap()\n    var foundMapEntryForActiveSetting = Object.keys(tagBasedMap).length &gt; 0\n    var foundExplicitConsent = checkForExplicitConsentDecision(cmpResponse)\n    var tiqIsAllowedToFire = checkForTiqConsent(cmpResponse)\n    var tiqIsLoaded = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!usercentricsFound) {\n      /**\n       * CASE A1: no Usercentrics CMS found\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(1)) logger('No Usercentrics CMP found on page.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundMapEntryForActiveSetting) {\n      /**\n        * CASE A7: No map found for the current settingsId\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(2)) logger('No map found for current Usercentrics Setting ID.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    } else if (!foundWellFormedConsentDecision) {\n      /**\n       * CASE A2: Usercentrics CMS found but consent response wasn't well-formed/complete/understandable\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(3)) logger('Found Usercentrics CMP and got response, but didn\\'t understand the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!tiqIsAllowedToFire) {\n      /**\n       * CASE A3: Usercentrics CMS found and consent response was well-formed, BUT TiQ didn't have an opt-in\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(4)) logger('Found Usercentrics CMP and got well-formed response, but TiQ isn\\'t allowed to run based on the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundExplicitConsent) {\n      /**\n       * CASE A4: Usercentrics CMS found AND response was understandable (AND includes an implicit TiQ consent), BUT the user hasn't made an explicit decision yet\n       *\n       * ALLOW TO LOAD for any 'default opt-in' tags (filter logic in Extension B)\n       * RETRY after a delay (in case there's an explicit decision, since implicit decisions usually mean the prompt is displayed)\n       */\n      if (messageNotLoggedYet(5)) logger('Found Usercentrics CMP and got well-formed IMPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on IMPLICIT consent.\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else if (foundExplicitConsent) {\n      /**\n       * CASE A5: Usercentrics CMS found AND response was understandable, AND the user has made an explicit consent decision AND TiQ is allowed\n       *\n       * ALLOW TO LOAD for any opted-in tags (filter logic in Extension B), do not retry.\n       */\n      if (messageNotLoggedYet(6)) logger('Found Usercentrics CMP and got well-formed EXPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on EXPLICIT consent.\\n\\nNo further polling.')\n      // only call if we've been polling (on initial load, it will load automatically)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n        processImplicitQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else {\n      /**\n        * CASE A6: Something went wrong with this extension.\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(7)) logger('Something unexpected went wrong.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    }\n  }\n\n  /**\n   * Override utag.loader.initdata and utag.handler.trigger to allow Tealium iQ Tags to be blocked if the user hasn't consented.\n   *\n   * @function overrideUtagFunctions\n   * @returns {boolean} 'true' if the function was overridden successfully by this request, 'false' if not (because it was already overridden)\n   */\n  function overrideUtagFunctions () {\n    // don't override more than once, assume that if one function has been overridden, both have\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    // the initial view is handled differently than subsequent events\n    // this is safe to to override even if noview is set (because it will never be called in that case)\n    window.utag.loader.initdata_old = window.utag.loader.initdata\n    window.utag.loader.initdata = newUtagLoaderInitdata\n\n    window.utag.handler.trigger_old = window.utag.handler.trigger\n    window.utag.handler.trigger = newUtagHandlerTrigger\n    logger('Overrode utag functions!')\n\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * An overridden version of the Tealium iQ function utag.loader.initdata.\n   *\n   * Calls the original function, respects possible noview settings, rechecks the user consent, and calls queueEventWithoutFiringImplicitServices\n   * if only an IMPLICIT consent is found (after recording the IMPLICIT services, to avoid double-firing).\n   *\n   * That same event can then be re-processed for any new Services if an EXPLICIT consent decision later made.\n   *\n   * @function newUtagLoaderInitdata\n   */\n  function newUtagLoaderInitdata () {\n    window.utag.loader.initdata_old()\n    // make sure we don't queue this initial page load twice, and respect the configured noview setting\n    if (!window.tealiumCmpIntegration.isNoviewSet &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n      window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n      var consentedServices = getCurrentConsentDecision()\n      if (consentedServices.type === 'implicit') {\n        window.tealiumCmpIntegration.implicitServices = consentedServices\n        // we don't need to fire implicit services in this case, because TiQ's loading process will fire them\n        queueEventWithoutFiringImplicitServices({\n          event: 'view',\n          data: window.utag.handler.C(window.utag.data)\n        })\n      }\n    }\n  }\n\n  /**\n   * Refresh [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration.tagBasedMap} and return that new map, helps smooth out any timing issues between Usercentrics and Tealium iQ load.\n   *\n   * @function generateTagBasedMap\n   * @returns a [TagToServiceMap]{@link TagToServiceMap}\n   */\n  function generateTagBasedMap () {\n    var tagBasedMap = getTagBasedMap(map)\n    window.tealiumCmpIntegration.tagBasedMap = tagBasedMap\n    return tagBasedMap\n  }\n\n  /**\n   * Tealium iQ's utag.handler.trigger normally causes tags to fire. For this integration, we override that function to support blocking tags without consent.\n   *\n   * @function newUtagHandlerTrigger\n   *\n   * @param {*} a can be an object or a string\n   * @param {*} b\n   * @param {*} c\n   */\n  function newUtagHandlerTrigger (a, b, c) {\n    /**\n     * Trigger CASES (utag.handler.trigger override)\n     *\n     * We need to queue the events if we only have implicit consent, to allow a selective retrigger if/when we get an explicit decision.\n     */\n    var isPureConsentEvent = (a === nameOfConsentPollingEvent &amp;&amp; !b &amp;&amp; !c)\n    var isNoviewSet = window.tealiumCmpIntegration.isNoviewSet || true // assume noview if something went wrong with the global, to avoid firing tracking in error\n\n    var consentedServices = getCurrentConsentDecision()\n    var consentType = (consentedServices &amp;&amp; consentedServices.type) || 'none'\n\n    var isUsercentricsReady = consentType === 'implicit' || consentType === 'explicit'\n    var isTealiumReady = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!isPureConsentEvent) {\n      logger('utag.handler.trigger called with:\\n\\n' + JSON.stringify(arguments, null, 2))\n    }\n\n    if (!isUsercentricsReady &amp;&amp; !isTealiumReady) {\n      consentedServices.type = 'tealium-and-usercentrics-loading'\n      logger('Waiting for Usercentrics and Tealium to be ready, queueing early event.')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isUsercentricsReady) {\n      consentedServices.type = 'usercentrics-loading'\n      logger('Usercentrics is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isTealiumReady) {\n      consentedServices.type = 'tealium-still-loading'\n      logger('Tealium iQ is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    }\n\n    // if an array of tagUids is passed, that forces them to fire regardless of load rules\n    // or consent, so we need to filter that array before allowing it to be processed\n    var hasTagUidArray = c &amp;&amp; typeof c === 'object' &amp;&amp; c.uids &amp;&amp; c.uids &amp;&amp; window.utag.ut.typeOf(c.uids) === 'array'\n    var uidMap = generateTagBasedMap()\n    var allowedTagUids = []\n    var blockedTagUids = []\n    var serviceName\n    var tagUid\n    if (hasTagUidArray) {\n      for (var i = 0; i &lt; c.uids.length; i++) {\n        tagUid = c.uids[i]\n        serviceName = uidMap[tagUid] || '(missing)'\n        // only push consented services into the new array\n        if (consentedServices.indexOf(serviceName) !== -1) {\n          allowedTagUids.push(tagUid)\n        } else {\n          blockedTagUids.push(tagUid)\n        }\n      }\n      // replace the original with the filtered array (can also be empty, if none of them were allowed)\n      logger('Call included tagUid array:\\n\\n' + JSON.stringify(c.uids) + '\\n\\nwhich was replaced by the filtered version:\\n\\n' + JSON.stringify(allowedTagUids))\n      c.originalUids = c.uids.slice() // make a shallow copy\n      c.uids = allowedTagUids\n      c.blockedTagUids = blockedTagUids\n    }\n\n    if (consentType === 'explicit') {\n      /**\n       * CASE T2: expected globals are populated, consent is EXPLICIT\n       *\n       * FIRE allowed tags (explicit)\n       * utag.handler.trigger override PROCESSES the queue, which will include any queued events from CASE A4, making sure not to re-fire any default\n       *   opt-in tags that were already fired for the queued events\n       */\n      // make sure TiQ loads\n      processEarlyQueue()\n      processImplicitQueue()\n      triggerTiqLoad()\n      // fire the current event if it's not just a polling event\n      if (!isPureConsentEvent) {\n        return window.utag.handler.trigger_old(a, b, c)\n      }\n    } else if (consentType === 'implicit') {\n      /**\n       * CASE T3: expected globals are populated, consent is IMPLICIT\n       *\n       * FIRE allowed tags (implicit)\n       * utag.handler.trigger override KEEPS a queue/record that includes\n       *  - the event(s) that were processed based on implicit consent\n       *  - which tags were allowed to process each event (are set to implicit opt-in)\n       */\n      processEarlyQueue()\n      // fire the initial view if appropriate, and queue it\n      triggerTiqLoad()\n      window.tealiumCmpIntegration.implicitServices = consentedServices\n\n      // queue the initial 'view' on pageload if appropriate\n      if (!isNoviewSet &amp;&amp; isTealiumReady &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n        window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n        queueEventAndFireImplicitServices('view', window.utag.handler.C(window.utag.data))\n      }\n      // queue the current event if it exists (and this isn't just consent polling)\n      if (!isPureConsentEvent) {\n        return queueEventAndFireImplicitServices(a, b, c)\n      }\n    } else if (consentType === 'missing-map') {\n      logger('Something went wrong - all tags were blocked because no consent map was found for the active setting ID.')\n      return false\n    } else if (consentType === 'missing-tiq-consent') {\n      logger('Something went wrong - all tags were blocked because no consent was found for &quot;' + tiqServiceName + '&quot;, configured Tealium iQ name.\\n\\nConsent found: ' + JSON.stringify(consentedServices, null, 2))\n      return false\n    } else {\n      /**\n       * CASE T1: expected variables not populated (misconfiguration/error case)\n       *\n       * STOP and fire nothing at all. Do not retry or queue the event.\n       */\n      logger('Something went wrong - all tags were blocked because the consent response was not understood.')\n      return false\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the early event queue]{@link tealiumCmpIntegration.earlyEventQueue} (can include pageviews) for any currently-consented Services.\n   *\n   * Intended to be called first understandable implicit consent.\n   *\n   * @function processEarlyQueue\n   */\n  function processEarlyQueue () {\n    var queuedEvent\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    while (window.tealiumCmpIntegration.earlyEventQueue.length &gt; 0) {\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.earlyEventQueue.shift()\n      logger('Processing queued early event for currently consented tags: ' + JSON.stringify(queuedEvent, null, 2))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the global queue]{@link tealiumCmpIntegration.implicitEventQueue} (can include pageviews) for any newly-consented Services.\n   *\n   * Intended to be called on new EXPLICIT consent decision - queued events have already had IMPLICTLY consented tags fired, so those need to be excluded.\n   *\n   * @function processImplicitQueue\n   */\n  function processImplicitQueue () {\n    var alreadyLogged = false\n    var queuedEvent\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    while (window.tealiumCmpIntegration.implicitEventQueue.length &gt; 0) {\n      if (!alreadyLogged) {\n        alreadyLogged = true\n        logger('Explicit consent tracking request received - processing past implicitly tracked events (' + window.tealiumCmpIntegration.implicitEventQueue.length + ') for any new explicit tags.')\n      }\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.implicitEventQueue.shift()\n      logger('Triggering event for explicitly-consented tags: ' + JSON.stringify(queuedEvent))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the early queue]{@link tealiumCmpIntegration.earlyEventQueue}, without firing any tags.\n   *\n   * Intended to be called for events that triggered before we get an understandable response from Usercentrics.\n   *\n   * @function queueEarlyEvent\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEarlyEvent (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    // nothing will be allowed to fire\n    a.data[nameOfImplicitConsentArray] = []\n\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    window.tealiumCmpIntegration.earlyEventQueue.push(a)\n    logger('Queued early event!')\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration.implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for the initial pageview on load, since the load process will have already fired the implicit services.\n   *\n   * @function queueEventWithoutFiringImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventWithoutFiringImplicitServices (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    a.data[nameOfImplicitConsentArray] = window.tealiumCmpIntegration.implicitServices || []\n\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    window.tealiumCmpIntegration.implicitEventQueue.push(a)\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration~implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for all events other than the initial page load.\n   *\n   * @function queueEventAndFireImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventAndFireImplicitServices (a, b, c) {\n    // fire the implicit tags\n    window.utag.handler.trigger_old(a, b, c)\n    logger('Implicit consent tracking request fired (or queued, if utag hasn\\'t loaded).')\n    return queueEventWithoutFiringImplicitServices(a, b, c)\n  }\n\n  /**\n   * Generate a {@link TagToServiceMap TagToServiceMap} based on a {@link ServiceToTagMap ServiceToTagMap}\n   *\n   * @function getTagBasedMap\n   * @param {object} map a {@link ServiceToTagMap ServiceToTagMap} object\n   * @return {object} a {@link TagToServiceMap TagToServiceMap}\n   */\n  function getTagBasedMap (map) {\n    // generate a lookup based on the tagUid\n    if (typeof map !== 'object') return {}\n    var settingsId = getCurrentUsercentricsSettingsId() || ''\n    if (typeof settingsId !== 'string' || settingsId === '') return {}\n    var settingSpecificMap = map[settingsId] || {}\n    var serviceNames = Object.keys(settingSpecificMap)\n    var uidMap = {}\n    for (var i = 0; i &lt; serviceNames.length; i++) {\n      for (var j = 0; j &lt; settingSpecificMap[serviceNames[i]].length; j++) {\n        uidMap[settingSpecificMap[serviceNames[i]][j]] = serviceNames[i]\n      }\n    }\n    return uidMap\n  }\n\n  /**\n   * Get the current Usercentrics settingsId from the page.\n   *\n   * @returns {string} the Usercentrics settingsId, defaults to an empty string if none is found\n   */\n  function getCurrentUsercentricsSettingsId () {\n    return (window.usercentrics &amp;&amp; window.usercentrics.settingsId) || ''\n  }\n\n  /**\n   * Trigger the core logic with an up-to-date array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   * @function recheckForCmpAndConsent\n   */\n  function recheckForCmpAndConsent () {\n    var newConsentResponse = cmpConsentCheck()\n    reactToCmpResponse(newConsentResponse)\n  }\n\n  /**\n   * Call [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents} to get the current consent decision.\n   * @function cmpConsentCheck\n   */\n  function cmpConsentCheck () {\n    if (!window.usercentrics || typeof window.usercentrics.getConsents !== 'function') return false\n    var cmpConsentArray = window.usercentrics.getConsents()\n    return cmpConsentArray\n  }\n\n  /**\n   * Indicates if Usercentrics has loaded and returned a well-formed indication of user consent.\n   * @function checkForWellFormedDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is well-formed, otherwise 'false'\n   */\n  function checkForWellFormedDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; typeof cmpConsentArray[0].dataProcessingService === 'string') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if the user has made an EXPLICIT decision\n   * @function checkForExplicitConsentDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is EXPLICIT otherwise 'false'\n   */\n  function checkForExplicitConsentDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; cmpConsentArray[0].updatedBy === 'explicit') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if Tealium iQ has permission to run (and fire tags).\n   * @function checkForTiqConsent\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if TiQ is allowed to run, otherwise 'false'\n   */\n  function checkForTiqConsent (cmpConsentArray) {\n    var foundOptIn = false\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // check vendors if there's an object, look for at least one\n    cmpConsentArray.forEach(function (tagInfo) {\n      if (tagInfo.consentStatus === true &amp;&amp; tagInfo.dataProcessingService === tiqServiceName) {\n        foundOptIn = true\n      }\n    })\n    return foundOptIn\n  }\n\n  /**\n   * Create an instance of\n   * @param {array} cmpConsentArray the array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   */\n  function getVendorConsentsFromCmpConsentArray (cmpConsentArray) {\n    var vendorArray = []\n\n    var isWellFormed = checkForWellFormedDecision(cmpConsentArray)\n\n    if (!isWellFormed) {\n      vendorArray.type = 'missing-well-formed-response'\n      return []\n    }\n\n    var tagBasedMap = generateTagBasedMap()\n\n    // if there is no mapping for the settings id, we need to change the console output\n    var currentSettingsIdHasMapping = (typeof tagBasedMap === 'object' &amp;&amp; Object.keys(tagBasedMap).length &gt; 0)\n\n    if (!currentSettingsIdHasMapping) {\n      vendorArray.type = 'missing-map'\n      return []\n    }\n\n    cmpConsentArray &amp;&amp; cmpConsentArray.forEach(function (tagConsent) {\n      if (tagConsent.consentStatus === true) {\n        vendorArray.push(tagConsent.dataProcessingService)\n      }\n    })\n    vendorArray.type = checkForExplicitConsentDecision(cmpConsentArray) ? 'explicit' : 'implicit'\n\n    if (checkForTiqConsent(cmpConsentArray) === false) {\n      // change the consent type, but leave the array for debugging purposes\n      vendorArray.type = 'missing-tiq-consent'\n    }\n\n    return vendorArray\n  }\n\n  /**\n   * Get the current consent decision from the CMP for the active Setting\n   * @function getCurrentConsentDecision\n   * @returns a {@link ConsentDecision ConsentDecision}\n   */\n  function getCurrentConsentDecision () {\n    var freshConsent = cmpConsentCheck()\n\n    return getVendorConsentsFromCmpConsentArray(freshConsent)\n  }\n\n  /**\n   *  A conditional logging function - we can't use utag.DB directly because some of our logic needs to be preloader, but we can mimic the same logic so that our logging only displays when TiQ is in debug mode and/or not in Prod, or is explicitly forced.\n   * @function logger\n   * @param {string} message the message to be conditionally shown\n   * @param {boolean} showOutsideDebugMode if 'true', forces the message to shown outside of debug mode, except on Prod\n   */\n  function logger (message, showOutsideDebugMode) {\n    if (typeof tealiumEnvironment === 'undefined' || tealiumEnvironment === 'prod') {\n      // don't allow anything outside of debug mode on prod (disable this flag)\n      showOutsideDebugMode = false\n    }\n\n    if (showOutsideDebugMode || tiqInDebugMode) {\n      message = '\\n' + message + '\\n'\n      var formattedArr = []\n      formattedArr.push('****************')\n      var messageArr = message.split('\\n')\n      messageArr.forEach(function (messageLine) {\n        formattedArr.push('*  ' + messageLine)\n      })\n      formattedArr.push('****************')\n      var outputString = formattedArr.join('\\n')\n      console.log(outputString)\n    }\n  }\n\n  /**\n   * Stops Tealium iQ from loading (the TMS will not load tags or set a cookie if this function is called in Pre Loader), using the {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} setting\n   * @function stopTiq\n   */\n  function stopTiq () {\n    // logger(&quot;stopTiq function fired&quot;)\n    window.utag_cfg_ovrd = window.utag_cfg_ovrd || {}\n    window.utag_cfg_ovrd.noload = true\n  }\n\n  /**\n   * Allows TiQ to finish loading, intended to be called when a well-formed consent response is received, and that response allows Tealium iQ to run.\n   *\n   * Works by setting {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} to 'false' and calling Tealium iQ's utag.loader.PINIT method.\n   *\n   * If noload was 'true' and this function runs it must've been set to true by our own {@link module:extension-1~stopTiq stopTiq} function, because otherwise Tealium iQ wouldn't have been allowed to load/poll in the first place.\n   * @function triggerTiqLoad\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function triggerTiqLoad () {\n    // if usercentrics is ready on the first request, TiQ won't have loaded yet at all - let it load naturally\n    if (!window.utag) {\n      return true\n    }\n    // if TiQ has already loaded but these flags aren't truthy, we've interrupted the load and should retrigger it\n    // initial load / view (noview logic handled in utag.handler.trigger function itself)\n    if (!window.utag.handler || !window.utag.handler.iflag) {\n      // we don't need to reload actually, just allow it to finish loading\n      window.utag.cfg.noload = false // safe because this code only runs if it was set to false originally\n      window.utag.loader.PINIT()\n      return true\n    }\n    // already loaded\n    return false\n  }\n\n  /**\n   * If Tealium iQ hasn't loaded, load it (calling utag.handler.trigger in the process), otherwise call utag.handler.trigger.\n   * @function triggerOrQueue\n   */\n  function triggerOrQueue () {\n    var successfullyTriggeredLoadIfNeeded = triggerTiqLoad()\n    if (!successfullyTriggeredLoadIfNeeded) {\n      // explicit consent from polling, but load has already been triggered\n      return window.utag.handler.trigger(nameOfConsentPollingEvent)\n    }\n  }\n  /**\n   * Get the the current Tealium iQ environment.\n   *\n   * Since this runs in Pre Loader, it needs to use regex to recognize the utag.js file in the DOM and read the environment from the file name (there are no utag functions or objects at this point in the load).\n   *\n   * NOTE: This doesn't work correctly when using the the Environment Switcher (because the original script is added to the DOM instead of the new one, and the 307 redirect that's used to pull the new file(s) only changes the response, not the script element itself).\n   *\n   * If you're using the Environment Switcher on Prod and would like to see console output, set the [debug cookie]{@link https://docs.tealium.com/platforms/javascript/debugging/}.\n   *\n   * @function getTealiumEnvironment\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function getTealiumEnvironment () {\n    var allScripts = document.getElementsByTagName('script')\n    var re = /\\/([^/]*)\\/utag\\.js(\\?.*)*$/\n    for (var i = 0; i &lt; allScripts.length; i++) {\n      var result = re.exec(allScripts[i].src) // can be null\n      if (result &amp;&amp; result[1]) { // [1] is the result of the match\n        return result[1]\n      }\n    }\n    return 'prod' // default to guessing we're in prod, just in case we're actually in prod (to avoid logging in Prod)\n  }\n})()\n\n// Document key data structures here for clarity.\n\n/**\n * An array of Usercentrics Service Names that have permission to run (uses the 'dataProcessingService' property from [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}).\n *\n * Also includes a 'type' property that indicates whether the consent decision is IMPLICIT or EXPLICT.\n *\n * @static\n * @type {array}\n * @name ConsentDecision\n * @memberof! &lt;global&gt;\n * @property {string} type the type of consent, will be either 'implicit' or 'explicit'\n * @example\nvar exampleConsentDecision = window.tealiumCmpIntegration.getCurrentConsentDecision()\n\nJSON.stringify(exampleConsentDecision)\n// [&quot;Google Analytics&quot;,&quot;Another Tag&quot;,&quot;Tealium iQ Tag Management&quot;]\n\nexampleConsentDecision.type\n// &quot;explicit&quot;\n\nexampleConsentDecision.length\n// 3\n */\n\n/**\n * Assigns Tealium iQ Tags to Usercentrics Service Names. Each service can have multiple tags, but each tag can only have one service.  If the same tag UID appears in multiple Service arrays, only one will be used.\n *\n * The keys for the main object are Setting-IDs from Usercentrics, inside that are key/value pairs where the key is a Service Name from Usercentrics, and the value is an array of TagUIDs from Tealium iQ.\n *\n * This needs to be provided as per the example below, in [tealiumCmpIntegration.map]{@link namespace:tealiumCmpIntegration~map}.\n *\n * An [example Tealium iQ extension]{@link module:example-map} is provided as well.\n *\n * @static\n * @type {object}\n * @name ServiceToTagMap\n * @memberof! &lt;global&gt;\n * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n  'yPyIAIIxY': {\n    'Google Analytics': [6, 8, 10],\n    'Mouseflow': [7, 9],\n    'Another Tag': [11]\n  }\n}\n */\n\n/**\n * A simple lookup, with Tealium iQ tag UIDs as keys and the associated Usercentrics service name as strings as values. Each service can be associated with multiple tags, but each tag can be associated with one service.\n *\n * The example is based on the {@link ServiceToTagMap ServiceToTagMap} example, where the Usercentrics settingsId on the active page is 'yPyIAIIxY'.\n *\n * This object is automatically generated by the [getTagBasedMap]{@link module:extension-1~getTagbasedMap} method, and made available globally in [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration~tagBasedMap} for debugging and use within the extensions.\n *\n * @static\n * @type {object}\n * @name TagToServiceMap\n * @memberof! &lt;global&gt;\n * @example\n{\n  6: 'Google Analytics',\n  7: 'Mouseflow',\n  8: 'Google Analytics',\n  9: 'Mouseflow',\n  10: 'Google Analytics',\n  11: 'Another Tag'\n}\n */\n\n/**\n * An object from the [implicitEventQueue]{@link tealiumCmpIntegration.implicitEventQueue} or [earlyEventQueue]{@link tealiumCmpIntegration.earlyEventQueue}, which represents a Tealium iQ tracking event that's been processed based on an IMPLICIT [ConsentDecision]{@link ConsentDecision}\n *\n * Heavily based on the argument passed to [utag.track]{@link https://community.tealiumiq.com/t5/Tealium-iQ-Tag-Management/utag-track-method/td-p/24578}, since it's designed to be processed by that method.\n *\n * Initial pageviews (handled in the [utag.loader.initdata override]{@link module:extension-1~newUtagLoaderInitdata}) will NOT have metadata like cookies, qps, etc - utag.track calls (handled in the [utag.handler.trigger override]{@link module:extension-1~newUtagHandlerTrigger}) will. That's a byproduct of using utag.handler.trigger, which is later in the load - those metadata will be re-read when the queue is processed, and since this queue isn't persisted between pages, it should be fine like that - the only strange behavior will be that any metadata that aren't present on re-read will still be present after the re-read - only values that are still present will be replaced with new values.\n *\n * An alternative approach could be to manually remove 'cp.\\*', 'dom.\\*', 'ut.\\*', 'qp.\\*', 'meta.\\*' and possibly 'tealium_\\*' (except 'tealium_event') from the 'data' object before queueing - that hasn't been done so far.\n *\n * @static\n * @type {array}\n * @name QueuedEvent\n * @memberof! &lt;global&gt;\n * @property {string} event the type of tracking event, generally 'view' for pageviews or 'link' for other events\n * @property {object} data the Universal Data Object associated with the event (from utag_data or the b object)\n * @property {object} cfg an optional configuration object that can have a 'cb' property (for a callback function) and a 'uids' array, which is a list of tag UIDs that should be triggered by the event, regardless of whether load rules are met.\n * @example\n{\n  &quot;event&quot;: &quot;view&quot;,\n  &quot;data&quot;: {\n    &quot;page_type&quot;: &quot;test_virtual_view&quot;,\n    &quot;cp.utag_main_v_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;cp.utag_main__sn&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__se&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__ss&quot;: &quot;0&quot;,\n    &quot;cp.utag_main__st&quot;: &quot;1598990152209&quot;,\n    &quot;cp.utag_main_ses_id&quot;: &quot;1598988112353&quot;,\n    &quot;cp.utag_main__pn&quot;: &quot;3&quot;,\n    &quot;cp.utagdb&quot;: &quot;true&quot;,\n    &quot;dom.referrer&quot;: &quot;&quot;,\n    &quot;dom.title&quot;: &quot;Usercentrics Test&quot;,\n    &quot;dom.domain&quot;: &quot;solutions.tealium.net&quot;,\n    &quot;dom.query_string&quot;: &quot;&quot;,\n    &quot;dom.hash&quot;: &quot;&quot;,\n    &quot;dom.url&quot;: &quot;https://solutions.tealium.net/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.pathname&quot;: &quot;/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.viewport_height&quot;: 456,\n    &quot;dom.viewport_width&quot;: 1825,\n    &quot;ut.domain&quot;: &quot;tealium.net&quot;,\n    &quot;ut.version&quot;: &quot;ut4.46.202009011921&quot;,\n    &quot;ut.event&quot;: &quot;view&quot;,\n    &quot;ut.visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;ut.session_id&quot;: &quot;1598988112353&quot;,\n    &quot;ut.account&quot;: &quot;services-caleb&quot;,\n    &quot;ut.profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;ut.env&quot;: &quot;prod&quot;,\n    &quot;tealium_event&quot;: &quot;view&quot;,\n    &quot;tealium_visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;tealium_session_id&quot;: &quot;1598988112353&quot;,\n    &quot;tealium_session_number&quot;: &quot;4&quot;,\n    &quot;tealium_session_event_number&quot;: &quot;4&quot;,\n    &quot;tealium_datasource&quot;: &quot;&quot;,\n    &quot;tealium_account&quot;: &quot;services-caleb&quot;,\n    &quot;tealium_profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;tealium_environment&quot;: &quot;prod&quot;,\n    &quot;tealium_random&quot;: &quot;2085060854215077&quot;,\n    &quot;tealium_library_name&quot;: &quot;utag.js&quot;,\n    &quot;tealium_library_version&quot;: &quot;4.46.0&quot;,\n    &quot;tealium_timestamp_epoch&quot;: 1598988352,\n    &quot;tealium_timestamp_utc&quot;: &quot;2020-09-01T19:25:52.211Z&quot;,\n    &quot;tealium_timestamp_local&quot;: &quot;2020-09-01T21:25:52.211&quot;,\n    &quot;usercentrics_services_with_consent&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ],\n    &quot;usercentrics_consent_type&quot;: &quot;implicit&quot;,\n    &quot;_usercentrics_services_already_processed&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ]\n  },\n  &quot;cfg&quot;: {\n    &quot;cb&quot;: function myCallback () {console.log(&quot;Callback fired!&quot;)},\n    &quot;uids&quot;: [\n      11\n    ],\n    &quot;originalUids&quot;: [\n      7,\n      11\n    ],\n    &quot;blockedTagUids&quot;: [\n      11\n    ]\n  }\n}\n*/\n","name":"qa","promotedTimestamp":"202011040723","promotedDraftName":"extension-1.js","promotedBy":"caleb.jaquith@tealium.com"},"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202011040723","promotedDraftName":"extension-1.js","name":"dev","code":"/**\n *  Scope       : Pre Loader\n *  Condition   : n/a\n *  Description : CMP 1/2 - Preloader component - prevent TiQ from loading if no consent, queue implicitly consented events to retrigger (for new tags only) if explicit decision is made.\n */\n\n/**\n  * @module extension-1\n  *\n  * @description The 'Pre Loader' extension component of the CMP integration, responsible for stopping Tealium iQ from loading/running as appropriate, and making certain\n  * window-scoped functions available to the other components.\n  */\n\n// Tealium iQ runs Pre Loader extensions in global scope, which would make all variables global. We don't want to do that.\n(function avoidGlobalScopeUnlessExplicit () {\n  // set names for key objects and variables to make them easy to change if needed\n\n  var version = 'v0.10-beta'\n\n  // for the consent information in the b object\n  var nameOfVendorOptInArray = 'usercentrics_services_with_consent'\n  var nameOfConsentTypeString = 'usercentrics_consent_type'\n\n  // for the name in the queue\n  var nameOfImplicitConsentArray = '_usercentrics_services_already_processed'\n\n  // name to use when calling utag.handler.trigger to indicate a consent polling call\n  var nameOfConsentPollingEvent = 'tiq_usercentrics_consent_polling'\n\n  var consentTimeoutInterval = 400 // setTimeout interval in MS - rate to poll for new (explicit) consent decision or correctly formed object\n\n  // check for the Tealium Debug cookie, see https://docs.tealium.com/platforms/javascript/debugging/\n  var tiqInDebugMode = /utagdb=true/.test(document.cookie)\n  var tealiumEnvironment = getTealiumEnvironment() || 'prod' // fall back to prod (stops logging) if something goes wrong with the function\n\n  /**\n   * A window-scoped (global) object used to expose selected functionality.\n   *\n   * @namespace tealiumCmpIntegration\n   * @type {object}\n   * @memberof! &lt;global&gt;\n   */\n  window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\n\n  /**\n   * The name of the CMP (&quot;Usercentrics Vanilla App&quot; in this case).\n   * @name cmpName\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.cmpName = 'Usercentrics Vanilla App'\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link ServiceToTagMap ServiceToTagMap}\n   * @name map\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  var map = window.tealiumCmpIntegration.map || {}\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link TagToServiceMap TagToServiceMap}\n   * @name tagBasedMap\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  generateTagBasedMap() // populates the window-level object for you as well\n\n  /**\n   * The Service Name for Tealium iQ in Usercentrics (used to decide if the TMS is allowed to run).  Uses the Usercentrics standard name if not provided.\n   * @name tiqServiceName\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   * @default 'Tealium iQ Tag Management'\n   * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.tiqServiceName = &quot;Tealium iQ Tag Management&quot;\n   */\n  var tiqServiceName = window.tealiumCmpIntegration.tiqServiceName || 'Tealium iQ Tag Management' // use the standard name here if not set\n\n  /**\n   * The current version designation.\n   * @name version\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.version = version\n\n  /**\n   * A [logger helper function]{@link module:extension-1~logger}, to help Tealium iQ users understand and troubleshoot this CMP integration without unneeded logging in production.\n   * @name logger\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.logger = logger\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentConsentDecision} that returns the current [ConsentDecision]{@link ConsentDecision}.\n   * @name getCurrentConsentDecision\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentConsentDecision = getCurrentConsentDecision\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentUsercentricsSettingsId} that returns the current Usercentrics settingsId.\n   * @name getCurrentUsercentricsSettingsId\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentUsercentricsSettingsId = getCurrentUsercentricsSettingsId\n\n  /**\n   * Records the status of the [noview]{@link https://docs.tealium.com/platforms/javascript/settings/#noview} setting on page load.\n   * @name isNoviewSet\n   * @type {boolean}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.isNoviewSet = window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noview === true\n\n  /**\n   * The name to use for the [ConsentDecision]{@link ConsentDecision} array when adding it to Tealium's b object on each event.\n   * @name nameOfVendorOptInArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfVendorOptInArray = nameOfVendorOptInArray\n\n  /**\n   * The name to use for the current [ConsentDecision]{@link ConsentDecision}'s 'type' attribute when adding it to Tealium's b object on each event.\n   * @name nameOfConsentTypeString\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfConsentTypeString = nameOfConsentTypeString\n\n  /**\n   * The name to use for the array of implicit tags (which have already been fired) in the 'data' property of {@link QueuedEvent QueuedEvent} objects.\n   * @name nameOfImplicitConsentArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfImplicitConsentArray = nameOfImplicitConsentArray\n\n  /**\n   * A [helper function]{@link module:extension-1~overrideUtagFunctions} that overrides certain utag functions to allow tags to be blocked based on CMP response.\n   *\n   * Must be called directly after the '##UTGEN##' reference by [editing]{@link https://community.tealiumiq.com/t5/iQ-Tag-Management/Managing-Tag-Templates/ta-p/21713} the 'utag loader' template, as shown in the example.\n   * @name overrideUtagFunctions\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   * @example\n// ... utag loader template ...\n\n##UTGEN##\n// override two utag functions for the Usercentrics CMP Integration, to allow tags to be blocked as needed\nwindow.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions()\n\n// ... utag loader template continues...\n\n   */\n  window.tealiumCmpIntegration.overrideUtagFunctions = overrideUtagFunctions\n\n  /**\n   * A queue for any events that Tealium iQ processes with IMPLICIT consent (to allow those events to be re-processed for new Services in the event of an EXPLICIT consent choice by the user).\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name implicitEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n\n  /**\n   * A queue for any events that are triggered before Tealium iQ AND Usercentrics have both loaded.\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name earlyEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n\n  /**\n   * Allows us to make sure we don't log certain messages more than once, especially useful while polling to avoid overwhelming the user.\n   * @function messageNotLoggedYet\n   * @param {*} messageId a string or number to uniquely identify a message for the purposes of deduplication\n   * @returns {boolean} 'true' if the message hasn't been logged yet (and should be logged), otherwise 'false'\n   */\n  var alreadyLoggedMessageIds = {}\n  function messageNotLoggedYet (messageId) {\n    var output = false\n    if (typeof alreadyLoggedMessageIds[messageId] === 'undefined') {\n      alreadyLoggedMessageIds[messageId] = true\n      output = true\n    }\n    return output\n  }\n\n  // if noload is set to 'true', don't interfere, just return to exit this function and allow that setting to stop TiQ load as usual.\n  if (window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noload === true) return false\n\n  logger('CMP integration active - Usercentrics/TiQ' + (tiqInDebugMode ? &quot;\\n\\nDEBUGGING TIP: Use /SENDING|\\\\*\\\\*\\\\*\\\\*/ in the browser console as the 'filter' to show only CMP and tag send notifications.&quot; : '\\n\\nActivate TiQ Debug Mode for more details: https://docs.tealium.com/platforms/javascript/debugging/'), true)\n  var cmpResponse = cmpConsentCheck()\n  // core business/GDPR logic, decides if TiQ should load at all\n  reactToCmpResponse(cmpResponse)\n\n  /**\n   * The core CMP integration logic, which decides if Tealium iQ should be allowed to run, or if it needs to be stopped\n   * until an understandable response that includes permission for Tealium iQ to run is found.\n   *\n   * @function reactToCmpResponse\n   * @param {object} cmpResponse The response from the Usercentrics Vanilla App\n   */\n  function reactToCmpResponse (cmpResponse) {\n    var usercentricsFound = typeof cmpResponse === 'object'\n    var foundWellFormedConsentDecision = checkForWellFormedDecision(cmpResponse)\n    var tagBasedMap = generateTagBasedMap()\n    var foundMapEntryForActiveSetting = Object.keys(tagBasedMap).length &gt; 0\n    var foundExplicitConsent = checkForExplicitConsentDecision(cmpResponse)\n    var tiqIsAllowedToFire = checkForTiqConsent(cmpResponse)\n    var tiqIsLoaded = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!usercentricsFound) {\n      /**\n       * CASE A1: no Usercentrics CMS found\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(1)) logger('No Usercentrics CMP found on page.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundMapEntryForActiveSetting) {\n      /**\n        * CASE A7: No map found for the current settingsId\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(2)) logger('No map found for current Usercentrics Setting ID.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    } else if (!foundWellFormedConsentDecision) {\n      /**\n       * CASE A2: Usercentrics CMS found but consent response wasn't well-formed/complete/understandable\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(3)) logger('Found Usercentrics CMP and got response, but didn\\'t understand the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!tiqIsAllowedToFire) {\n      /**\n       * CASE A3: Usercentrics CMS found and consent response was well-formed, BUT TiQ didn't have an opt-in\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(4)) logger('Found Usercentrics CMP and got well-formed response, but TiQ isn\\'t allowed to run based on the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundExplicitConsent) {\n      /**\n       * CASE A4: Usercentrics CMS found AND response was understandable (AND includes an implicit TiQ consent), BUT the user hasn't made an explicit decision yet\n       *\n       * ALLOW TO LOAD for any 'default opt-in' tags (filter logic in Extension B)\n       * RETRY after a delay (in case there's an explicit decision, since implicit decisions usually mean the prompt is displayed)\n       */\n      if (messageNotLoggedYet(5)) logger('Found Usercentrics CMP and got well-formed IMPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on IMPLICIT consent.\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else if (foundExplicitConsent) {\n      /**\n       * CASE A5: Usercentrics CMS found AND response was understandable, AND the user has made an explicit consent decision AND TiQ is allowed\n       *\n       * ALLOW TO LOAD for any opted-in tags (filter logic in Extension B), do not retry.\n       */\n      if (messageNotLoggedYet(6)) logger('Found Usercentrics CMP and got well-formed EXPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on EXPLICIT consent.\\n\\nNo further polling.')\n      // only call if we've been polling (on initial load, it will load automatically)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n        processImplicitQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else {\n      /**\n        * CASE A6: Something went wrong with this extension.\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(7)) logger('Something unexpected went wrong.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    }\n  }\n\n  /**\n   * Override utag.loader.initdata and utag.handler.trigger to allow Tealium iQ Tags to be blocked if the user hasn't consented.\n   *\n   * @function overrideUtagFunctions\n   * @returns {boolean} 'true' if the function was overridden successfully by this request, 'false' if not (because it was already overridden)\n   */\n  function overrideUtagFunctions () {\n    // don't override more than once, assume that if one function has been overridden, both have\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    // the initial view is handled differently than subsequent events\n    // this is safe to to override even if noview is set (because it will never be called in that case)\n    window.utag.loader.initdata_old = window.utag.loader.initdata\n    window.utag.loader.initdata = newUtagLoaderInitdata\n\n    window.utag.handler.trigger_old = window.utag.handler.trigger\n    window.utag.handler.trigger = newUtagHandlerTrigger\n    logger('Overrode utag functions!')\n\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * An overridden version of the Tealium iQ function utag.loader.initdata.\n   *\n   * Calls the original function, respects possible noview settings, rechecks the user consent, and calls queueEventWithoutFiringImplicitServices\n   * if only an IMPLICIT consent is found (after recording the IMPLICIT services, to avoid double-firing).\n   *\n   * That same event can then be re-processed for any new Services if an EXPLICIT consent decision later made.\n   *\n   * @function newUtagLoaderInitdata\n   */\n  function newUtagLoaderInitdata () {\n    window.utag.loader.initdata_old()\n    // make sure we don't queue this initial page load twice, and respect the configured noview setting\n    if (!window.tealiumCmpIntegration.isNoviewSet &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n      window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n      var consentedServices = getCurrentConsentDecision()\n      if (consentedServices.type === 'implicit') {\n        window.tealiumCmpIntegration.implicitServices = consentedServices\n        // we don't need to fire implicit services in this case, because TiQ's loading process will fire them\n        queueEventWithoutFiringImplicitServices({\n          event: 'view',\n          data: window.utag.handler.C(window.utag.data)\n        })\n      }\n    }\n  }\n\n  /**\n   * Refresh [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration.tagBasedMap} and return that new map, helps smooth out any timing issues between Usercentrics and Tealium iQ load.\n   *\n   * @function generateTagBasedMap\n   * @returns a [TagToServiceMap]{@link TagToServiceMap}\n   */\n  function generateTagBasedMap () {\n    var tagBasedMap = getTagBasedMap(map)\n    window.tealiumCmpIntegration.tagBasedMap = tagBasedMap\n    return tagBasedMap\n  }\n\n  /**\n   * Tealium iQ's utag.handler.trigger normally causes tags to fire. For this integration, we override that function to support blocking tags without consent.\n   *\n   * @function newUtagHandlerTrigger\n   *\n   * @param {*} a can be an object or a string\n   * @param {*} b\n   * @param {*} c\n   */\n  function newUtagHandlerTrigger (a, b, c) {\n    /**\n     * Trigger CASES (utag.handler.trigger override)\n     *\n     * We need to queue the events if we only have implicit consent, to allow a selective retrigger if/when we get an explicit decision.\n     */\n    var isPureConsentEvent = (a === nameOfConsentPollingEvent &amp;&amp; !b &amp;&amp; !c)\n    var isNoviewSet = window.tealiumCmpIntegration.isNoviewSet || true // assume noview if something went wrong with the global, to avoid firing tracking in error\n\n    var consentedServices = getCurrentConsentDecision()\n    var consentType = (consentedServices &amp;&amp; consentedServices.type) || 'none'\n\n    var isUsercentricsReady = consentType === 'implicit' || consentType === 'explicit'\n    var isTealiumReady = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!isPureConsentEvent) {\n      logger('utag.handler.trigger called with:\\n\\n' + JSON.stringify(arguments, null, 2))\n    }\n\n    if (!isUsercentricsReady &amp;&amp; !isTealiumReady) {\n      consentedServices.type = 'tealium-and-usercentrics-loading'\n      logger('Waiting for Usercentrics and Tealium to be ready, queueing early event.')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isUsercentricsReady) {\n      consentedServices.type = 'usercentrics-loading'\n      logger('Usercentrics is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isTealiumReady) {\n      consentedServices.type = 'tealium-still-loading'\n      logger('Tealium iQ is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    }\n\n    // if an array of tagUids is passed, that forces them to fire regardless of load rules\n    // or consent, so we need to filter that array before allowing it to be processed\n    var hasTagUidArray = c &amp;&amp; typeof c === 'object' &amp;&amp; c.uids &amp;&amp; c.uids &amp;&amp; window.utag.ut.typeOf(c.uids) === 'array'\n    var uidMap = generateTagBasedMap()\n    var allowedTagUids = []\n    var blockedTagUids = []\n    var serviceName\n    var tagUid\n    if (hasTagUidArray) {\n      for (var i = 0; i &lt; c.uids.length; i++) {\n        tagUid = c.uids[i]\n        serviceName = uidMap[tagUid] || '(missing)'\n        // only push consented services into the new array\n        if (consentedServices.indexOf(serviceName) !== -1) {\n          allowedTagUids.push(tagUid)\n        } else {\n          blockedTagUids.push(tagUid)\n        }\n      }\n      // replace the original with the filtered array (can also be empty, if none of them were allowed)\n      logger('Call included tagUid array:\\n\\n' + JSON.stringify(c.uids) + '\\n\\nwhich was replaced by the filtered version:\\n\\n' + JSON.stringify(allowedTagUids))\n      c.originalUids = c.uids.slice() // make a shallow copy\n      c.uids = allowedTagUids\n      c.blockedTagUids = blockedTagUids\n    }\n\n    if (consentType === 'explicit') {\n      /**\n       * CASE T2: expected globals are populated, consent is EXPLICIT\n       *\n       * FIRE allowed tags (explicit)\n       * utag.handler.trigger override PROCESSES the queue, which will include any queued events from CASE A4, making sure not to re-fire any default\n       *   opt-in tags that were already fired for the queued events\n       */\n      // make sure TiQ loads\n      processEarlyQueue()\n      processImplicitQueue()\n      triggerTiqLoad()\n      // fire the current event if it's not just a polling event\n      if (!isPureConsentEvent) {\n        return window.utag.handler.trigger_old(a, b, c)\n      }\n    } else if (consentType === 'implicit') {\n      /**\n       * CASE T3: expected globals are populated, consent is IMPLICIT\n       *\n       * FIRE allowed tags (implicit)\n       * utag.handler.trigger override KEEPS a queue/record that includes\n       *  - the event(s) that were processed based on implicit consent\n       *  - which tags were allowed to process each event (are set to implicit opt-in)\n       */\n      processEarlyQueue()\n      // fire the initial view if appropriate, and queue it\n      triggerTiqLoad()\n      window.tealiumCmpIntegration.implicitServices = consentedServices\n\n      // queue the initial 'view' on pageload if appropriate\n      if (!isNoviewSet &amp;&amp; isTealiumReady &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n        window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n        queueEventAndFireImplicitServices('view', window.utag.handler.C(window.utag.data))\n      }\n      // queue the current event if it exists (and this isn't just consent polling)\n      if (!isPureConsentEvent) {\n        return queueEventAndFireImplicitServices(a, b, c)\n      }\n    } else if (consentType === 'missing-map') {\n      logger('Something went wrong - all tags were blocked because no consent map was found for the active setting ID.')\n      return false\n    } else if (consentType === 'missing-tiq-consent') {\n      logger('Something went wrong - all tags were blocked because no consent was found for &quot;' + tiqServiceName + '&quot;, configured Tealium iQ name.\\n\\nConsent found: ' + JSON.stringify(consentedServices, null, 2))\n      return false\n    } else {\n      /**\n       * CASE T1: expected variables not populated (misconfiguration/error case)\n       *\n       * STOP and fire nothing at all. Do not retry or queue the event.\n       */\n      logger('Something went wrong - all tags were blocked because the consent response was not understood.')\n      return false\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the early event queue]{@link tealiumCmpIntegration.earlyEventQueue} (can include pageviews) for any currently-consented Services.\n   *\n   * Intended to be called first understandable implicit consent.\n   *\n   * @function processEarlyQueue\n   */\n  function processEarlyQueue () {\n    var queuedEvent\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    while (window.tealiumCmpIntegration.earlyEventQueue.length &gt; 0) {\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.earlyEventQueue.shift()\n      logger('Processing queued early event for currently consented tags: ' + JSON.stringify(queuedEvent, null, 2))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the global queue]{@link tealiumCmpIntegration.implicitEventQueue} (can include pageviews) for any newly-consented Services.\n   *\n   * Intended to be called on new EXPLICIT consent decision - queued events have already had IMPLICTLY consented tags fired, so those need to be excluded.\n   *\n   * @function processImplicitQueue\n   */\n  function processImplicitQueue () {\n    var alreadyLogged = false\n    var queuedEvent\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    while (window.tealiumCmpIntegration.implicitEventQueue.length &gt; 0) {\n      if (!alreadyLogged) {\n        alreadyLogged = true\n        logger('Explicit consent tracking request received - processing past implicitly tracked events (' + window.tealiumCmpIntegration.implicitEventQueue.length + ') for any new explicit tags.')\n      }\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.implicitEventQueue.shift()\n      logger('Triggering event for explicitly-consented tags: ' + JSON.stringify(queuedEvent))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the early queue]{@link tealiumCmpIntegration.earlyEventQueue}, without firing any tags.\n   *\n   * Intended to be called for events that triggered before we get an understandable response from Usercentrics.\n   *\n   * @function queueEarlyEvent\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEarlyEvent (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    // nothing will be allowed to fire\n    a.data[nameOfImplicitConsentArray] = []\n\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    window.tealiumCmpIntegration.earlyEventQueue.push(a)\n    logger('Queued early event!')\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration.implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for the initial pageview on load, since the load process will have already fired the implicit services.\n   *\n   * @function queueEventWithoutFiringImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventWithoutFiringImplicitServices (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    a.data[nameOfImplicitConsentArray] = window.tealiumCmpIntegration.implicitServices || []\n\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    window.tealiumCmpIntegration.implicitEventQueue.push(a)\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration~implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for all events other than the initial page load.\n   *\n   * @function queueEventAndFireImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventAndFireImplicitServices (a, b, c) {\n    // fire the implicit tags\n    window.utag.handler.trigger_old(a, b, c)\n    logger('Implicit consent tracking request fired (or queued, if utag hasn\\'t loaded).')\n    return queueEventWithoutFiringImplicitServices(a, b, c)\n  }\n\n  /**\n   * Generate a {@link TagToServiceMap TagToServiceMap} based on a {@link ServiceToTagMap ServiceToTagMap}\n   *\n   * @function getTagBasedMap\n   * @param {object} map a {@link ServiceToTagMap ServiceToTagMap} object\n   * @return {object} a {@link TagToServiceMap TagToServiceMap}\n   */\n  function getTagBasedMap (map) {\n    // generate a lookup based on the tagUid\n    if (typeof map !== 'object') return {}\n    var settingsId = getCurrentUsercentricsSettingsId() || ''\n    if (typeof settingsId !== 'string' || settingsId === '') return {}\n    var settingSpecificMap = map[settingsId] || {}\n    var serviceNames = Object.keys(settingSpecificMap)\n    var uidMap = {}\n    for (var i = 0; i &lt; serviceNames.length; i++) {\n      for (var j = 0; j &lt; settingSpecificMap[serviceNames[i]].length; j++) {\n        uidMap[settingSpecificMap[serviceNames[i]][j]] = serviceNames[i]\n      }\n    }\n    return uidMap\n  }\n\n  /**\n   * Get the current Usercentrics settingsId from the page.\n   *\n   * @returns {string} the Usercentrics settingsId, defaults to an empty string if none is found\n   */\n  function getCurrentUsercentricsSettingsId () {\n    return (window.usercentrics &amp;&amp; window.usercentrics.settingsId) || ''\n  }\n\n  /**\n   * Trigger the core logic with an up-to-date array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   * @function recheckForCmpAndConsent\n   */\n  function recheckForCmpAndConsent () {\n    var newConsentResponse = cmpConsentCheck()\n    reactToCmpResponse(newConsentResponse)\n  }\n\n  /**\n   * Call [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents} to get the current consent decision.\n   * @function cmpConsentCheck\n   */\n  function cmpConsentCheck () {\n    if (!window.usercentrics || typeof window.usercentrics.getConsents !== 'function') return false\n    var cmpConsentArray = window.usercentrics.getConsents()\n    return cmpConsentArray\n  }\n\n  /**\n   * Indicates if Usercentrics has loaded and returned a well-formed indication of user consent.\n   * @function checkForWellFormedDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is well-formed, otherwise 'false'\n   */\n  function checkForWellFormedDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; typeof cmpConsentArray[0].dataProcessingService === 'string') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if the user has made an EXPLICIT decision\n   * @function checkForExplicitConsentDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is EXPLICIT otherwise 'false'\n   */\n  function checkForExplicitConsentDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; cmpConsentArray[0].updatedBy === 'explicit') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if Tealium iQ has permission to run (and fire tags).\n   * @function checkForTiqConsent\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if TiQ is allowed to run, otherwise 'false'\n   */\n  function checkForTiqConsent (cmpConsentArray) {\n    var foundOptIn = false\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // check vendors if there's an object, look for at least one\n    cmpConsentArray.forEach(function (tagInfo) {\n      if (tagInfo.consentStatus === true &amp;&amp; tagInfo.dataProcessingService === tiqServiceName) {\n        foundOptIn = true\n      }\n    })\n    return foundOptIn\n  }\n\n  /**\n   * Create an instance of\n   * @param {array} cmpConsentArray the array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   */\n  function getVendorConsentsFromCmpConsentArray (cmpConsentArray) {\n    var vendorArray = []\n\n    var isWellFormed = checkForWellFormedDecision(cmpConsentArray)\n\n    if (!isWellFormed) {\n      vendorArray.type = 'missing-well-formed-response'\n      return []\n    }\n\n    var tagBasedMap = generateTagBasedMap()\n\n    // if there is no mapping for the settings id, we need to change the console output\n    var currentSettingsIdHasMapping = (typeof tagBasedMap === 'object' &amp;&amp; Object.keys(tagBasedMap).length &gt; 0)\n\n    if (!currentSettingsIdHasMapping) {\n      vendorArray.type = 'missing-map'\n      return []\n    }\n\n    cmpConsentArray &amp;&amp; cmpConsentArray.forEach(function (tagConsent) {\n      if (tagConsent.consentStatus === true) {\n        vendorArray.push(tagConsent.dataProcessingService)\n      }\n    })\n    vendorArray.type = checkForExplicitConsentDecision(cmpConsentArray) ? 'explicit' : 'implicit'\n\n    if (checkForTiqConsent(cmpConsentArray) === false) {\n      // change the consent type, but leave the array for debugging purposes\n      vendorArray.type = 'missing-tiq-consent'\n    }\n\n    return vendorArray\n  }\n\n  /**\n   * Get the current consent decision from the CMP for the active Setting\n   * @function getCurrentConsentDecision\n   * @returns a {@link ConsentDecision ConsentDecision}\n   */\n  function getCurrentConsentDecision () {\n    var freshConsent = cmpConsentCheck()\n\n    return getVendorConsentsFromCmpConsentArray(freshConsent)\n  }\n\n  /**\n   *  A conditional logging function - we can't use utag.DB directly because some of our logic needs to be preloader, but we can mimic the same logic so that our logging only displays when TiQ is in debug mode and/or not in Prod, or is explicitly forced.\n   * @function logger\n   * @param {string} message the message to be conditionally shown\n   * @param {boolean} showOutsideDebugMode if 'true', forces the message to shown outside of debug mode, except on Prod\n   */\n  function logger (message, showOutsideDebugMode) {\n    if (typeof tealiumEnvironment === 'undefined' || tealiumEnvironment === 'prod') {\n      // don't allow anything outside of debug mode on prod (disable this flag)\n      showOutsideDebugMode = false\n    }\n\n    if (showOutsideDebugMode || tiqInDebugMode) {\n      message = '\\n' + message + '\\n'\n      var formattedArr = []\n      formattedArr.push('****************')\n      var messageArr = message.split('\\n')\n      messageArr.forEach(function (messageLine) {\n        formattedArr.push('*  ' + messageLine)\n      })\n      formattedArr.push('****************')\n      var outputString = formattedArr.join('\\n')\n      console.log(outputString)\n    }\n  }\n\n  /**\n   * Stops Tealium iQ from loading (the TMS will not load tags or set a cookie if this function is called in Pre Loader), using the {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} setting\n   * @function stopTiq\n   */\n  function stopTiq () {\n    // logger(&quot;stopTiq function fired&quot;)\n    window.utag_cfg_ovrd = window.utag_cfg_ovrd || {}\n    window.utag_cfg_ovrd.noload = true\n  }\n\n  /**\n   * Allows TiQ to finish loading, intended to be called when a well-formed consent response is received, and that response allows Tealium iQ to run.\n   *\n   * Works by setting {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} to 'false' and calling Tealium iQ's utag.loader.PINIT method.\n   *\n   * If noload was 'true' and this function runs it must've been set to true by our own {@link module:extension-1~stopTiq stopTiq} function, because otherwise Tealium iQ wouldn't have been allowed to load/poll in the first place.\n   * @function triggerTiqLoad\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function triggerTiqLoad () {\n    // if usercentrics is ready on the first request, TiQ won't have loaded yet at all - let it load naturally\n    if (!window.utag) {\n      return true\n    }\n    // if TiQ has already loaded but these flags aren't truthy, we've interrupted the load and should retrigger it\n    // initial load / view (noview logic handled in utag.handler.trigger function itself)\n    if (!window.utag.handler || !window.utag.handler.iflag) {\n      // we don't need to reload actually, just allow it to finish loading\n      window.utag.cfg.noload = false // safe because this code only runs if it was set to false originally\n      window.utag.loader.PINIT()\n      return true\n    }\n    // already loaded\n    return false\n  }\n\n  /**\n   * If Tealium iQ hasn't loaded, load it (calling utag.handler.trigger in the process), otherwise call utag.handler.trigger.\n   * @function triggerOrQueue\n   */\n  function triggerOrQueue () {\n    var successfullyTriggeredLoadIfNeeded = triggerTiqLoad()\n    if (!successfullyTriggeredLoadIfNeeded) {\n      // explicit consent from polling, but load has already been triggered\n      return window.utag.handler.trigger(nameOfConsentPollingEvent)\n    }\n  }\n  /**\n   * Get the the current Tealium iQ environment.\n   *\n   * Since this runs in Pre Loader, it needs to use regex to recognize the utag.js file in the DOM and read the environment from the file name (there are no utag functions or objects at this point in the load).\n   *\n   * NOTE: This doesn't work correctly when using the the Environment Switcher (because the original script is added to the DOM instead of the new one, and the 307 redirect that's used to pull the new file(s) only changes the response, not the script element itself).\n   *\n   * If you're using the Environment Switcher on Prod and would like to see console output, set the [debug cookie]{@link https://docs.tealium.com/platforms/javascript/debugging/}.\n   *\n   * @function getTealiumEnvironment\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function getTealiumEnvironment () {\n    var allScripts = document.getElementsByTagName('script')\n    var re = /\\/([^/]*)\\/utag\\.js(\\?.*)*$/\n    for (var i = 0; i &lt; allScripts.length; i++) {\n      var result = re.exec(allScripts[i].src) // can be null\n      if (result &amp;&amp; result[1]) { // [1] is the result of the match\n        return result[1]\n      }\n    }\n    return 'prod' // default to guessing we're in prod, just in case we're actually in prod (to avoid logging in Prod)\n  }\n})()\n\n// Document key data structures here for clarity.\n\n/**\n * An array of Usercentrics Service Names that have permission to run (uses the 'dataProcessingService' property from [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}).\n *\n * Also includes a 'type' property that indicates whether the consent decision is IMPLICIT or EXPLICT.\n *\n * @static\n * @type {array}\n * @name ConsentDecision\n * @memberof! &lt;global&gt;\n * @property {string} type the type of consent, will be either 'implicit' or 'explicit'\n * @example\nvar exampleConsentDecision = window.tealiumCmpIntegration.getCurrentConsentDecision()\n\nJSON.stringify(exampleConsentDecision)\n// [&quot;Google Analytics&quot;,&quot;Another Tag&quot;,&quot;Tealium iQ Tag Management&quot;]\n\nexampleConsentDecision.type\n// &quot;explicit&quot;\n\nexampleConsentDecision.length\n// 3\n */\n\n/**\n * Assigns Tealium iQ Tags to Usercentrics Service Names. Each service can have multiple tags, but each tag can only have one service.  If the same tag UID appears in multiple Service arrays, only one will be used.\n *\n * The keys for the main object are Setting-IDs from Usercentrics, inside that are key/value pairs where the key is a Service Name from Usercentrics, and the value is an array of TagUIDs from Tealium iQ.\n *\n * This needs to be provided as per the example below, in [tealiumCmpIntegration.map]{@link namespace:tealiumCmpIntegration~map}.\n *\n * An [example Tealium iQ extension]{@link module:example-map} is provided as well.\n *\n * @static\n * @type {object}\n * @name ServiceToTagMap\n * @memberof! &lt;global&gt;\n * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n  'yPyIAIIxY': {\n    'Google Analytics': [6, 8, 10],\n    'Mouseflow': [7, 9],\n    'Another Tag': [11]\n  }\n}\n */\n\n/**\n * A simple lookup, with Tealium iQ tag UIDs as keys and the associated Usercentrics service name as strings as values. Each service can be associated with multiple tags, but each tag can be associated with one service.\n *\n * The example is based on the {@link ServiceToTagMap ServiceToTagMap} example, where the Usercentrics settingsId on the active page is 'yPyIAIIxY'.\n *\n * This object is automatically generated by the [getTagBasedMap]{@link module:extension-1~getTagbasedMap} method, and made available globally in [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration~tagBasedMap} for debugging and use within the extensions.\n *\n * @static\n * @type {object}\n * @name TagToServiceMap\n * @memberof! &lt;global&gt;\n * @example\n{\n  6: 'Google Analytics',\n  7: 'Mouseflow',\n  8: 'Google Analytics',\n  9: 'Mouseflow',\n  10: 'Google Analytics',\n  11: 'Another Tag'\n}\n */\n\n/**\n * An object from the [implicitEventQueue]{@link tealiumCmpIntegration.implicitEventQueue} or [earlyEventQueue]{@link tealiumCmpIntegration.earlyEventQueue}, which represents a Tealium iQ tracking event that's been processed based on an IMPLICIT [ConsentDecision]{@link ConsentDecision}\n *\n * Heavily based on the argument passed to [utag.track]{@link https://community.tealiumiq.com/t5/Tealium-iQ-Tag-Management/utag-track-method/td-p/24578}, since it's designed to be processed by that method.\n *\n * Initial pageviews (handled in the [utag.loader.initdata override]{@link module:extension-1~newUtagLoaderInitdata}) will NOT have metadata like cookies, qps, etc - utag.track calls (handled in the [utag.handler.trigger override]{@link module:extension-1~newUtagHandlerTrigger}) will. That's a byproduct of using utag.handler.trigger, which is later in the load - those metadata will be re-read when the queue is processed, and since this queue isn't persisted between pages, it should be fine like that - the only strange behavior will be that any metadata that aren't present on re-read will still be present after the re-read - only values that are still present will be replaced with new values.\n *\n * An alternative approach could be to manually remove 'cp.\\*', 'dom.\\*', 'ut.\\*', 'qp.\\*', 'meta.\\*' and possibly 'tealium_\\*' (except 'tealium_event') from the 'data' object before queueing - that hasn't been done so far.\n *\n * @static\n * @type {array}\n * @name QueuedEvent\n * @memberof! &lt;global&gt;\n * @property {string} event the type of tracking event, generally 'view' for pageviews or 'link' for other events\n * @property {object} data the Universal Data Object associated with the event (from utag_data or the b object)\n * @property {object} cfg an optional configuration object that can have a 'cb' property (for a callback function) and a 'uids' array, which is a list of tag UIDs that should be triggered by the event, regardless of whether load rules are met.\n * @example\n{\n  &quot;event&quot;: &quot;view&quot;,\n  &quot;data&quot;: {\n    &quot;page_type&quot;: &quot;test_virtual_view&quot;,\n    &quot;cp.utag_main_v_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;cp.utag_main__sn&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__se&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__ss&quot;: &quot;0&quot;,\n    &quot;cp.utag_main__st&quot;: &quot;1598990152209&quot;,\n    &quot;cp.utag_main_ses_id&quot;: &quot;1598988112353&quot;,\n    &quot;cp.utag_main__pn&quot;: &quot;3&quot;,\n    &quot;cp.utagdb&quot;: &quot;true&quot;,\n    &quot;dom.referrer&quot;: &quot;&quot;,\n    &quot;dom.title&quot;: &quot;Usercentrics Test&quot;,\n    &quot;dom.domain&quot;: &quot;solutions.tealium.net&quot;,\n    &quot;dom.query_string&quot;: &quot;&quot;,\n    &quot;dom.hash&quot;: &quot;&quot;,\n    &quot;dom.url&quot;: &quot;https://solutions.tealium.net/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.pathname&quot;: &quot;/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.viewport_height&quot;: 456,\n    &quot;dom.viewport_width&quot;: 1825,\n    &quot;ut.domain&quot;: &quot;tealium.net&quot;,\n    &quot;ut.version&quot;: &quot;ut4.46.202009011921&quot;,\n    &quot;ut.event&quot;: &quot;view&quot;,\n    &quot;ut.visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;ut.session_id&quot;: &quot;1598988112353&quot;,\n    &quot;ut.account&quot;: &quot;services-caleb&quot;,\n    &quot;ut.profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;ut.env&quot;: &quot;prod&quot;,\n    &quot;tealium_event&quot;: &quot;view&quot;,\n    &quot;tealium_visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;tealium_session_id&quot;: &quot;1598988112353&quot;,\n    &quot;tealium_session_number&quot;: &quot;4&quot;,\n    &quot;tealium_session_event_number&quot;: &quot;4&quot;,\n    &quot;tealium_datasource&quot;: &quot;&quot;,\n    &quot;tealium_account&quot;: &quot;services-caleb&quot;,\n    &quot;tealium_profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;tealium_environment&quot;: &quot;prod&quot;,\n    &quot;tealium_random&quot;: &quot;2085060854215077&quot;,\n    &quot;tealium_library_name&quot;: &quot;utag.js&quot;,\n    &quot;tealium_library_version&quot;: &quot;4.46.0&quot;,\n    &quot;tealium_timestamp_epoch&quot;: 1598988352,\n    &quot;tealium_timestamp_utc&quot;: &quot;2020-09-01T19:25:52.211Z&quot;,\n    &quot;tealium_timestamp_local&quot;: &quot;2020-09-01T21:25:52.211&quot;,\n    &quot;usercentrics_services_with_consent&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ],\n    &quot;usercentrics_consent_type&quot;: &quot;implicit&quot;,\n    &quot;_usercentrics_services_already_processed&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ]\n  },\n  &quot;cfg&quot;: {\n    &quot;cb&quot;: function myCallback () {console.log(&quot;Callback fired!&quot;)},\n    &quot;uids&quot;: [\n      11\n    ],\n    &quot;originalUids&quot;: [\n      7,\n      11\n    ],\n    &quot;blockedTagUids&quot;: [\n      11\n    ]\n  }\n}\n*/\n"}},"draftSeq":"2","queueSeq":"106","draftSnippets":{"2c3d371cbfd31225ec25b3e9798107cb8ca008f2357b98d13d1eddb7b042cc44":{"updatedBy":"caleb.jaquith@tealium.com","updateDate":"202010050833","creationDate":"202010050833","name":"Blank","code":"// Type your JavaScript code here..."},"7a04d78e08e772d2120d15cfebc31b13a3d9cb8dd002560b1aae5d31bf9035e7":{"updatedBy":"caleb.jaquith@tealium.com","versionControl":{"isReadOnly":"true","sourceUrl":"https://github.com/jaquith/usercentrics-integration/blob/release/extensions/extension-1.js","lastSyncTimeStamp":"202011040723","sourceName":"GitHub","accountName":"jaquith","isOutdated":"false","lastSyncSuccess":"true","hashValue":"a33123fde5698c23d941d5c8fdf32dff4bf62e6f"},"creationDate":"202008131558","updateDate":"202011040723","name":"extension-1.js","code":"/**\n *  Scope       : Pre Loader\n *  Condition   : n/a\n *  Description : CMP 1/2 - Preloader component - prevent TiQ from loading if no consent, queue implicitly consented events to retrigger (for new tags only) if explicit decision is made.\n */\n\n/**\n  * @module extension-1\n  *\n  * @description The 'Pre Loader' extension component of the CMP integration, responsible for stopping Tealium iQ from loading/running as appropriate, and making certain\n  * window-scoped functions available to the other components.\n  */\n\n// Tealium iQ runs Pre Loader extensions in global scope, which would make all variables global. We don't want to do that.\n(function avoidGlobalScopeUnlessExplicit () {\n  // set names for key objects and variables to make them easy to change if needed\n\n  var version = 'v0.10-beta'\n\n  // for the consent information in the b object\n  var nameOfVendorOptInArray = 'usercentrics_services_with_consent'\n  var nameOfConsentTypeString = 'usercentrics_consent_type'\n\n  // for the name in the queue\n  var nameOfImplicitConsentArray = '_usercentrics_services_already_processed'\n\n  // name to use when calling utag.handler.trigger to indicate a consent polling call\n  var nameOfConsentPollingEvent = 'tiq_usercentrics_consent_polling'\n\n  var consentTimeoutInterval = 400 // setTimeout interval in MS - rate to poll for new (explicit) consent decision or correctly formed object\n\n  // check for the Tealium Debug cookie, see https://docs.tealium.com/platforms/javascript/debugging/\n  var tiqInDebugMode = /utagdb=true/.test(document.cookie)\n  var tealiumEnvironment = getTealiumEnvironment() || 'prod' // fall back to prod (stops logging) if something goes wrong with the function\n\n  /**\n   * A window-scoped (global) object used to expose selected functionality.\n   *\n   * @namespace tealiumCmpIntegration\n   * @type {object}\n   * @memberof! &lt;global&gt;\n   */\n  window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\n\n  /**\n   * The name of the CMP (&quot;Usercentrics Vanilla App&quot; in this case).\n   * @name cmpName\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.cmpName = 'Usercentrics Vanilla App'\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link ServiceToTagMap ServiceToTagMap}\n   * @name map\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  var map = window.tealiumCmpIntegration.map || {}\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link TagToServiceMap TagToServiceMap}\n   * @name tagBasedMap\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  generateTagBasedMap() // populates the window-level object for you as well\n\n  /**\n   * The Service Name for Tealium iQ in Usercentrics (used to decide if the TMS is allowed to run).  Uses the Usercentrics standard name if not provided.\n   * @name tiqServiceName\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   * @default 'Tealium iQ Tag Management'\n   * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.tiqServiceName = &quot;Tealium iQ Tag Management&quot;\n   */\n  var tiqServiceName = window.tealiumCmpIntegration.tiqServiceName || 'Tealium iQ Tag Management' // use the standard name here if not set\n\n  /**\n   * The current version designation.\n   * @name version\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.version = version\n\n  /**\n   * A [logger helper function]{@link module:extension-1~logger}, to help Tealium iQ users understand and troubleshoot this CMP integration without unneeded logging in production.\n   * @name logger\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.logger = logger\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentConsentDecision} that returns the current [ConsentDecision]{@link ConsentDecision}.\n   * @name getCurrentConsentDecision\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentConsentDecision = getCurrentConsentDecision\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentUsercentricsSettingsId} that returns the current Usercentrics settingsId.\n   * @name getCurrentUsercentricsSettingsId\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentUsercentricsSettingsId = getCurrentUsercentricsSettingsId\n\n  /**\n   * Records the status of the [noview]{@link https://docs.tealium.com/platforms/javascript/settings/#noview} setting on page load.\n   * @name isNoviewSet\n   * @type {boolean}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.isNoviewSet = window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noview === true\n\n  /**\n   * The name to use for the [ConsentDecision]{@link ConsentDecision} array when adding it to Tealium's b object on each event.\n   * @name nameOfVendorOptInArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfVendorOptInArray = nameOfVendorOptInArray\n\n  /**\n   * The name to use for the current [ConsentDecision]{@link ConsentDecision}'s 'type' attribute when adding it to Tealium's b object on each event.\n   * @name nameOfConsentTypeString\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfConsentTypeString = nameOfConsentTypeString\n\n  /**\n   * The name to use for the array of implicit tags (which have already been fired) in the 'data' property of {@link QueuedEvent QueuedEvent} objects.\n   * @name nameOfImplicitConsentArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfImplicitConsentArray = nameOfImplicitConsentArray\n\n  /**\n   * A [helper function]{@link module:extension-1~overrideUtagFunctions} that overrides certain utag functions to allow tags to be blocked based on CMP response.\n   *\n   * Must be called directly after the '##UTGEN##' reference by [editing]{@link https://community.tealiumiq.com/t5/iQ-Tag-Management/Managing-Tag-Templates/ta-p/21713} the 'utag loader' template, as shown in the example.\n   * @name overrideUtagFunctions\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   * @example\n// ... utag loader template ...\n\n##UTGEN##\n// override two utag functions for the Usercentrics CMP Integration, to allow tags to be blocked as needed\nwindow.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions()\n\n// ... utag loader template continues...\n\n   */\n  window.tealiumCmpIntegration.overrideUtagFunctions = overrideUtagFunctions\n\n  /**\n   * A queue for any events that Tealium iQ processes with IMPLICIT consent (to allow those events to be re-processed for new Services in the event of an EXPLICIT consent choice by the user).\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name implicitEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n\n  /**\n   * A queue for any events that are triggered before Tealium iQ AND Usercentrics have both loaded.\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name earlyEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n\n  /**\n   * Allows us to make sure we don't log certain messages more than once, especially useful while polling to avoid overwhelming the user.\n   * @function messageNotLoggedYet\n   * @param {*} messageId a string or number to uniquely identify a message for the purposes of deduplication\n   * @returns {boolean} 'true' if the message hasn't been logged yet (and should be logged), otherwise 'false'\n   */\n  var alreadyLoggedMessageIds = {}\n  function messageNotLoggedYet (messageId) {\n    var output = false\n    if (typeof alreadyLoggedMessageIds[messageId] === 'undefined') {\n      alreadyLoggedMessageIds[messageId] = true\n      output = true\n    }\n    return output\n  }\n\n  // if noload is set to 'true', don't interfere, just return to exit this function and allow that setting to stop TiQ load as usual.\n  if (window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noload === true) return false\n\n  logger('CMP integration active - Usercentrics/TiQ' + (tiqInDebugMode ? &quot;\\n\\nDEBUGGING TIP: Use /SENDING|\\\\*\\\\*\\\\*\\\\*/ in the browser console as the 'filter' to show only CMP and tag send notifications.&quot; : '\\n\\nActivate TiQ Debug Mode for more details: https://docs.tealium.com/platforms/javascript/debugging/'), true)\n  var cmpResponse = cmpConsentCheck()\n  // core business/GDPR logic, decides if TiQ should load at all\n  reactToCmpResponse(cmpResponse)\n\n  /**\n   * The core CMP integration logic, which decides if Tealium iQ should be allowed to run, or if it needs to be stopped\n   * until an understandable response that includes permission for Tealium iQ to run is found.\n   *\n   * @function reactToCmpResponse\n   * @param {object} cmpResponse The response from the Usercentrics Vanilla App\n   */\n  function reactToCmpResponse (cmpResponse) {\n    var usercentricsFound = typeof cmpResponse === 'object'\n    var foundWellFormedConsentDecision = checkForWellFormedDecision(cmpResponse)\n    var tagBasedMap = generateTagBasedMap()\n    var foundMapEntryForActiveSetting = Object.keys(tagBasedMap).length &gt; 0\n    var foundExplicitConsent = checkForExplicitConsentDecision(cmpResponse)\n    var tiqIsAllowedToFire = checkForTiqConsent(cmpResponse)\n    var tiqIsLoaded = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!usercentricsFound) {\n      /**\n       * CASE A1: no Usercentrics CMS found\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(1)) logger('No Usercentrics CMP found on page.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundMapEntryForActiveSetting) {\n      /**\n        * CASE A7: No map found for the current settingsId\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(2)) logger('No map found for current Usercentrics Setting ID.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    } else if (!foundWellFormedConsentDecision) {\n      /**\n       * CASE A2: Usercentrics CMS found but consent response wasn't well-formed/complete/understandable\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(3)) logger('Found Usercentrics CMP and got response, but didn\\'t understand the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!tiqIsAllowedToFire) {\n      /**\n       * CASE A3: Usercentrics CMS found and consent response was well-formed, BUT TiQ didn't have an opt-in\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(4)) logger('Found Usercentrics CMP and got well-formed response, but TiQ isn\\'t allowed to run based on the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundExplicitConsent) {\n      /**\n       * CASE A4: Usercentrics CMS found AND response was understandable (AND includes an implicit TiQ consent), BUT the user hasn't made an explicit decision yet\n       *\n       * ALLOW TO LOAD for any 'default opt-in' tags (filter logic in Extension B)\n       * RETRY after a delay (in case there's an explicit decision, since implicit decisions usually mean the prompt is displayed)\n       */\n      if (messageNotLoggedYet(5)) logger('Found Usercentrics CMP and got well-formed IMPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on IMPLICIT consent.\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else if (foundExplicitConsent) {\n      /**\n       * CASE A5: Usercentrics CMS found AND response was understandable, AND the user has made an explicit consent decision AND TiQ is allowed\n       *\n       * ALLOW TO LOAD for any opted-in tags (filter logic in Extension B), do not retry.\n       */\n      if (messageNotLoggedYet(6)) logger('Found Usercentrics CMP and got well-formed EXPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on EXPLICIT consent.\\n\\nNo further polling.')\n      // only call if we've been polling (on initial load, it will load automatically)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n        processImplicitQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else {\n      /**\n        * CASE A6: Something went wrong with this extension.\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(7)) logger('Something unexpected went wrong.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    }\n  }\n\n  /**\n   * Override utag.loader.initdata and utag.handler.trigger to allow Tealium iQ Tags to be blocked if the user hasn't consented.\n   *\n   * @function overrideUtagFunctions\n   * @returns {boolean} 'true' if the function was overridden successfully by this request, 'false' if not (because it was already overridden)\n   */\n  function overrideUtagFunctions () {\n    // don't override more than once, assume that if one function has been overridden, both have\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    // the initial view is handled differently than subsequent events\n    // this is safe to to override even if noview is set (because it will never be called in that case)\n    window.utag.loader.initdata_old = window.utag.loader.initdata\n    window.utag.loader.initdata = newUtagLoaderInitdata\n\n    window.utag.handler.trigger_old = window.utag.handler.trigger\n    window.utag.handler.trigger = newUtagHandlerTrigger\n    logger('Overrode utag functions!')\n\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * An overridden version of the Tealium iQ function utag.loader.initdata.\n   *\n   * Calls the original function, respects possible noview settings, rechecks the user consent, and calls queueEventWithoutFiringImplicitServices\n   * if only an IMPLICIT consent is found (after recording the IMPLICIT services, to avoid double-firing).\n   *\n   * That same event can then be re-processed for any new Services if an EXPLICIT consent decision later made.\n   *\n   * @function newUtagLoaderInitdata\n   */\n  function newUtagLoaderInitdata () {\n    window.utag.loader.initdata_old()\n    // make sure we don't queue this initial page load twice, and respect the configured noview setting\n    if (!window.tealiumCmpIntegration.isNoviewSet &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n      window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n      var consentedServices = getCurrentConsentDecision()\n      if (consentedServices.type === 'implicit') {\n        window.tealiumCmpIntegration.implicitServices = consentedServices\n        // we don't need to fire implicit services in this case, because TiQ's loading process will fire them\n        queueEventWithoutFiringImplicitServices({\n          event: 'view',\n          data: window.utag.handler.C(window.utag.data)\n        })\n      }\n    }\n  }\n\n  /**\n   * Refresh [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration.tagBasedMap} and return that new map, helps smooth out any timing issues between Usercentrics and Tealium iQ load.\n   *\n   * @function generateTagBasedMap\n   * @returns a [TagToServiceMap]{@link TagToServiceMap}\n   */\n  function generateTagBasedMap () {\n    var tagBasedMap = getTagBasedMap(map)\n    window.tealiumCmpIntegration.tagBasedMap = tagBasedMap\n    return tagBasedMap\n  }\n\n  /**\n   * Tealium iQ's utag.handler.trigger normally causes tags to fire. For this integration, we override that function to support blocking tags without consent.\n   *\n   * @function newUtagHandlerTrigger\n   *\n   * @param {*} a can be an object or a string\n   * @param {*} b\n   * @param {*} c\n   */\n  function newUtagHandlerTrigger (a, b, c) {\n    /**\n     * Trigger CASES (utag.handler.trigger override)\n     *\n     * We need to queue the events if we only have implicit consent, to allow a selective retrigger if/when we get an explicit decision.\n     */\n    var isPureConsentEvent = (a === nameOfConsentPollingEvent &amp;&amp; !b &amp;&amp; !c)\n    var isNoviewSet = window.tealiumCmpIntegration.isNoviewSet || true // assume noview if something went wrong with the global, to avoid firing tracking in error\n\n    var consentedServices = getCurrentConsentDecision()\n    var consentType = (consentedServices &amp;&amp; consentedServices.type) || 'none'\n\n    var isUsercentricsReady = consentType === 'implicit' || consentType === 'explicit'\n    var isTealiumReady = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!isPureConsentEvent) {\n      logger('utag.handler.trigger called with:\\n\\n' + JSON.stringify(arguments, null, 2))\n    }\n\n    if (!isUsercentricsReady &amp;&amp; !isTealiumReady) {\n      consentedServices.type = 'tealium-and-usercentrics-loading'\n      logger('Waiting for Usercentrics and Tealium to be ready, queueing early event.')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isUsercentricsReady) {\n      consentedServices.type = 'usercentrics-loading'\n      logger('Usercentrics is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isTealiumReady) {\n      consentedServices.type = 'tealium-still-loading'\n      logger('Tealium iQ is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    }\n\n    // if an array of tagUids is passed, that forces them to fire regardless of load rules\n    // or consent, so we need to filter that array before allowing it to be processed\n    var hasTagUidArray = c &amp;&amp; typeof c === 'object' &amp;&amp; c.uids &amp;&amp; c.uids &amp;&amp; window.utag.ut.typeOf(c.uids) === 'array'\n    var uidMap = generateTagBasedMap()\n    var allowedTagUids = []\n    var blockedTagUids = []\n    var serviceName\n    var tagUid\n    if (hasTagUidArray) {\n      for (var i = 0; i &lt; c.uids.length; i++) {\n        tagUid = c.uids[i]\n        serviceName = uidMap[tagUid] || '(missing)'\n        // only push consented services into the new array\n        if (consentedServices.indexOf(serviceName) !== -1) {\n          allowedTagUids.push(tagUid)\n        } else {\n          blockedTagUids.push(tagUid)\n        }\n      }\n      // replace the original with the filtered array (can also be empty, if none of them were allowed)\n      logger('Call included tagUid array:\\n\\n' + JSON.stringify(c.uids) + '\\n\\nwhich was replaced by the filtered version:\\n\\n' + JSON.stringify(allowedTagUids))\n      c.originalUids = c.uids.slice() // make a shallow copy\n      c.uids = allowedTagUids\n      c.blockedTagUids = blockedTagUids\n    }\n\n    if (consentType === 'explicit') {\n      /**\n       * CASE T2: expected globals are populated, consent is EXPLICIT\n       *\n       * FIRE allowed tags (explicit)\n       * utag.handler.trigger override PROCESSES the queue, which will include any queued events from CASE A4, making sure not to re-fire any default\n       *   opt-in tags that were already fired for the queued events\n       */\n      // make sure TiQ loads\n      processEarlyQueue()\n      processImplicitQueue()\n      triggerTiqLoad()\n      // fire the current event if it's not just a polling event\n      if (!isPureConsentEvent) {\n        return window.utag.handler.trigger_old(a, b, c)\n      }\n    } else if (consentType === 'implicit') {\n      /**\n       * CASE T3: expected globals are populated, consent is IMPLICIT\n       *\n       * FIRE allowed tags (implicit)\n       * utag.handler.trigger override KEEPS a queue/record that includes\n       *  - the event(s) that were processed based on implicit consent\n       *  - which tags were allowed to process each event (are set to implicit opt-in)\n       */\n      processEarlyQueue()\n      // fire the initial view if appropriate, and queue it\n      triggerTiqLoad()\n      window.tealiumCmpIntegration.implicitServices = consentedServices\n\n      // queue the initial 'view' on pageload if appropriate\n      if (!isNoviewSet &amp;&amp; isTealiumReady &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n        window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n        queueEventAndFireImplicitServices('view', window.utag.handler.C(window.utag.data))\n      }\n      // queue the current event if it exists (and this isn't just consent polling)\n      if (!isPureConsentEvent) {\n        return queueEventAndFireImplicitServices(a, b, c)\n      }\n    } else if (consentType === 'missing-map') {\n      logger('Something went wrong - all tags were blocked because no consent map was found for the active setting ID.')\n      return false\n    } else if (consentType === 'missing-tiq-consent') {\n      logger('Something went wrong - all tags were blocked because no consent was found for &quot;' + tiqServiceName + '&quot;, configured Tealium iQ name.\\n\\nConsent found: ' + JSON.stringify(consentedServices, null, 2))\n      return false\n    } else {\n      /**\n       * CASE T1: expected variables not populated (misconfiguration/error case)\n       *\n       * STOP and fire nothing at all. Do not retry or queue the event.\n       */\n      logger('Something went wrong - all tags were blocked because the consent response was not understood.')\n      return false\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the early event queue]{@link tealiumCmpIntegration.earlyEventQueue} (can include pageviews) for any currently-consented Services.\n   *\n   * Intended to be called first understandable implicit consent.\n   *\n   * @function processEarlyQueue\n   */\n  function processEarlyQueue () {\n    var queuedEvent\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    while (window.tealiumCmpIntegration.earlyEventQueue.length &gt; 0) {\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.earlyEventQueue.shift()\n      logger('Processing queued early event for currently consented tags: ' + JSON.stringify(queuedEvent, null, 2))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the global queue]{@link tealiumCmpIntegration.implicitEventQueue} (can include pageviews) for any newly-consented Services.\n   *\n   * Intended to be called on new EXPLICIT consent decision - queued events have already had IMPLICTLY consented tags fired, so those need to be excluded.\n   *\n   * @function processImplicitQueue\n   */\n  function processImplicitQueue () {\n    var alreadyLogged = false\n    var queuedEvent\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    while (window.tealiumCmpIntegration.implicitEventQueue.length &gt; 0) {\n      if (!alreadyLogged) {\n        alreadyLogged = true\n        logger('Explicit consent tracking request received - processing past implicitly tracked events (' + window.tealiumCmpIntegration.implicitEventQueue.length + ') for any new explicit tags.')\n      }\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.implicitEventQueue.shift()\n      logger('Triggering event for explicitly-consented tags: ' + JSON.stringify(queuedEvent))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the early queue]{@link tealiumCmpIntegration.earlyEventQueue}, without firing any tags.\n   *\n   * Intended to be called for events that triggered before we get an understandable response from Usercentrics.\n   *\n   * @function queueEarlyEvent\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEarlyEvent (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    // nothing will be allowed to fire\n    a.data[nameOfImplicitConsentArray] = []\n\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    window.tealiumCmpIntegration.earlyEventQueue.push(a)\n    logger('Queued early event!')\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration.implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for the initial pageview on load, since the load process will have already fired the implicit services.\n   *\n   * @function queueEventWithoutFiringImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventWithoutFiringImplicitServices (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    a.data[nameOfImplicitConsentArray] = window.tealiumCmpIntegration.implicitServices || []\n\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    window.tealiumCmpIntegration.implicitEventQueue.push(a)\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration~implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for all events other than the initial page load.\n   *\n   * @function queueEventAndFireImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventAndFireImplicitServices (a, b, c) {\n    // fire the implicit tags\n    window.utag.handler.trigger_old(a, b, c)\n    logger('Implicit consent tracking request fired (or queued, if utag hasn\\'t loaded).')\n    return queueEventWithoutFiringImplicitServices(a, b, c)\n  }\n\n  /**\n   * Generate a {@link TagToServiceMap TagToServiceMap} based on a {@link ServiceToTagMap ServiceToTagMap}\n   *\n   * @function getTagBasedMap\n   * @param {object} map a {@link ServiceToTagMap ServiceToTagMap} object\n   * @return {object} a {@link TagToServiceMap TagToServiceMap}\n   */\n  function getTagBasedMap (map) {\n    // generate a lookup based on the tagUid\n    if (typeof map !== 'object') return {}\n    var settingsId = getCurrentUsercentricsSettingsId() || ''\n    if (typeof settingsId !== 'string' || settingsId === '') return {}\n    var settingSpecificMap = map[settingsId] || {}\n    var serviceNames = Object.keys(settingSpecificMap)\n    var uidMap = {}\n    for (var i = 0; i &lt; serviceNames.length; i++) {\n      for (var j = 0; j &lt; settingSpecificMap[serviceNames[i]].length; j++) {\n        uidMap[settingSpecificMap[serviceNames[i]][j]] = serviceNames[i]\n      }\n    }\n    return uidMap\n  }\n\n  /**\n   * Get the current Usercentrics settingsId from the page.\n   *\n   * @returns {string} the Usercentrics settingsId, defaults to an empty string if none is found\n   */\n  function getCurrentUsercentricsSettingsId () {\n    return (window.usercentrics &amp;&amp; window.usercentrics.settingsId) || ''\n  }\n\n  /**\n   * Trigger the core logic with an up-to-date array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   * @function recheckForCmpAndConsent\n   */\n  function recheckForCmpAndConsent () {\n    var newConsentResponse = cmpConsentCheck()\n    reactToCmpResponse(newConsentResponse)\n  }\n\n  /**\n   * Call [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents} to get the current consent decision.\n   * @function cmpConsentCheck\n   */\n  function cmpConsentCheck () {\n    if (!window.usercentrics || typeof window.usercentrics.getConsents !== 'function') return false\n    var cmpConsentArray = window.usercentrics.getConsents()\n    return cmpConsentArray\n  }\n\n  /**\n   * Indicates if Usercentrics has loaded and returned a well-formed indication of user consent.\n   * @function checkForWellFormedDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is well-formed, otherwise 'false'\n   */\n  function checkForWellFormedDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; typeof cmpConsentArray[0].dataProcessingService === 'string') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if the user has made an EXPLICIT decision\n   * @function checkForExplicitConsentDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is EXPLICIT otherwise 'false'\n   */\n  function checkForExplicitConsentDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; cmpConsentArray[0].updatedBy === 'explicit') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if Tealium iQ has permission to run (and fire tags).\n   * @function checkForTiqConsent\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if TiQ is allowed to run, otherwise 'false'\n   */\n  function checkForTiqConsent (cmpConsentArray) {\n    var foundOptIn = false\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // check vendors if there's an object, look for at least one\n    cmpConsentArray.forEach(function (tagInfo) {\n      if (tagInfo.consentStatus === true &amp;&amp; tagInfo.dataProcessingService === tiqServiceName) {\n        foundOptIn = true\n      }\n    })\n    return foundOptIn\n  }\n\n  /**\n   * Create an instance of\n   * @param {array} cmpConsentArray the array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   */\n  function getVendorConsentsFromCmpConsentArray (cmpConsentArray) {\n    var vendorArray = []\n\n    var isWellFormed = checkForWellFormedDecision(cmpConsentArray)\n\n    if (!isWellFormed) {\n      vendorArray.type = 'missing-well-formed-response'\n      return []\n    }\n\n    var tagBasedMap = generateTagBasedMap()\n\n    // if there is no mapping for the settings id, we need to change the console output\n    var currentSettingsIdHasMapping = (typeof tagBasedMap === 'object' &amp;&amp; Object.keys(tagBasedMap).length &gt; 0)\n\n    if (!currentSettingsIdHasMapping) {\n      vendorArray.type = 'missing-map'\n      return []\n    }\n\n    cmpConsentArray &amp;&amp; cmpConsentArray.forEach(function (tagConsent) {\n      if (tagConsent.consentStatus === true) {\n        vendorArray.push(tagConsent.dataProcessingService)\n      }\n    })\n    vendorArray.type = checkForExplicitConsentDecision(cmpConsentArray) ? 'explicit' : 'implicit'\n\n    if (checkForTiqConsent(cmpConsentArray) === false) {\n      // change the consent type, but leave the array for debugging purposes\n      vendorArray.type = 'missing-tiq-consent'\n    }\n\n    return vendorArray\n  }\n\n  /**\n   * Get the current consent decision from the CMP for the active Setting\n   * @function getCurrentConsentDecision\n   * @returns a {@link ConsentDecision ConsentDecision}\n   */\n  function getCurrentConsentDecision () {\n    var freshConsent = cmpConsentCheck()\n\n    return getVendorConsentsFromCmpConsentArray(freshConsent)\n  }\n\n  /**\n   *  A conditional logging function - we can't use utag.DB directly because some of our logic needs to be preloader, but we can mimic the same logic so that our logging only displays when TiQ is in debug mode and/or not in Prod, or is explicitly forced.\n   * @function logger\n   * @param {string} message the message to be conditionally shown\n   * @param {boolean} showOutsideDebugMode if 'true', forces the message to shown outside of debug mode, except on Prod\n   */\n  function logger (message, showOutsideDebugMode) {\n    if (typeof tealiumEnvironment === 'undefined' || tealiumEnvironment === 'prod') {\n      // don't allow anything outside of debug mode on prod (disable this flag)\n      showOutsideDebugMode = false\n    }\n\n    if (showOutsideDebugMode || tiqInDebugMode) {\n      message = '\\n' + message + '\\n'\n      var formattedArr = []\n      formattedArr.push('****************')\n      var messageArr = message.split('\\n')\n      messageArr.forEach(function (messageLine) {\n        formattedArr.push('*  ' + messageLine)\n      })\n      formattedArr.push('****************')\n      var outputString = formattedArr.join('\\n')\n      console.log(outputString)\n    }\n  }\n\n  /**\n   * Stops Tealium iQ from loading (the TMS will not load tags or set a cookie if this function is called in Pre Loader), using the {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} setting\n   * @function stopTiq\n   */\n  function stopTiq () {\n    // logger(&quot;stopTiq function fired&quot;)\n    window.utag_cfg_ovrd = window.utag_cfg_ovrd || {}\n    window.utag_cfg_ovrd.noload = true\n  }\n\n  /**\n   * Allows TiQ to finish loading, intended to be called when a well-formed consent response is received, and that response allows Tealium iQ to run.\n   *\n   * Works by setting {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} to 'false' and calling Tealium iQ's utag.loader.PINIT method.\n   *\n   * If noload was 'true' and this function runs it must've been set to true by our own {@link module:extension-1~stopTiq stopTiq} function, because otherwise Tealium iQ wouldn't have been allowed to load/poll in the first place.\n   * @function triggerTiqLoad\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function triggerTiqLoad () {\n    // if usercentrics is ready on the first request, TiQ won't have loaded yet at all - let it load naturally\n    if (!window.utag) {\n      return true\n    }\n    // if TiQ has already loaded but these flags aren't truthy, we've interrupted the load and should retrigger it\n    // initial load / view (noview logic handled in utag.handler.trigger function itself)\n    if (!window.utag.handler || !window.utag.handler.iflag) {\n      // we don't need to reload actually, just allow it to finish loading\n      window.utag.cfg.noload = false // safe because this code only runs if it was set to false originally\n      window.utag.loader.PINIT()\n      return true\n    }\n    // already loaded\n    return false\n  }\n\n  /**\n   * If Tealium iQ hasn't loaded, load it (calling utag.handler.trigger in the process), otherwise call utag.handler.trigger.\n   * @function triggerOrQueue\n   */\n  function triggerOrQueue () {\n    var successfullyTriggeredLoadIfNeeded = triggerTiqLoad()\n    if (!successfullyTriggeredLoadIfNeeded) {\n      // explicit consent from polling, but load has already been triggered\n      return window.utag.handler.trigger(nameOfConsentPollingEvent)\n    }\n  }\n  /**\n   * Get the the current Tealium iQ environment.\n   *\n   * Since this runs in Pre Loader, it needs to use regex to recognize the utag.js file in the DOM and read the environment from the file name (there are no utag functions or objects at this point in the load).\n   *\n   * NOTE: This doesn't work correctly when using the the Environment Switcher (because the original script is added to the DOM instead of the new one, and the 307 redirect that's used to pull the new file(s) only changes the response, not the script element itself).\n   *\n   * If you're using the Environment Switcher on Prod and would like to see console output, set the [debug cookie]{@link https://docs.tealium.com/platforms/javascript/debugging/}.\n   *\n   * @function getTealiumEnvironment\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function getTealiumEnvironment () {\n    var allScripts = document.getElementsByTagName('script')\n    var re = /\\/([^/]*)\\/utag\\.js(\\?.*)*$/\n    for (var i = 0; i &lt; allScripts.length; i++) {\n      var result = re.exec(allScripts[i].src) // can be null\n      if (result &amp;&amp; result[1]) { // [1] is the result of the match\n        return result[1]\n      }\n    }\n    return 'prod' // default to guessing we're in prod, just in case we're actually in prod (to avoid logging in Prod)\n  }\n})()\n\n// Document key data structures here for clarity.\n\n/**\n * An array of Usercentrics Service Names that have permission to run (uses the 'dataProcessingService' property from [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}).\n *\n * Also includes a 'type' property that indicates whether the consent decision is IMPLICIT or EXPLICT.\n *\n * @static\n * @type {array}\n * @name ConsentDecision\n * @memberof! &lt;global&gt;\n * @property {string} type the type of consent, will be either 'implicit' or 'explicit'\n * @example\nvar exampleConsentDecision = window.tealiumCmpIntegration.getCurrentConsentDecision()\n\nJSON.stringify(exampleConsentDecision)\n// [&quot;Google Analytics&quot;,&quot;Another Tag&quot;,&quot;Tealium iQ Tag Management&quot;]\n\nexampleConsentDecision.type\n// &quot;explicit&quot;\n\nexampleConsentDecision.length\n// 3\n */\n\n/**\n * Assigns Tealium iQ Tags to Usercentrics Service Names. Each service can have multiple tags, but each tag can only have one service.  If the same tag UID appears in multiple Service arrays, only one will be used.\n *\n * The keys for the main object are Setting-IDs from Usercentrics, inside that are key/value pairs where the key is a Service Name from Usercentrics, and the value is an array of TagUIDs from Tealium iQ.\n *\n * This needs to be provided as per the example below, in [tealiumCmpIntegration.map]{@link namespace:tealiumCmpIntegration~map}.\n *\n * An [example Tealium iQ extension]{@link module:example-map} is provided as well.\n *\n * @static\n * @type {object}\n * @name ServiceToTagMap\n * @memberof! &lt;global&gt;\n * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n  'yPyIAIIxY': {\n    'Google Analytics': [6, 8, 10],\n    'Mouseflow': [7, 9],\n    'Another Tag': [11]\n  }\n}\n */\n\n/**\n * A simple lookup, with Tealium iQ tag UIDs as keys and the associated Usercentrics service name as strings as values. Each service can be associated with multiple tags, but each tag can be associated with one service.\n *\n * The example is based on the {@link ServiceToTagMap ServiceToTagMap} example, where the Usercentrics settingsId on the active page is 'yPyIAIIxY'.\n *\n * This object is automatically generated by the [getTagBasedMap]{@link module:extension-1~getTagbasedMap} method, and made available globally in [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration~tagBasedMap} for debugging and use within the extensions.\n *\n * @static\n * @type {object}\n * @name TagToServiceMap\n * @memberof! &lt;global&gt;\n * @example\n{\n  6: 'Google Analytics',\n  7: 'Mouseflow',\n  8: 'Google Analytics',\n  9: 'Mouseflow',\n  10: 'Google Analytics',\n  11: 'Another Tag'\n}\n */\n\n/**\n * An object from the [implicitEventQueue]{@link tealiumCmpIntegration.implicitEventQueue} or [earlyEventQueue]{@link tealiumCmpIntegration.earlyEventQueue}, which represents a Tealium iQ tracking event that's been processed based on an IMPLICIT [ConsentDecision]{@link ConsentDecision}\n *\n * Heavily based on the argument passed to [utag.track]{@link https://community.tealiumiq.com/t5/Tealium-iQ-Tag-Management/utag-track-method/td-p/24578}, since it's designed to be processed by that method.\n *\n * Initial pageviews (handled in the [utag.loader.initdata override]{@link module:extension-1~newUtagLoaderInitdata}) will NOT have metadata like cookies, qps, etc - utag.track calls (handled in the [utag.handler.trigger override]{@link module:extension-1~newUtagHandlerTrigger}) will. That's a byproduct of using utag.handler.trigger, which is later in the load - those metadata will be re-read when the queue is processed, and since this queue isn't persisted between pages, it should be fine like that - the only strange behavior will be that any metadata that aren't present on re-read will still be present after the re-read - only values that are still present will be replaced with new values.\n *\n * An alternative approach could be to manually remove 'cp.\\*', 'dom.\\*', 'ut.\\*', 'qp.\\*', 'meta.\\*' and possibly 'tealium_\\*' (except 'tealium_event') from the 'data' object before queueing - that hasn't been done so far.\n *\n * @static\n * @type {array}\n * @name QueuedEvent\n * @memberof! &lt;global&gt;\n * @property {string} event the type of tracking event, generally 'view' for pageviews or 'link' for other events\n * @property {object} data the Universal Data Object associated with the event (from utag_data or the b object)\n * @property {object} cfg an optional configuration object that can have a 'cb' property (for a callback function) and a 'uids' array, which is a list of tag UIDs that should be triggered by the event, regardless of whether load rules are met.\n * @example\n{\n  &quot;event&quot;: &quot;view&quot;,\n  &quot;data&quot;: {\n    &quot;page_type&quot;: &quot;test_virtual_view&quot;,\n    &quot;cp.utag_main_v_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;cp.utag_main__sn&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__se&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__ss&quot;: &quot;0&quot;,\n    &quot;cp.utag_main__st&quot;: &quot;1598990152209&quot;,\n    &quot;cp.utag_main_ses_id&quot;: &quot;1598988112353&quot;,\n    &quot;cp.utag_main__pn&quot;: &quot;3&quot;,\n    &quot;cp.utagdb&quot;: &quot;true&quot;,\n    &quot;dom.referrer&quot;: &quot;&quot;,\n    &quot;dom.title&quot;: &quot;Usercentrics Test&quot;,\n    &quot;dom.domain&quot;: &quot;solutions.tealium.net&quot;,\n    &quot;dom.query_string&quot;: &quot;&quot;,\n    &quot;dom.hash&quot;: &quot;&quot;,\n    &quot;dom.url&quot;: &quot;https://solutions.tealium.net/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.pathname&quot;: &quot;/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.viewport_height&quot;: 456,\n    &quot;dom.viewport_width&quot;: 1825,\n    &quot;ut.domain&quot;: &quot;tealium.net&quot;,\n    &quot;ut.version&quot;: &quot;ut4.46.202009011921&quot;,\n    &quot;ut.event&quot;: &quot;view&quot;,\n    &quot;ut.visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;ut.session_id&quot;: &quot;1598988112353&quot;,\n    &quot;ut.account&quot;: &quot;services-caleb&quot;,\n    &quot;ut.profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;ut.env&quot;: &quot;prod&quot;,\n    &quot;tealium_event&quot;: &quot;view&quot;,\n    &quot;tealium_visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;tealium_session_id&quot;: &quot;1598988112353&quot;,\n    &quot;tealium_session_number&quot;: &quot;4&quot;,\n    &quot;tealium_session_event_number&quot;: &quot;4&quot;,\n    &quot;tealium_datasource&quot;: &quot;&quot;,\n    &quot;tealium_account&quot;: &quot;services-caleb&quot;,\n    &quot;tealium_profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;tealium_environment&quot;: &quot;prod&quot;,\n    &quot;tealium_random&quot;: &quot;2085060854215077&quot;,\n    &quot;tealium_library_name&quot;: &quot;utag.js&quot;,\n    &quot;tealium_library_version&quot;: &quot;4.46.0&quot;,\n    &quot;tealium_timestamp_epoch&quot;: 1598988352,\n    &quot;tealium_timestamp_utc&quot;: &quot;2020-09-01T19:25:52.211Z&quot;,\n    &quot;tealium_timestamp_local&quot;: &quot;2020-09-01T21:25:52.211&quot;,\n    &quot;usercentrics_services_with_consent&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ],\n    &quot;usercentrics_consent_type&quot;: &quot;implicit&quot;,\n    &quot;_usercentrics_services_already_processed&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ]\n  },\n  &quot;cfg&quot;: {\n    &quot;cb&quot;: function myCallback () {console.log(&quot;Callback fired!&quot;)},\n    &quot;uids&quot;: [\n      11\n    ],\n    &quot;originalUids&quot;: [\n      7,\n      11\n    ],\n    &quot;blockedTagUids&quot;: [\n      11\n    ]\n  }\n}\n*/\n"}}},"initialize":"","labels":"","title":"RELEASE 1/2","id":"100040","_id":"10","extType":"Javascript Code","notes":"   Force","sort":"6","selectedTargets":{"dev":"true","prod":"true","qa":"true"},"blockPubTargetsLogic":"true","publishedTargets":"dev","type":"new"},"11":{"id":"100040","title":"RELEASE 2/2","labels":"","codeDevData":{"draftSeq":"2","promotedSnippets":{"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202010080753","promotedDraftName":"extension-2.js","name":"prod","code":"/* global b */\n\n/**\n *  Scope       : All Tags - After Load Rules\n *  Condition   : n/a\n *  Description : CMP 2/2 - After Load Rules component - Prevent tags from firing if they don't have an opt-in in the mapping (or there is no mapping)\n *\n */\n\n/**\n * @module extension-2\n * @description The 'All Tags - After Load Rules' component, responsible for blocking tags if consent is missing or this CMP integration is misconfigured.\n */\n\nvar map = (window.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.map) || {}\n\n// get settings from CMP 1 extension, shouldn't need to change these\nvar globals = window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nvar tiqServiceName = globals.tiqServiceName || 'Tealium iQ Tag Management' // the default name for our Service in Usercentrics\n\nvar nameOfVendorOptInArray = globals.nameOfVendorOptInArray || 'missing_opt_in_array_name'\nvar nameOfConsentTypeString = globals.nameOfConsentTypeString || 'missing_consent_type_name'\nvar nameOfImplicitConsentArray = globals.nameOfImplicitConsentArray || 'missing_implicit_queue_array_name'\n\nvar tagBasedMap = globals.tagBasedMap || {}\n\nvar getCurrentConsentDecision = globals.getCurrentConsentDecision || function () { return [] }\nvar getCurrentUsercentricsSettingsId = globals.getCurrentUsercentricsSettingsId || function () { return '' }\n\nvar logger = globals.logger || (window.utag &amp;&amp; window.utag.DB) || function (message) { console.log(message) } // logger function with fallback in case global function is missing\n\n// recheck\nvar currentlyAllowedVendors = getCurrentConsentDecision()\n\n// Add the current ConsentDecision information (allowed Services and consent type) to the UDO for possible use in extensions\nb[nameOfVendorOptInArray] = currentlyAllowedVendors\nb[nameOfConsentTypeString] = currentlyAllowedVendors &amp;&amp; currentlyAllowedVendors.type\n\nvar implicitServices\n\n// only block previous implicit services from reloading if the current consent is explicit\nif (currentlyAllowedVendors.type === 'explicit') {\n  implicitServices = b[nameOfImplicitConsentArray] // use the previously stored array, from the queued event\n}\n\nlogger('Called block logic:\\n\\nAllowed: ' + JSON.stringify(currentlyAllowedVendors, null, 2) + '\\n\\nAlready processed: ' + (implicitServices ? JSON.stringify(implicitServices, null, 2) : '(none)'))\n\nlogger('Map:\\n\\n' + JSON.stringify(map, null, 2) + '\\n\\nActive Usercentrics settingsId: ' + getCurrentUsercentricsSettingsId() + '\\n\\nMap has entry for current settingsId: ' + (typeof map[getCurrentUsercentricsSettingsId()] === 'object' ? 'true' : 'false') + '\\n\\nTag-based map for the active settingsId: ' + JSON.stringify(tagBasedMap, null, 2))\nlogger('Consent confirmed: ' + currentlyAllowedVendors.type + ' : ' + JSON.stringify(currentlyAllowedVendors, null, 2))\n\nvar newCfg = blockTagsBasedOnConsent(tagBasedMap, window.utag.loader.cfg, currentlyAllowedVendors, implicitServices)\n\n// logger('Tag block debug:' + JSON.stringify(newCfg, null, 2))\n\nwindow.utag.loader.cfg = newCfg\n\n/**\n * Blocks tags based on consent by manually setting the 'load' and 'send' flags to 0 for any tags that don't have permission to fire.\n *\n * That logic isn't sufficient to block tracking calls with a 'uids' array (which also circumvents load rules), so additional blocking logic is added in the utag.handler.trigger override.\n * @param {object} tagBasedMap a {@link TagToServiceMap TagToServiceMap}\n * @param {object} configObject the current window.utag.loader.cfg object (which is used to control which tags should load/fire)\n * @param {array} consentedServices a {@link ConsentDecision ConsentDecision}\n * @param {array} alreadyProcessedImplicitServices an array of Service Names that have already been processed, to avoid double-firing those tags.\n */\nfunction blockTagsBasedOnConsent (tagBasedMap, configObject, consentedServices, alreadyProcessedImplicitServices) {\n  // block all tags if the consented services array is missing\n  if (Array.isArray(consentedServices) !== true) {\n    consentedServices = []\n  }\n\n  tagBasedMap = tagBasedMap || {}\n\n  // if the utag template hasn't been edited, this function won't have been overriden, so we gut it\n  // to stop tags from firing\n  var utagFunctionsHaveBeenOverriden = window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1\n  if (utagFunctionsHaveBeenOverriden !== true) {\n    window.utag.handler.trigger = function () {\n      logger('Tags have been disabled because the required utag.loader edit hasn\\'t been done successfully and the tealiumCmpIntegration is active.')\n    }\n    consentedServices = []\n  }\n\n  var deactivatedTags = []\n  // turn the map into an easier-to-query object\n\n  alreadyProcessedImplicitServices = alreadyProcessedImplicitServices || []\n\n  var tiqIsAllowed = tiqServiceName &amp;&amp; consentedServices.indexOf(tiqServiceName) !== -1\n\n  var allTagUids = Object.keys(configObject)\n\n  var assignedServiceName\n  var hasConsent\n\n  // deactivate tags that aren't mapped and consented\n  for (var i = 0; i &lt; allTagUids.length; i++) {\n    hasConsent = false // assume no consent\n\n    assignedServiceName = tagBasedMap[allTagUids[i]] || false\n\n    if (assignedServiceName) {\n      hasConsent = tiqIsAllowed &amp;&amp; consentedServices.indexOf(assignedServiceName) !== -1 &amp;&amp; alreadyProcessedImplicitServices.indexOf(assignedServiceName) === -1\n    }\n\n    if (hasConsent !== true) {\n      // this isn't enough to stop specified tagUids (in the array) from firing by itself\n      configObject[allTagUids[i]].send = 0\n      configObject[allTagUids[i]].load = 0\n      deactivatedTags.push(allTagUids[i])\n    }\n  }\n  logger('Blocked tags: ' + JSON.stringify(deactivatedTags, null, 2) + (tiqIsAllowed ? '' : '\\n\\nAll tags blocked because TealiumIQ isn\\'t allowed to fire.'))\n  return configObject\n}\n"},"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"name":"qa","code":"// Type your JavaScript code here...","promotedBy":"caleb.jaquith@tealium.com","promotedDraftName":"BLANK","promotedTimestamp":"202010050843"},"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"name":"dev","code":"// Type your JavaScript code here...","promotedBy":"caleb.jaquith@tealium.com","promotedDraftName":"BLANK","promotedTimestamp":"202010050843"}},"queueSeq":"58","draftSnippets":{"2fa929d49a80e817505e2e615cdf1845c410c53247af9a8075b45620044e4a12":{"updatedBy":"caleb.jaquith@tealium.com","creationDate":"202010050833","updateDate":"202010050833","name":"BLANK","code":"// Type your JavaScript code here..."},"d90fc7fde547e2f883f63469ca5b98f71983b0bc4ca45dc8d0bf67aa99e8adb4":{"name":"extension-2.js","code":"/* global b */\n\n/**\n *  Scope       : All Tags - After Load Rules\n *  Condition   : n/a\n *  Description : CMP 2/2 - After Load Rules component - Prevent tags from firing if they don't have an opt-in in the mapping (or there is no mapping)\n *\n */\n\n/**\n * @module extension-2\n * @description The 'All Tags - After Load Rules' component, responsible for blocking tags if consent is missing or this CMP integration is misconfigured.\n */\n\nvar map = (window.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.map) || {}\n\n// get settings from CMP 1 extension, shouldn't need to change these\nvar globals = window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nvar tiqServiceName = globals.tiqServiceName || 'Tealium iQ Tag Management' // the default name for our Service in Usercentrics\n\nvar nameOfVendorOptInArray = globals.nameOfVendorOptInArray || 'missing_opt_in_array_name'\nvar nameOfConsentTypeString = globals.nameOfConsentTypeString || 'missing_consent_type_name'\nvar nameOfImplicitConsentArray = globals.nameOfImplicitConsentArray || 'missing_implicit_queue_array_name'\n\nvar tagBasedMap = globals.tagBasedMap || {}\n\nvar getCurrentConsentDecision = globals.getCurrentConsentDecision || function () { return [] }\nvar getCurrentUsercentricsSettingsId = globals.getCurrentUsercentricsSettingsId || function () { return '' }\n\nvar logger = globals.logger || (window.utag &amp;&amp; window.utag.DB) || function (message) { console.log(message) } // logger function with fallback in case global function is missing\n\n// recheck\nvar currentlyAllowedVendors = getCurrentConsentDecision()\n\n// Add the current ConsentDecision information (allowed Services and consent type) to the UDO for possible use in extensions\nb[nameOfVendorOptInArray] = currentlyAllowedVendors\nb[nameOfConsentTypeString] = currentlyAllowedVendors &amp;&amp; currentlyAllowedVendors.type\n\nvar implicitServices\n\n// only block previous implicit services from reloading if the current consent is explicit\nif (currentlyAllowedVendors.type === 'explicit') {\n  implicitServices = b[nameOfImplicitConsentArray] // use the previously stored array, from the queued event\n}\n\nlogger('Called block logic:\\n\\nAllowed: ' + JSON.stringify(currentlyAllowedVendors, null, 2) + '\\n\\nAlready processed: ' + (implicitServices ? JSON.stringify(implicitServices, null, 2) : '(none)'))\n\nlogger('Map:\\n\\n' + JSON.stringify(map, null, 2) + '\\n\\nActive Usercentrics settingsId: ' + getCurrentUsercentricsSettingsId() + '\\n\\nMap has entry for current settingsId: ' + (typeof map[getCurrentUsercentricsSettingsId()] === 'object' ? 'true' : 'false') + '\\n\\nTag-based map for the active settingsId: ' + JSON.stringify(tagBasedMap, null, 2))\nlogger('Consent confirmed: ' + currentlyAllowedVendors.type + ' : ' + JSON.stringify(currentlyAllowedVendors, null, 2))\n\nvar newCfg = blockTagsBasedOnConsent(tagBasedMap, window.utag.loader.cfg, currentlyAllowedVendors, implicitServices)\n\n// logger('Tag block debug:' + JSON.stringify(newCfg, null, 2))\n\nwindow.utag.loader.cfg = newCfg\n\n/**\n * Blocks tags based on consent by manually setting the 'load' and 'send' flags to 0 for any tags that don't have permission to fire.\n *\n * That logic isn't sufficient to block tracking calls with a 'uids' array (which also circumvents load rules), so additional blocking logic is added in the utag.handler.trigger override.\n * @param {object} tagBasedMap a {@link TagToServiceMap TagToServiceMap}\n * @param {object} configObject the current window.utag.loader.cfg object (which is used to control which tags should load/fire)\n * @param {array} consentedServices a {@link ConsentDecision ConsentDecision}\n * @param {array} alreadyProcessedImplicitServices an array of Service Names that have already been processed, to avoid double-firing those tags.\n */\nfunction blockTagsBasedOnConsent (tagBasedMap, configObject, consentedServices, alreadyProcessedImplicitServices) {\n  // block all tags if the consented services array is missing\n  if (Array.isArray(consentedServices) !== true) {\n    consentedServices = []\n  }\n\n  tagBasedMap = tagBasedMap || {}\n\n  // if the utag template hasn't been edited, this function won't have been overriden, so we gut it\n  // to stop tags from firing\n  var utagFunctionsHaveBeenOverriden = window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1\n  if (utagFunctionsHaveBeenOverriden !== true) {\n    window.utag.handler.trigger = function () {\n      logger('Tags have been disabled because the required utag.loader edit hasn\\'t been done successfully and the tealiumCmpIntegration is active.')\n    }\n    consentedServices = []\n  }\n\n  var deactivatedTags = []\n  // turn the map into an easier-to-query object\n\n  alreadyProcessedImplicitServices = alreadyProcessedImplicitServices || []\n\n  var tiqIsAllowed = tiqServiceName &amp;&amp; consentedServices.indexOf(tiqServiceName) !== -1\n\n  var allTagUids = Object.keys(configObject)\n\n  var assignedServiceName\n  var hasConsent\n\n  // deactivate tags that aren't mapped and consented\n  for (var i = 0; i &lt; allTagUids.length; i++) {\n    hasConsent = false // assume no consent\n\n    assignedServiceName = tagBasedMap[allTagUids[i]] || false\n\n    if (assignedServiceName) {\n      hasConsent = tiqIsAllowed &amp;&amp; consentedServices.indexOf(assignedServiceName) !== -1 &amp;&amp; alreadyProcessedImplicitServices.indexOf(assignedServiceName) === -1\n    }\n\n    if (hasConsent !== true) {\n      // this isn't enough to stop specified tagUids (in the array) from firing by itself\n      configObject[allTagUids[i]].send = 0\n      configObject[allTagUids[i]].load = 0\n      deactivatedTags.push(allTagUids[i])\n    }\n  }\n  logger('Blocked tags: ' + JSON.stringify(deactivatedTags, null, 2) + (tiqIsAllowed ? '' : '\\n\\nAll tags blocked because TealiumIQ isn\\'t allowed to fire.'))\n  return configObject\n}\n","versionControl":{"isReadOnly":"true","sourceUrl":"https://github.com/jaquith/usercentrics-integration/blob/release/extensions/extension-2.js","accountName":"jaquith","lastSyncTimeStamp":"202010080753","sourceName":"GitHub","isOutdated":"false","lastSyncSuccess":"true","hashValue":"8da85ba6458591f80d894fdf7ffc0890a66d7594"},"updatedBy":"caleb.jaquith@tealium.com","creationDate":"202008131558","updateDate":"202010021536"}}},"initialize":"","advExecOption":"alr","scope":"global","constructor":"","status":"active","type":"new","publishedTargets":"dev","blockPubTargetsLogic":"true","selectedTargets":{"prod":"true","dev":"true","qa":"true"},"sort":"7","notes":"Forceeee","extType":"Javascript Code","_id":"11"},"13":{"codeDevData":{"queueSeq":"2","draftSnippets":{"156e808776455eb7fb3231a67b22d1d38ab0ed941db5b8d157735eea6c9da88b":{"updatedBy":"caleb.jaquith@tealium.com","updateDate":"202008100854","creationDate":"202008100854","name":"Draft 1","code":"// Put this code in a Javascript Code extension scoped to the tag.\nu.callback = function() {\n console.log(&quot;The tag has loaded, now do cool stuff!&quot;);\n}"}},"draftSeq":"1"},"labels":"","initialize":"","advExecOption":"alr","status":"inactive","constructor":"","scope":"6","id":"100040","title":"Callback test","selectedTargets":{"qa":"true","dev":"true","prod":"true"},"notes":"","sort":"10","_id":"13","extType":"Javascript Code","type":"new","blockPubTargetsLogic":"true"},"14":{"publishedTargets":"dev","blockPubTargetsLogic":"true","type":"new","_id":"14","extType":"Javascript Code","selectedTargets":{"qa":"true","dev":"true","prod":"true"},"notes":"","sort":"5","id":"100040","title":"CMP Map","advExecOption":"alr","status":"active","constructor":"","scope":"preload","codeDevData":{"draftSnippets":{"156e808776455eb7fb3231a67b22d1d38ab0ed941db5b8d157735eea6c9da88b":{"updatedBy":"caleb.jaquith@tealium.com","updateDate":"202010021536","creationDate":"202008100949","name":"Draft 1","code":"window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n    'yPyIAIIxY': {\n      'Google Analytics': [6, 8, 10],\n      'Mouseflow': [7, 9],\n      'Another Tag': [11]\n    }\n}\n\n\n// if TiQ isn't allowed to fire, no tags will be fired at all, and no cookies will be set\n// window.tealiumCmpIntegration.tiqServiceName = 'Tealium iQ'\n"}},"queueSeq":"16","draftSeq":"1","promotedSnippets":{"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"name":"qa","code":"window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n    'yPyIAIIxY': {\n      'Google Analytics': [6, 8, 10],\n      'Mouseflow': [7, 9],\n      'Another Tag': [11]\n    }\n}\n\n\n// if TiQ isn't allowed to fire, no tags will be fired at all, and no cookies will be set\n// window.tealiumCmpIntegration.tiqServiceName = 'Tealium iQ'\n","promotedBy":"caleb.jaquith@tealium.com","promotedDraftName":"Draft 1","promotedTimestamp":"202010021537"},"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"name":"prod","code":"window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n    'yPyIAIIxY': {\n      'Google Analytics': [6, 8, 10],\n      'Mouseflow': [7, 9],\n      'Another Tag': [11]\n    }\n}\n\n\n// if TiQ isn't allowed to fire, no tags will be fired at all, and no cookies will be set\n// window.tealiumCmpIntegration.tiqServiceName = 'Tealium iQ'\n","promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202010021537","promotedDraftName":"Draft 1"},"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"promotedBy":"caleb.jaquith@tealium.com","promotedDraftName":"Draft 1","promotedTimestamp":"202010021537","name":"dev","code":"window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n    'yPyIAIIxY': {\n      'Google Analytics': [6, 8, 10],\n      'Mouseflow': [7, 9],\n      'Another Tag': [11]\n    }\n}\n\n\n// if TiQ isn't allowed to fire, no tags will be fired at all, and no cookies will be set\n// window.tealiumCmpIntegration.tiqServiceName = 'Tealium iQ'\n"}}},"initialize":"","labels":""},"15":{"sort":"4","notes":"","selectedTargets":{"dev":"true","prod":"true","qa":"true"},"extType":"Javascript Code","_id":"15","type":"new","blockPubTargetsLogic":"true","publishedTargets":"dev","initialize":"","codeDevData":{"draftSnippets":{"156e808776455eb7fb3231a67b22d1d38ab0ed941db5b8d157735eea6c9da88b":{"code":"document.cookie = &quot;utagdb=true&quot;\n\nwindow.utag_data = window.utag_data || {}\nwindow.utag_data.test = 'test123'","name":"Draft 1","creationDate":"202008101034","updateDate":"202008101916","updatedBy":"caleb.jaquith@tealium.com"}},"queueSeq":"4","promotedSnippets":{"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"code":"document.cookie = &quot;utagdb=true&quot;\n\nwindow.utag_data = window.utag_data || {}\nwindow.utag_data.test = 'test123'","name":"prod","promotedTimestamp":"202008140759","promotedDraftName":"Draft 1","promotedBy":"caleb.jaquith@tealium.com"},"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"code":"document.cookie = &quot;utagdb=true&quot;\n\nwindow.utag_data = window.utag_data || {}\nwindow.utag_data.test = 'test123'","name":"qa","promotedTimestamp":"202008140759","promotedDraftName":"Draft 1","promotedBy":"caleb.jaquith@tealium.com"},"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202008140759","promotedDraftName":"Draft 1","name":"dev","code":"document.cookie = &quot;utagdb=true&quot;\n\nwindow.utag_data = window.utag_data || {}\nwindow.utag_data.test = 'test123'"}},"draftSeq":"1"},"labels":"","constructor":"","scope":"preload","status":"active","advExecOption":"alr","title":"Activate debug mode and add a test variable to utag_data","id":"100040"},"16":{"publishedTargets":"dev","blockPubTargetsLogic":"true","type":"new","_id":"16","extType":"Javascript Code","selectedTargets":{"prod":"true","dev":"true","qa":"true"},"notes":"","sort":"0","id":"100040","title":"DataLayer Listener 1 - Suppress view event","advExecOption":"alr","status":"active","constructor":"","scope":"preload","labels":"","initialize":"","codeDevData":{"queueSeq":"1","draftSnippets":{"156e808776455eb7fb3231a67b22d1d38ab0ed941db5b8d157735eea6c9da88b":{"updatedBy":"caleb.jaquith@tealium.com","updateDate":"202009300925","creationDate":"202009300925","name":"Draft 1","code":" /**\n * Scope       : Pre Loader\n * Execution   : n/a\n * Condition   : n/a\n * Description : Disable automatic utag.view() event that fires on page load.\n */\n\n// disable the automatic view, we want to fire it from the listener instead\n// Doc: https://docs.tealium.com/platforms/javascript/settings/\nwindow.utag_cfg_ovrd = window.utag_cfg_ovrd || {};\nwindow.utag_cfg_ovrd.noview = true;"}},"promotedSnippets":{"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"code":" /**\n * Scope       : Pre Loader\n * Execution   : n/a\n * Condition   : n/a\n * Description : Disable automatic utag.view() event that fires on page load.\n */\n\n// disable the automatic view, we want to fire it from the listener instead\n// Doc: https://docs.tealium.com/platforms/javascript/settings/\nwindow.utag_cfg_ovrd = window.utag_cfg_ovrd || {};\nwindow.utag_cfg_ovrd.noview = true;","name":"dev","promotedTimestamp":"202009300932","promotedDraftName":"Draft 1","promotedBy":"caleb.jaquith@tealium.com"},"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"promotedTimestamp":"202009300932","promotedDraftName":"Draft 1","promotedBy":"caleb.jaquith@tealium.com","code":" /**\n * Scope       : Pre Loader\n * Execution   : n/a\n * Condition   : n/a\n * Description : Disable automatic utag.view() event that fires on page load.\n */\n\n// disable the automatic view, we want to fire it from the listener instead\n// Doc: https://docs.tealium.com/platforms/javascript/settings/\nwindow.utag_cfg_ovrd = window.utag_cfg_ovrd || {};\nwindow.utag_cfg_ovrd.noview = true;","name":"prod"},"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"promotedTimestamp":"202009300932","promotedDraftName":"Draft 1","promotedBy":"caleb.jaquith@tealium.com","code":" /**\n * Scope       : Pre Loader\n * Execution   : n/a\n * Condition   : n/a\n * Description : Disable automatic utag.view() event that fires on page load.\n */\n\n// disable the automatic view, we want to fire it from the listener instead\n// Doc: https://docs.tealium.com/platforms/javascript/settings/\nwindow.utag_cfg_ovrd = window.utag_cfg_ovrd || {};\nwindow.utag_cfg_ovrd.noview = true;","name":"qa"}},"draftSeq":"1"}},"17":{"_id":"17","extType":"Javascript Code","notes":"","sort":"1","selectedTargets":{"prod":"true","dev":"true","qa":"true"},"blockPubTargetsLogic":"true","publishedTargets":"dev","type":"new","status":"active","scope":"domready","constructor":"","advExecOption":"alr","labels":"","codeDevData":{"queueSeq":"1","draftSnippets":{"156e808776455eb7fb3231a67b22d1d38ab0ed941db5b8d157735eea6c9da88b":{"name":"Draft 1","code":"// from https://raw.githubusercontent.com/google/data-layer-helper/master/dist/data-layer-helper.js, as in https://community.tealiumiq.com/t5/Customer-Data-Hub/Tealium-Collect-and-Google-Tag-Manager-GTM-Setup-Guide/ta-p/17939\n\n(function(){/*\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\n'use strict';/*\n jQuery v1.9.1 (c) 2005, 2012\n jQuery Foundation, Inc. jquery.org/license.\n*/\nvar f=/\\[object (Boolean|Number|String|Function|Array|Date|RegExp|Arguments)\\]/;function g(a){return null==a?String(a):(a=f.exec(Object.prototype.toString.call(Object(a))))?a[1].toLowerCase():&quot;object&quot;}function m(a,b){return Object.prototype.hasOwnProperty.call(Object(a),b)}function n(a){if(!a||&quot;object&quot;!=g(a)||a.nodeType||a==a.window)return!1;try{if(a.constructor&amp;&amp;!m(a,&quot;constructor&quot;)&amp;&amp;!m(a.constructor.prototype,&quot;isPrototypeOf&quot;))return!1}catch(c){return!1}for(var b in a);return void 0===b||m(a,b)};function p(a,b){var c={},d=c;a=a.split(&quot;.&quot;);for(var e=0;e&lt;a.length-1;e++)d=d[a[e]]={};d[a[a.length-1]]=b;return c}function q(a,b){var c=!a._clear,d;for(d in a)if(m(a,d)){var e=a[d];&quot;array&quot;===g(e)&amp;&amp;c?(&quot;array&quot;===g(b[d])||(b[d]=[]),q(e,b[d])):n(e)&amp;&amp;c?(n(b[d])||(b[d]={}),q(e,b[d])):b[d]=e}delete b._clear};/*\n Copyright 2012 Google Inc. All rights reserved. */\nfunction r(a,b,c){b=void 0===b?{}:b;&quot;function&quot;===typeof b?b={listener:b,listenToPast:void 0===c?!1:c,processNow:!0,commandProcessors:{}}:b={listener:b.listener||function(){},listenToPast:b.listenToPast||!1,processNow:void 0===b.processNow?!0:b.processNow,commandProcessors:b.commandProcessors||{}};this.a=a;this.l=b.listener;this.j=b.listenToPast;this.g=this.i=!1;this.c={};this.f=[];this.b=b.commandProcessors;this.h=u(this);var d=this.a.push,e=this;this.a.push=function(){var k=[].slice.call(arguments,\n0),l=d.apply(e.a,k);v(e,k);return l};b.processNow&amp;&amp;this.process()}r.prototype.process=function(){this.registerProcessor(&quot;set&quot;,function(){var c={};1===arguments.length&amp;&amp;&quot;object&quot;===g(arguments[0])?c=arguments[0]:2===arguments.length&amp;&amp;&quot;string&quot;===g(arguments[0])&amp;&amp;(c=p(arguments[0],arguments[1]));return c});this.i=!0;for(var a=this.a.length,b=0;b&lt;a;b++)v(this,[this.a[b]],!this.j)};r.prototype.get=function(a){var b=this.c;a=a.split(&quot;.&quot;);for(var c=0;c&lt;a.length;c++){if(void 0===b[a[c]])return;b=b[a[c]]}return b};\nr.prototype.flatten=function(){this.a.splice(0,this.a.length);this.a[0]={};q(this.c,this.a[0])};r.prototype.registerProcessor=function(a,b){a in this.b||(this.b[a]=[]);this.b[a].push(b)};\nfunction v(a,b,c){c=void 0===c?!1:c;if(a.i&amp;&amp;(a.f.push.apply(a.f,b),!a.g))for(;0&lt;a.f.length;){b=a.f.shift();if(&quot;array&quot;===g(b))a:{var d=a.c;g(b[0]);for(var e=b[0].split(&quot;.&quot;),k=e.pop(),l=b.slice(1),h=0;h&lt;e.length;h++){if(void 0===d[e[h]])break a;d=d[e[h]]}try{d[k].apply(d,l)}catch(w){}}else if(&quot;arguments&quot;===g(b)){e=a;k=[];l=b[0];if(e.b[l])for(d=e.b[l].length,h=0;h&lt;d;h++)k.push(e.b[l][h].apply(e.h,[].slice.call(b,1)));a.f.push.apply(a.f,k)}else if(&quot;function&quot;==typeof b)try{b.call(a.h)}catch(w){}else if(n(b))for(var t in b)q(p(t,\nb[t]),a.c);else continue;c||(a.g=!0,a.l(a.c,b),a.g=!1)}}r.prototype.registerProcessor=r.prototype.registerProcessor;r.prototype.flatten=r.prototype.flatten;r.prototype.get=r.prototype.get;r.prototype.process=r.prototype.process;window.DataLayerHelper=r;function u(a){return{set:function(b,c){q(p(b,c),a.c)},get:function(b){return a.get(b)}}};})();","updatedBy":"caleb.jaquith@tealium.com","creationDate":"202009300927","updateDate":"202009300928"}},"draftSeq":"1","promotedSnippets":{"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"name":"dev","code":"// from https://raw.githubusercontent.com/google/data-layer-helper/master/dist/data-layer-helper.js, as in https://community.tealiumiq.com/t5/Customer-Data-Hub/Tealium-Collect-and-Google-Tag-Manager-GTM-Setup-Guide/ta-p/17939\n\n(function(){/*\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\n'use strict';/*\n jQuery v1.9.1 (c) 2005, 2012\n jQuery Foundation, Inc. jquery.org/license.\n*/\nvar f=/\\[object (Boolean|Number|String|Function|Array|Date|RegExp|Arguments)\\]/;function g(a){return null==a?String(a):(a=f.exec(Object.prototype.toString.call(Object(a))))?a[1].toLowerCase():&quot;object&quot;}function m(a,b){return Object.prototype.hasOwnProperty.call(Object(a),b)}function n(a){if(!a||&quot;object&quot;!=g(a)||a.nodeType||a==a.window)return!1;try{if(a.constructor&amp;&amp;!m(a,&quot;constructor&quot;)&amp;&amp;!m(a.constructor.prototype,&quot;isPrototypeOf&quot;))return!1}catch(c){return!1}for(var b in a);return void 0===b||m(a,b)};function p(a,b){var c={},d=c;a=a.split(&quot;.&quot;);for(var e=0;e&lt;a.length-1;e++)d=d[a[e]]={};d[a[a.length-1]]=b;return c}function q(a,b){var c=!a._clear,d;for(d in a)if(m(a,d)){var e=a[d];&quot;array&quot;===g(e)&amp;&amp;c?(&quot;array&quot;===g(b[d])||(b[d]=[]),q(e,b[d])):n(e)&amp;&amp;c?(n(b[d])||(b[d]={}),q(e,b[d])):b[d]=e}delete b._clear};/*\n Copyright 2012 Google Inc. All rights reserved. */\nfunction r(a,b,c){b=void 0===b?{}:b;&quot;function&quot;===typeof b?b={listener:b,listenToPast:void 0===c?!1:c,processNow:!0,commandProcessors:{}}:b={listener:b.listener||function(){},listenToPast:b.listenToPast||!1,processNow:void 0===b.processNow?!0:b.processNow,commandProcessors:b.commandProcessors||{}};this.a=a;this.l=b.listener;this.j=b.listenToPast;this.g=this.i=!1;this.c={};this.f=[];this.b=b.commandProcessors;this.h=u(this);var d=this.a.push,e=this;this.a.push=function(){var k=[].slice.call(arguments,\n0),l=d.apply(e.a,k);v(e,k);return l};b.processNow&amp;&amp;this.process()}r.prototype.process=function(){this.registerProcessor(&quot;set&quot;,function(){var c={};1===arguments.length&amp;&amp;&quot;object&quot;===g(arguments[0])?c=arguments[0]:2===arguments.length&amp;&amp;&quot;string&quot;===g(arguments[0])&amp;&amp;(c=p(arguments[0],arguments[1]));return c});this.i=!0;for(var a=this.a.length,b=0;b&lt;a;b++)v(this,[this.a[b]],!this.j)};r.prototype.get=function(a){var b=this.c;a=a.split(&quot;.&quot;);for(var c=0;c&lt;a.length;c++){if(void 0===b[a[c]])return;b=b[a[c]]}return b};\nr.prototype.flatten=function(){this.a.splice(0,this.a.length);this.a[0]={};q(this.c,this.a[0])};r.prototype.registerProcessor=function(a,b){a in this.b||(this.b[a]=[]);this.b[a].push(b)};\nfunction v(a,b,c){c=void 0===c?!1:c;if(a.i&amp;&amp;(a.f.push.apply(a.f,b),!a.g))for(;0&lt;a.f.length;){b=a.f.shift();if(&quot;array&quot;===g(b))a:{var d=a.c;g(b[0]);for(var e=b[0].split(&quot;.&quot;),k=e.pop(),l=b.slice(1),h=0;h&lt;e.length;h++){if(void 0===d[e[h]])break a;d=d[e[h]]}try{d[k].apply(d,l)}catch(w){}}else if(&quot;arguments&quot;===g(b)){e=a;k=[];l=b[0];if(e.b[l])for(d=e.b[l].length,h=0;h&lt;d;h++)k.push(e.b[l][h].apply(e.h,[].slice.call(b,1)));a.f.push.apply(a.f,k)}else if(&quot;function&quot;==typeof b)try{b.call(a.h)}catch(w){}else if(n(b))for(var t in b)q(p(t,\nb[t]),a.c);else continue;c||(a.g=!0,a.l(a.c,b),a.g=!1)}}r.prototype.registerProcessor=r.prototype.registerProcessor;r.prototype.flatten=r.prototype.flatten;r.prototype.get=r.prototype.get;r.prototype.process=r.prototype.process;window.DataLayerHelper=r;function u(a){return{set:function(b,c){q(p(b,c),a.c)},get:function(b){return a.get(b)}}};})();","promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202009300932","promotedDraftName":"Draft 1"},"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"promotedBy":"caleb.jaquith@tealium.com","promotedDraftName":"Draft 1","promotedTimestamp":"202009300932","name":"prod","code":"// from https://raw.githubusercontent.com/google/data-layer-helper/master/dist/data-layer-helper.js, as in https://community.tealiumiq.com/t5/Customer-Data-Hub/Tealium-Collect-and-Google-Tag-Manager-GTM-Setup-Guide/ta-p/17939\n\n(function(){/*\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\n'use strict';/*\n jQuery v1.9.1 (c) 2005, 2012\n jQuery Foundation, Inc. jquery.org/license.\n*/\nvar f=/\\[object (Boolean|Number|String|Function|Array|Date|RegExp|Arguments)\\]/;function g(a){return null==a?String(a):(a=f.exec(Object.prototype.toString.call(Object(a))))?a[1].toLowerCase():&quot;object&quot;}function m(a,b){return Object.prototype.hasOwnProperty.call(Object(a),b)}function n(a){if(!a||&quot;object&quot;!=g(a)||a.nodeType||a==a.window)return!1;try{if(a.constructor&amp;&amp;!m(a,&quot;constructor&quot;)&amp;&amp;!m(a.constructor.prototype,&quot;isPrototypeOf&quot;))return!1}catch(c){return!1}for(var b in a);return void 0===b||m(a,b)};function p(a,b){var c={},d=c;a=a.split(&quot;.&quot;);for(var e=0;e&lt;a.length-1;e++)d=d[a[e]]={};d[a[a.length-1]]=b;return c}function q(a,b){var c=!a._clear,d;for(d in a)if(m(a,d)){var e=a[d];&quot;array&quot;===g(e)&amp;&amp;c?(&quot;array&quot;===g(b[d])||(b[d]=[]),q(e,b[d])):n(e)&amp;&amp;c?(n(b[d])||(b[d]={}),q(e,b[d])):b[d]=e}delete b._clear};/*\n Copyright 2012 Google Inc. All rights reserved. */\nfunction r(a,b,c){b=void 0===b?{}:b;&quot;function&quot;===typeof b?b={listener:b,listenToPast:void 0===c?!1:c,processNow:!0,commandProcessors:{}}:b={listener:b.listener||function(){},listenToPast:b.listenToPast||!1,processNow:void 0===b.processNow?!0:b.processNow,commandProcessors:b.commandProcessors||{}};this.a=a;this.l=b.listener;this.j=b.listenToPast;this.g=this.i=!1;this.c={};this.f=[];this.b=b.commandProcessors;this.h=u(this);var d=this.a.push,e=this;this.a.push=function(){var k=[].slice.call(arguments,\n0),l=d.apply(e.a,k);v(e,k);return l};b.processNow&amp;&amp;this.process()}r.prototype.process=function(){this.registerProcessor(&quot;set&quot;,function(){var c={};1===arguments.length&amp;&amp;&quot;object&quot;===g(arguments[0])?c=arguments[0]:2===arguments.length&amp;&amp;&quot;string&quot;===g(arguments[0])&amp;&amp;(c=p(arguments[0],arguments[1]));return c});this.i=!0;for(var a=this.a.length,b=0;b&lt;a;b++)v(this,[this.a[b]],!this.j)};r.prototype.get=function(a){var b=this.c;a=a.split(&quot;.&quot;);for(var c=0;c&lt;a.length;c++){if(void 0===b[a[c]])return;b=b[a[c]]}return b};\nr.prototype.flatten=function(){this.a.splice(0,this.a.length);this.a[0]={};q(this.c,this.a[0])};r.prototype.registerProcessor=function(a,b){a in this.b||(this.b[a]=[]);this.b[a].push(b)};\nfunction v(a,b,c){c=void 0===c?!1:c;if(a.i&amp;&amp;(a.f.push.apply(a.f,b),!a.g))for(;0&lt;a.f.length;){b=a.f.shift();if(&quot;array&quot;===g(b))a:{var d=a.c;g(b[0]);for(var e=b[0].split(&quot;.&quot;),k=e.pop(),l=b.slice(1),h=0;h&lt;e.length;h++){if(void 0===d[e[h]])break a;d=d[e[h]]}try{d[k].apply(d,l)}catch(w){}}else if(&quot;arguments&quot;===g(b)){e=a;k=[];l=b[0];if(e.b[l])for(d=e.b[l].length,h=0;h&lt;d;h++)k.push(e.b[l][h].apply(e.h,[].slice.call(b,1)));a.f.push.apply(a.f,k)}else if(&quot;function&quot;==typeof b)try{b.call(a.h)}catch(w){}else if(n(b))for(var t in b)q(p(t,\nb[t]),a.c);else continue;c||(a.g=!0,a.l(a.c,b),a.g=!1)}}r.prototype.registerProcessor=r.prototype.registerProcessor;r.prototype.flatten=r.prototype.flatten;r.prototype.get=r.prototype.get;r.prototype.process=r.prototype.process;window.DataLayerHelper=r;function u(a){return{set:function(b,c){q(p(b,c),a.c)},get:function(b){return a.get(b)}}};})();"},"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"code":"// from https://raw.githubusercontent.com/google/data-layer-helper/master/dist/data-layer-helper.js, as in https://community.tealiumiq.com/t5/Customer-Data-Hub/Tealium-Collect-and-Google-Tag-Manager-GTM-Setup-Guide/ta-p/17939\n\n(function(){/*\n\n Copyright The Closure Library Authors.\n SPDX-License-Identifier: Apache-2.0\n*/\n'use strict';/*\n jQuery v1.9.1 (c) 2005, 2012\n jQuery Foundation, Inc. jquery.org/license.\n*/\nvar f=/\\[object (Boolean|Number|String|Function|Array|Date|RegExp|Arguments)\\]/;function g(a){return null==a?String(a):(a=f.exec(Object.prototype.toString.call(Object(a))))?a[1].toLowerCase():&quot;object&quot;}function m(a,b){return Object.prototype.hasOwnProperty.call(Object(a),b)}function n(a){if(!a||&quot;object&quot;!=g(a)||a.nodeType||a==a.window)return!1;try{if(a.constructor&amp;&amp;!m(a,&quot;constructor&quot;)&amp;&amp;!m(a.constructor.prototype,&quot;isPrototypeOf&quot;))return!1}catch(c){return!1}for(var b in a);return void 0===b||m(a,b)};function p(a,b){var c={},d=c;a=a.split(&quot;.&quot;);for(var e=0;e&lt;a.length-1;e++)d=d[a[e]]={};d[a[a.length-1]]=b;return c}function q(a,b){var c=!a._clear,d;for(d in a)if(m(a,d)){var e=a[d];&quot;array&quot;===g(e)&amp;&amp;c?(&quot;array&quot;===g(b[d])||(b[d]=[]),q(e,b[d])):n(e)&amp;&amp;c?(n(b[d])||(b[d]={}),q(e,b[d])):b[d]=e}delete b._clear};/*\n Copyright 2012 Google Inc. All rights reserved. */\nfunction r(a,b,c){b=void 0===b?{}:b;&quot;function&quot;===typeof b?b={listener:b,listenToPast:void 0===c?!1:c,processNow:!0,commandProcessors:{}}:b={listener:b.listener||function(){},listenToPast:b.listenToPast||!1,processNow:void 0===b.processNow?!0:b.processNow,commandProcessors:b.commandProcessors||{}};this.a=a;this.l=b.listener;this.j=b.listenToPast;this.g=this.i=!1;this.c={};this.f=[];this.b=b.commandProcessors;this.h=u(this);var d=this.a.push,e=this;this.a.push=function(){var k=[].slice.call(arguments,\n0),l=d.apply(e.a,k);v(e,k);return l};b.processNow&amp;&amp;this.process()}r.prototype.process=function(){this.registerProcessor(&quot;set&quot;,function(){var c={};1===arguments.length&amp;&amp;&quot;object&quot;===g(arguments[0])?c=arguments[0]:2===arguments.length&amp;&amp;&quot;string&quot;===g(arguments[0])&amp;&amp;(c=p(arguments[0],arguments[1]));return c});this.i=!0;for(var a=this.a.length,b=0;b&lt;a;b++)v(this,[this.a[b]],!this.j)};r.prototype.get=function(a){var b=this.c;a=a.split(&quot;.&quot;);for(var c=0;c&lt;a.length;c++){if(void 0===b[a[c]])return;b=b[a[c]]}return b};\nr.prototype.flatten=function(){this.a.splice(0,this.a.length);this.a[0]={};q(this.c,this.a[0])};r.prototype.registerProcessor=function(a,b){a in this.b||(this.b[a]=[]);this.b[a].push(b)};\nfunction v(a,b,c){c=void 0===c?!1:c;if(a.i&amp;&amp;(a.f.push.apply(a.f,b),!a.g))for(;0&lt;a.f.length;){b=a.f.shift();if(&quot;array&quot;===g(b))a:{var d=a.c;g(b[0]);for(var e=b[0].split(&quot;.&quot;),k=e.pop(),l=b.slice(1),h=0;h&lt;e.length;h++){if(void 0===d[e[h]])break a;d=d[e[h]]}try{d[k].apply(d,l)}catch(w){}}else if(&quot;arguments&quot;===g(b)){e=a;k=[];l=b[0];if(e.b[l])for(d=e.b[l].length,h=0;h&lt;d;h++)k.push(e.b[l][h].apply(e.h,[].slice.call(b,1)));a.f.push.apply(a.f,k)}else if(&quot;function&quot;==typeof b)try{b.call(a.h)}catch(w){}else if(n(b))for(var t in b)q(p(t,\nb[t]),a.c);else continue;c||(a.g=!0,a.l(a.c,b),a.g=!1)}}r.prototype.registerProcessor=r.prototype.registerProcessor;r.prototype.flatten=r.prototype.flatten;r.prototype.get=r.prototype.get;r.prototype.process=r.prototype.process;window.DataLayerHelper=r;function u(a){return{set:function(b,c){q(p(b,c),a.c)},get:function(b){return a.get(b)}}};})();","name":"qa","promotedDraftName":"Draft 1","promotedTimestamp":"202009300932","promotedBy":"caleb.jaquith@tealium.com"}}},"initialize":"","title":"DataLayer Listener 2 - Add listener library","id":"100040"},"18":{"advExecOption":"alr","status":"active","scope":"domready","constructor":"","codeDevData":{"queueSeq":"1","draftSnippets":{"156e808776455eb7fb3231a67b22d1d38ab0ed941db5b8d157735eea6c9da88b":{"name":"Draft 1","code":"//Define the teal global namespace\nwindow.teal = window.teal || {};\nteal.ignore_keys = {};\nteal.replace_keys = {};\nteal.prefix = &quot;&quot;;\n\n//In cases of a nested object, what should join the parent key and child key\nteal.nested_delimiter = &quot;.&quot;;\n\n//Ignore keys in the data layer that start with the following text.\n//Expecting an object of strings\n/*\nteal.ignore_keys = {\n  &quot;user&quot; : 1,\n  &quot;util&quot; : 1\n};\n*/\n\n//Specify a prefix for data layer elements being sent to the utag_data object.\n//Instead of utag_data.productID, it could be utag_data.dl_productID\n// teal.prefix = &quot;dl_&quot;;\n\n//Keys to be removed from the new flattened key name\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.page.pi.pageName\n/* teal.replace_keys = {\n    &quot;pageInfo&quot;:&quot;pi&quot;\n  };\n*/\n\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.page.pageName\n/* teal.replace_keys = {\n    &quot;pageInfo&quot;:&quot;&quot;\n  };\n*/\n\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.pageName\n/* teal.replace_keys = {\n    &quot;page&quot;:&quot;&quot;,\n    &quot;pageInfo&quot;:&quot;&quot;\n  };\n*/\n\n/*****************DO NOT MODIFY BELOW***********************/\n\nteal.flattener_version = 1.4;\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n// Add the Object.keys method for older versions of IE\nObject.keys||(Object.keys=function(){&quot;use strict&quot;;var a=Object.prototype.hasOwnProperty,b=!{toString:null}.propertyIsEnumerable(&quot;toString&quot;),c=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=c.length;return function(e){if(&quot;object&quot;!=typeof e&amp;&amp;(&quot;function&quot;!=typeof e||null===e))throw new TypeError(&quot;Object.keys called on non-object&quot;);var g,h,f=[];for(g in e)a.call(e,g)&amp;&amp;f.push(g);if(b)for(h=0;h&lt;d;h++)a.call(e,c[h])&amp;&amp;f.push(c[h]);return f}}());\n\nteal.ignoreKey = function(key,re){\n  var should_ignore_key = 0;\n  //Build a new array to avoid running through Object.keys multiple times\n  if(typeof teal.ignore_keys_list === 'undefined'){\n    teal.ignore_keys_list = Object.keys(teal.ignore_keys);\n    teal.ignore_keys_list.forEach(function(name){\n      //Store a copy of the regex in the object\n      teal.ignore_keys[name] = new RegExp(&quot;^&quot;+name);\n      if(key.match(teal.ignore_keys[name])){\n        should_ignore_key = 1;\n      }\n    });\n  }else{\n    //Loop through the ignore_keys object to see if we should ignore this key\n    teal.ignore_keys_list.forEach(function(name){\n      if(key.match(teal.ignore_keys[name])){\n        should_ignore_key = 1;\n      }\n    });\n  }\n  return should_ignore_key;\n}\n\nteal.getKeyName = function(key,re){\n  //Create a new object to store regexs or use existing one\n  teal.replace_keys_regex = teal.replace_keys_regex || {};\n  //Build a new array to avoid running through Object.keys multiple times\n  if(typeof teal.replace_keys_list === 'undefined'){\n    teal.replace_keys_list = Object.keys(teal.replace_keys);\n    //Make a start of string and end of string regex\n    teal.replace_keys_regex.startOfString = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n    teal.replace_keys_regex.endOfString = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]$&quot;);\n    teal.replace_keys_list.forEach(function(name){\n      //Store a copy of the regex in the teal.replace_keys_regex object so that the regexs are only built once\n      teal.replace_keys_regex[name] = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]?&quot; + name + &quot;[&quot; + teal.nested_delimiter + &quot;]?&quot;, &quot;g&quot;);\n      key = teal.keyReplace(key,name,teal.replace_keys_regex[name]);\n    });\n  }else{\n    //Loop through the replace_keys object to see what we should be replacing\n    teal.replace_keys_list.forEach(function(name){\n      key = teal.keyReplace(key,name,teal.replace_keys_regex[name]);\n    });\n  }\n  return key;\n}\n\nteal.keyReplace = function(key,name,re){\n  //Check to see if we are replacing the key name with a new value or if we are removing the key altogether\n  if(teal.replace_keys[name] === ''){\n    //The key needs to be removed completely\n    key = key.replace(re,teal.nested_delimiter);\n    //Check to see if the key starts with the nested delimiter and if so, remove it\n    if(key.indexOf(teal.nested_delimiter) === 0){\n      var cleanRegEx = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n  }else{\n    //Make a copy of the original key to see how we need to update the key name\n    var origKey = key;\n    //Replace the key name\n    key = key.replace(re,teal.nested_delimiter + teal.replace_keys[name] + teal.nested_delimiter);\n    //Check for the start of the origKey to see of the nested delimiter is there\n    if(!origKey.match(teal.replace_keys_regex.startOfString)){\n      //Remove the nested delimiter from the start of the string\n      var cleanRegEx = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n    //Check for the end of the origKey to see of the nested delimiter is there\n    if(!origKey.match(teal.replace_keys_regex.endOfString)){\n      //Add the nested delimiter to the end of the string\n      var cleanRegEx = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]$&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n  }\n  return key;\n}\n\nteal.processDataObject = function(obj,new_obj,parent_key,create_array){\n  if(typeof parent_key === &quot;undefined&quot;){\n    //This object isn't nested in another object\n    parent_key = &quot;&quot;;\n  }else{\n    //Add the nested_delimiter to the parent key if the delimiter isn't already at the end\n    teal.nested_delimiter_regex = teal.nested_delimiter_regex || new RegExp(&quot;[&quot;+teal.nested_delimiter+&quot;]$&quot;);\n    if(!parent_key.match(teal.nested_delimiter_regex)){\n      parent_key += &quot;&quot;+teal.nested_delimiter;\n    }\n  }\n  Object.keys(obj).forEach(function(key){\n    var nested_key_name = parent_key+key;\n    //Format the new key name and take out any whitespace\n    var new_key_name = teal.getKeyName((teal.prefix+parent_key+key).replace(/\\s/g, ''));\n    //Set the key_type to limit the number of typeof checks\n    var key_type = teal.typeOf(obj[key]);\n    if(key_type !== 'undefined' &amp;&amp; key_type != null){\n      if(key_type.match(/boolean|string|number|date/) &amp;&amp; !teal.ignoreKey(key)){\n        //If obj[key] is a date, convert to ISOString\n        if(teal.typeOf(obj[key]) === 'date'){\n          obj[key] = obj[key].toISOString();\n        }\n        //Check to see if we need to create an array for this data point\n        if(create_array){\n          //First check to see if this key exists\n          if(teal.typeOf(new_obj[new_key_name]) !== &quot;array&quot;){\n            //Make the key an array\n            new_obj[new_key_name] = [];\n          }\n          new_obj[new_key_name].push(&quot;&quot;+obj[key]); //Force value to be a string\n        }else{\n          //If the value of the key is a boolean or a string or a number and\n          //the key shouldn't be ignored add to the data layer\n          new_obj[new_key_name] = &quot;&quot;+obj[key]; //Force value to be a string\n        }\n      }else if(key_type === 'object' &amp;&amp; !teal.ignoreKey(key)){\n        //Process this piece of the data layer and merge it\n        teal.processDataObject(obj[key],new_obj,nested_key_name,create_array);\n      }else if(key_type === 'array'){\n        teal.processDataArray(obj[key],new_obj,nested_key_name);\n      }\n    }\n  });\n}\n\nteal.processDataArray = function(obj,new_obj,parent_key){\n  var objLength = obj.length;\n  if(typeof parent_key === &quot;undefined&quot;){\n    //This object isn't nested in another object\n    parent_key = &quot;&quot;;\n  }else if(objLength &gt; 0 &amp;&amp; teal.typeOf(obj[0]).match(/boolean|string|number|date/)){\n    //This is a normal array that doesn't need a nested delimiter\n  }else{\n    //Add the nested_delimiter to the parent key\n    parent_key += &quot;&quot;+teal.nested_delimiter;\n  }\n  //Format the new key name and take out any whitespace\n  var new_key_name = teal.getKeyName((teal.prefix+parent_key).replace(/\\s/g, ''));\n  for(var n = 0; n &lt; objLength; n++){\n    var key_type = teal.typeOf(obj[n]);\n    if(key_type.match(/boolean|string|number|date/)){\n      //If obj[n] is a date, convert to ISOString\n      if(key_type === 'date'){\n        obj[n] = obj[n].toISOString();\n      }\n      //First check to see if this key exists\n      if(teal.typeOf(new_obj[new_key_name]) !== &quot;array&quot;){\n        //Make the key an array\n        new_obj[new_key_name] = [];\n      }\n      //If the value of the key is a boolean or a string or a number and\n      //the key shouldn't be ignored add to the data layer\n      new_obj[new_key_name].push(&quot;&quot;+obj[n]);\n    }else if(key_type === 'object'){\n      teal.processDataObject(obj[n],new_obj,new_key_name,1);\n    }\n  }\n}\n\nteal.typeOf = function(e){return ({}).toString.call(e).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();}\n\nteal.flattenObject = function(obj,new_obj){\n  //Make sure object exists\n  if(typeof obj === 'undefined'){\n    return false;\n  }\n  //Check to see if we want to flatten the same object and keep the reference\n  var mergeObject = false;\n  if(obj === new_obj){\n    mergeObject = true;\n    //Start off a clean copy of the object\n    new_obj = {};\n  }\n  //Make sure new object exists\n  if(typeof new_obj === 'undefined'){\n    new_obj = {};\n  }\n  //Check to see if this object is an array\n  if(teal.typeOf(obj) === 'array'){\n    //Store a safe copy of this object in case we are processing the b object\n    var temp_array = JSON.parse(JSON.stringify(obj));\n    var temp_array_length = temp_array.length;\n    //Clean up the object\n    obj = {};\n    //Let's see if the obj and new_obj are the same.  If so, going to assume we are using the b object\n    if(obj == new_obj){\n      //Let's ensure that we have the a object\n      if(typeof a === 'undefined'){\n        var a = 'view';\n      }\n      //Add the automatic utag data points\n      utag.loader.RD(new_obj,a);\n    }\n    for(var i = 0; i &lt; temp_array_length; i++){\n        teal.processDataObject(temp_array[i],new_obj);\n    }\n  }else{\n    teal.processDataObject(obj,new_obj);\n  }\n  if(mergeObject){\n    //Need to delete everything out of obj and replace with new_obj\n    Object.keys(obj).forEach(function(key){\n      delete obj[key];\n    });\n    //Now that we have a clean original object, add everything from new_obj which allows the reference to be kept\n    Object.keys(new_obj).forEach(function(key){\n      obj[key] = new_obj[key];\n    });\n  }\n\n  return new_obj;\n}","updatedBy":"caleb.jaquith@tealium.com","updateDate":"202009300929","creationDate":"202009300929"}},"promotedSnippets":{"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"promotedBy":"caleb.jaquith@tealium.com","promotedDraftName":"Draft 1","promotedTimestamp":"202009300932","name":"dev","code":"//Define the teal global namespace\nwindow.teal = window.teal || {};\nteal.ignore_keys = {};\nteal.replace_keys = {};\nteal.prefix = &quot;&quot;;\n\n//In cases of a nested object, what should join the parent key and child key\nteal.nested_delimiter = &quot;.&quot;;\n\n//Ignore keys in the data layer that start with the following text.\n//Expecting an object of strings\n/*\nteal.ignore_keys = {\n  &quot;user&quot; : 1,\n  &quot;util&quot; : 1\n};\n*/\n\n//Specify a prefix for data layer elements being sent to the utag_data object.\n//Instead of utag_data.productID, it could be utag_data.dl_productID\n// teal.prefix = &quot;dl_&quot;;\n\n//Keys to be removed from the new flattened key name\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.page.pi.pageName\n/* teal.replace_keys = {\n    &quot;pageInfo&quot;:&quot;pi&quot;\n  };\n*/\n\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.page.pageName\n/* teal.replace_keys = {\n    &quot;pageInfo&quot;:&quot;&quot;\n  };\n*/\n\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.pageName\n/* teal.replace_keys = {\n    &quot;page&quot;:&quot;&quot;,\n    &quot;pageInfo&quot;:&quot;&quot;\n  };\n*/\n\n/*****************DO NOT MODIFY BELOW***********************/\n\nteal.flattener_version = 1.4;\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n// Add the Object.keys method for older versions of IE\nObject.keys||(Object.keys=function(){&quot;use strict&quot;;var a=Object.prototype.hasOwnProperty,b=!{toString:null}.propertyIsEnumerable(&quot;toString&quot;),c=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=c.length;return function(e){if(&quot;object&quot;!=typeof e&amp;&amp;(&quot;function&quot;!=typeof e||null===e))throw new TypeError(&quot;Object.keys called on non-object&quot;);var g,h,f=[];for(g in e)a.call(e,g)&amp;&amp;f.push(g);if(b)for(h=0;h&lt;d;h++)a.call(e,c[h])&amp;&amp;f.push(c[h]);return f}}());\n\nteal.ignoreKey = function(key,re){\n  var should_ignore_key = 0;\n  //Build a new array to avoid running through Object.keys multiple times\n  if(typeof teal.ignore_keys_list === 'undefined'){\n    teal.ignore_keys_list = Object.keys(teal.ignore_keys);\n    teal.ignore_keys_list.forEach(function(name){\n      //Store a copy of the regex in the object\n      teal.ignore_keys[name] = new RegExp(&quot;^&quot;+name);\n      if(key.match(teal.ignore_keys[name])){\n        should_ignore_key = 1;\n      }\n    });\n  }else{\n    //Loop through the ignore_keys object to see if we should ignore this key\n    teal.ignore_keys_list.forEach(function(name){\n      if(key.match(teal.ignore_keys[name])){\n        should_ignore_key = 1;\n      }\n    });\n  }\n  return should_ignore_key;\n}\n\nteal.getKeyName = function(key,re){\n  //Create a new object to store regexs or use existing one\n  teal.replace_keys_regex = teal.replace_keys_regex || {};\n  //Build a new array to avoid running through Object.keys multiple times\n  if(typeof teal.replace_keys_list === 'undefined'){\n    teal.replace_keys_list = Object.keys(teal.replace_keys);\n    //Make a start of string and end of string regex\n    teal.replace_keys_regex.startOfString = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n    teal.replace_keys_regex.endOfString = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]$&quot;);\n    teal.replace_keys_list.forEach(function(name){\n      //Store a copy of the regex in the teal.replace_keys_regex object so that the regexs are only built once\n      teal.replace_keys_regex[name] = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]?&quot; + name + &quot;[&quot; + teal.nested_delimiter + &quot;]?&quot;, &quot;g&quot;);\n      key = teal.keyReplace(key,name,teal.replace_keys_regex[name]);\n    });\n  }else{\n    //Loop through the replace_keys object to see what we should be replacing\n    teal.replace_keys_list.forEach(function(name){\n      key = teal.keyReplace(key,name,teal.replace_keys_regex[name]);\n    });\n  }\n  return key;\n}\n\nteal.keyReplace = function(key,name,re){\n  //Check to see if we are replacing the key name with a new value or if we are removing the key altogether\n  if(teal.replace_keys[name] === ''){\n    //The key needs to be removed completely\n    key = key.replace(re,teal.nested_delimiter);\n    //Check to see if the key starts with the nested delimiter and if so, remove it\n    if(key.indexOf(teal.nested_delimiter) === 0){\n      var cleanRegEx = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n  }else{\n    //Make a copy of the original key to see how we need to update the key name\n    var origKey = key;\n    //Replace the key name\n    key = key.replace(re,teal.nested_delimiter + teal.replace_keys[name] + teal.nested_delimiter);\n    //Check for the start of the origKey to see of the nested delimiter is there\n    if(!origKey.match(teal.replace_keys_regex.startOfString)){\n      //Remove the nested delimiter from the start of the string\n      var cleanRegEx = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n    //Check for the end of the origKey to see of the nested delimiter is there\n    if(!origKey.match(teal.replace_keys_regex.endOfString)){\n      //Add the nested delimiter to the end of the string\n      var cleanRegEx = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]$&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n  }\n  return key;\n}\n\nteal.processDataObject = function(obj,new_obj,parent_key,create_array){\n  if(typeof parent_key === &quot;undefined&quot;){\n    //This object isn't nested in another object\n    parent_key = &quot;&quot;;\n  }else{\n    //Add the nested_delimiter to the parent key if the delimiter isn't already at the end\n    teal.nested_delimiter_regex = teal.nested_delimiter_regex || new RegExp(&quot;[&quot;+teal.nested_delimiter+&quot;]$&quot;);\n    if(!parent_key.match(teal.nested_delimiter_regex)){\n      parent_key += &quot;&quot;+teal.nested_delimiter;\n    }\n  }\n  Object.keys(obj).forEach(function(key){\n    var nested_key_name = parent_key+key;\n    //Format the new key name and take out any whitespace\n    var new_key_name = teal.getKeyName((teal.prefix+parent_key+key).replace(/\\s/g, ''));\n    //Set the key_type to limit the number of typeof checks\n    var key_type = teal.typeOf(obj[key]);\n    if(key_type !== 'undefined' &amp;&amp; key_type != null){\n      if(key_type.match(/boolean|string|number|date/) &amp;&amp; !teal.ignoreKey(key)){\n        //If obj[key] is a date, convert to ISOString\n        if(teal.typeOf(obj[key]) === 'date'){\n          obj[key] = obj[key].toISOString();\n        }\n        //Check to see if we need to create an array for this data point\n        if(create_array){\n          //First check to see if this key exists\n          if(teal.typeOf(new_obj[new_key_name]) !== &quot;array&quot;){\n            //Make the key an array\n            new_obj[new_key_name] = [];\n          }\n          new_obj[new_key_name].push(&quot;&quot;+obj[key]); //Force value to be a string\n        }else{\n          //If the value of the key is a boolean or a string or a number and\n          //the key shouldn't be ignored add to the data layer\n          new_obj[new_key_name] = &quot;&quot;+obj[key]; //Force value to be a string\n        }\n      }else if(key_type === 'object' &amp;&amp; !teal.ignoreKey(key)){\n        //Process this piece of the data layer and merge it\n        teal.processDataObject(obj[key],new_obj,nested_key_name,create_array);\n      }else if(key_type === 'array'){\n        teal.processDataArray(obj[key],new_obj,nested_key_name);\n      }\n    }\n  });\n}\n\nteal.processDataArray = function(obj,new_obj,parent_key){\n  var objLength = obj.length;\n  if(typeof parent_key === &quot;undefined&quot;){\n    //This object isn't nested in another object\n    parent_key = &quot;&quot;;\n  }else if(objLength &gt; 0 &amp;&amp; teal.typeOf(obj[0]).match(/boolean|string|number|date/)){\n    //This is a normal array that doesn't need a nested delimiter\n  }else{\n    //Add the nested_delimiter to the parent key\n    parent_key += &quot;&quot;+teal.nested_delimiter;\n  }\n  //Format the new key name and take out any whitespace\n  var new_key_name = teal.getKeyName((teal.prefix+parent_key).replace(/\\s/g, ''));\n  for(var n = 0; n &lt; objLength; n++){\n    var key_type = teal.typeOf(obj[n]);\n    if(key_type.match(/boolean|string|number|date/)){\n      //If obj[n] is a date, convert to ISOString\n      if(key_type === 'date'){\n        obj[n] = obj[n].toISOString();\n      }\n      //First check to see if this key exists\n      if(teal.typeOf(new_obj[new_key_name]) !== &quot;array&quot;){\n        //Make the key an array\n        new_obj[new_key_name] = [];\n      }\n      //If the value of the key is a boolean or a string or a number and\n      //the key shouldn't be ignored add to the data layer\n      new_obj[new_key_name].push(&quot;&quot;+obj[n]);\n    }else if(key_type === 'object'){\n      teal.processDataObject(obj[n],new_obj,new_key_name,1);\n    }\n  }\n}\n\nteal.typeOf = function(e){return ({}).toString.call(e).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();}\n\nteal.flattenObject = function(obj,new_obj){\n  //Make sure object exists\n  if(typeof obj === 'undefined'){\n    return false;\n  }\n  //Check to see if we want to flatten the same object and keep the reference\n  var mergeObject = false;\n  if(obj === new_obj){\n    mergeObject = true;\n    //Start off a clean copy of the object\n    new_obj = {};\n  }\n  //Make sure new object exists\n  if(typeof new_obj === 'undefined'){\n    new_obj = {};\n  }\n  //Check to see if this object is an array\n  if(teal.typeOf(obj) === 'array'){\n    //Store a safe copy of this object in case we are processing the b object\n    var temp_array = JSON.parse(JSON.stringify(obj));\n    var temp_array_length = temp_array.length;\n    //Clean up the object\n    obj = {};\n    //Let's see if the obj and new_obj are the same.  If so, going to assume we are using the b object\n    if(obj == new_obj){\n      //Let's ensure that we have the a object\n      if(typeof a === 'undefined'){\n        var a = 'view';\n      }\n      //Add the automatic utag data points\n      utag.loader.RD(new_obj,a);\n    }\n    for(var i = 0; i &lt; temp_array_length; i++){\n        teal.processDataObject(temp_array[i],new_obj);\n    }\n  }else{\n    teal.processDataObject(obj,new_obj);\n  }\n  if(mergeObject){\n    //Need to delete everything out of obj and replace with new_obj\n    Object.keys(obj).forEach(function(key){\n      delete obj[key];\n    });\n    //Now that we have a clean original object, add everything from new_obj which allows the reference to be kept\n    Object.keys(new_obj).forEach(function(key){\n      obj[key] = new_obj[key];\n    });\n  }\n\n  return new_obj;\n}"},"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"promotedDraftName":"Draft 1","promotedTimestamp":"202009300932","promotedBy":"caleb.jaquith@tealium.com","code":"//Define the teal global namespace\nwindow.teal = window.teal || {};\nteal.ignore_keys = {};\nteal.replace_keys = {};\nteal.prefix = &quot;&quot;;\n\n//In cases of a nested object, what should join the parent key and child key\nteal.nested_delimiter = &quot;.&quot;;\n\n//Ignore keys in the data layer that start with the following text.\n//Expecting an object of strings\n/*\nteal.ignore_keys = {\n  &quot;user&quot; : 1,\n  &quot;util&quot; : 1\n};\n*/\n\n//Specify a prefix for data layer elements being sent to the utag_data object.\n//Instead of utag_data.productID, it could be utag_data.dl_productID\n// teal.prefix = &quot;dl_&quot;;\n\n//Keys to be removed from the new flattened key name\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.page.pi.pageName\n/* teal.replace_keys = {\n    &quot;pageInfo&quot;:&quot;pi&quot;\n  };\n*/\n\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.page.pageName\n/* teal.replace_keys = {\n    &quot;pageInfo&quot;:&quot;&quot;\n  };\n*/\n\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.pageName\n/* teal.replace_keys = {\n    &quot;page&quot;:&quot;&quot;,\n    &quot;pageInfo&quot;:&quot;&quot;\n  };\n*/\n\n/*****************DO NOT MODIFY BELOW***********************/\n\nteal.flattener_version = 1.4;\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n// Add the Object.keys method for older versions of IE\nObject.keys||(Object.keys=function(){&quot;use strict&quot;;var a=Object.prototype.hasOwnProperty,b=!{toString:null}.propertyIsEnumerable(&quot;toString&quot;),c=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=c.length;return function(e){if(&quot;object&quot;!=typeof e&amp;&amp;(&quot;function&quot;!=typeof e||null===e))throw new TypeError(&quot;Object.keys called on non-object&quot;);var g,h,f=[];for(g in e)a.call(e,g)&amp;&amp;f.push(g);if(b)for(h=0;h&lt;d;h++)a.call(e,c[h])&amp;&amp;f.push(c[h]);return f}}());\n\nteal.ignoreKey = function(key,re){\n  var should_ignore_key = 0;\n  //Build a new array to avoid running through Object.keys multiple times\n  if(typeof teal.ignore_keys_list === 'undefined'){\n    teal.ignore_keys_list = Object.keys(teal.ignore_keys);\n    teal.ignore_keys_list.forEach(function(name){\n      //Store a copy of the regex in the object\n      teal.ignore_keys[name] = new RegExp(&quot;^&quot;+name);\n      if(key.match(teal.ignore_keys[name])){\n        should_ignore_key = 1;\n      }\n    });\n  }else{\n    //Loop through the ignore_keys object to see if we should ignore this key\n    teal.ignore_keys_list.forEach(function(name){\n      if(key.match(teal.ignore_keys[name])){\n        should_ignore_key = 1;\n      }\n    });\n  }\n  return should_ignore_key;\n}\n\nteal.getKeyName = function(key,re){\n  //Create a new object to store regexs or use existing one\n  teal.replace_keys_regex = teal.replace_keys_regex || {};\n  //Build a new array to avoid running through Object.keys multiple times\n  if(typeof teal.replace_keys_list === 'undefined'){\n    teal.replace_keys_list = Object.keys(teal.replace_keys);\n    //Make a start of string and end of string regex\n    teal.replace_keys_regex.startOfString = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n    teal.replace_keys_regex.endOfString = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]$&quot;);\n    teal.replace_keys_list.forEach(function(name){\n      //Store a copy of the regex in the teal.replace_keys_regex object so that the regexs are only built once\n      teal.replace_keys_regex[name] = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]?&quot; + name + &quot;[&quot; + teal.nested_delimiter + &quot;]?&quot;, &quot;g&quot;);\n      key = teal.keyReplace(key,name,teal.replace_keys_regex[name]);\n    });\n  }else{\n    //Loop through the replace_keys object to see what we should be replacing\n    teal.replace_keys_list.forEach(function(name){\n      key = teal.keyReplace(key,name,teal.replace_keys_regex[name]);\n    });\n  }\n  return key;\n}\n\nteal.keyReplace = function(key,name,re){\n  //Check to see if we are replacing the key name with a new value or if we are removing the key altogether\n  if(teal.replace_keys[name] === ''){\n    //The key needs to be removed completely\n    key = key.replace(re,teal.nested_delimiter);\n    //Check to see if the key starts with the nested delimiter and if so, remove it\n    if(key.indexOf(teal.nested_delimiter) === 0){\n      var cleanRegEx = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n  }else{\n    //Make a copy of the original key to see how we need to update the key name\n    var origKey = key;\n    //Replace the key name\n    key = key.replace(re,teal.nested_delimiter + teal.replace_keys[name] + teal.nested_delimiter);\n    //Check for the start of the origKey to see of the nested delimiter is there\n    if(!origKey.match(teal.replace_keys_regex.startOfString)){\n      //Remove the nested delimiter from the start of the string\n      var cleanRegEx = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n    //Check for the end of the origKey to see of the nested delimiter is there\n    if(!origKey.match(teal.replace_keys_regex.endOfString)){\n      //Add the nested delimiter to the end of the string\n      var cleanRegEx = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]$&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n  }\n  return key;\n}\n\nteal.processDataObject = function(obj,new_obj,parent_key,create_array){\n  if(typeof parent_key === &quot;undefined&quot;){\n    //This object isn't nested in another object\n    parent_key = &quot;&quot;;\n  }else{\n    //Add the nested_delimiter to the parent key if the delimiter isn't already at the end\n    teal.nested_delimiter_regex = teal.nested_delimiter_regex || new RegExp(&quot;[&quot;+teal.nested_delimiter+&quot;]$&quot;);\n    if(!parent_key.match(teal.nested_delimiter_regex)){\n      parent_key += &quot;&quot;+teal.nested_delimiter;\n    }\n  }\n  Object.keys(obj).forEach(function(key){\n    var nested_key_name = parent_key+key;\n    //Format the new key name and take out any whitespace\n    var new_key_name = teal.getKeyName((teal.prefix+parent_key+key).replace(/\\s/g, ''));\n    //Set the key_type to limit the number of typeof checks\n    var key_type = teal.typeOf(obj[key]);\n    if(key_type !== 'undefined' &amp;&amp; key_type != null){\n      if(key_type.match(/boolean|string|number|date/) &amp;&amp; !teal.ignoreKey(key)){\n        //If obj[key] is a date, convert to ISOString\n        if(teal.typeOf(obj[key]) === 'date'){\n          obj[key] = obj[key].toISOString();\n        }\n        //Check to see if we need to create an array for this data point\n        if(create_array){\n          //First check to see if this key exists\n          if(teal.typeOf(new_obj[new_key_name]) !== &quot;array&quot;){\n            //Make the key an array\n            new_obj[new_key_name] = [];\n          }\n          new_obj[new_key_name].push(&quot;&quot;+obj[key]); //Force value to be a string\n        }else{\n          //If the value of the key is a boolean or a string or a number and\n          //the key shouldn't be ignored add to the data layer\n          new_obj[new_key_name] = &quot;&quot;+obj[key]; //Force value to be a string\n        }\n      }else if(key_type === 'object' &amp;&amp; !teal.ignoreKey(key)){\n        //Process this piece of the data layer and merge it\n        teal.processDataObject(obj[key],new_obj,nested_key_name,create_array);\n      }else if(key_type === 'array'){\n        teal.processDataArray(obj[key],new_obj,nested_key_name);\n      }\n    }\n  });\n}\n\nteal.processDataArray = function(obj,new_obj,parent_key){\n  var objLength = obj.length;\n  if(typeof parent_key === &quot;undefined&quot;){\n    //This object isn't nested in another object\n    parent_key = &quot;&quot;;\n  }else if(objLength &gt; 0 &amp;&amp; teal.typeOf(obj[0]).match(/boolean|string|number|date/)){\n    //This is a normal array that doesn't need a nested delimiter\n  }else{\n    //Add the nested_delimiter to the parent key\n    parent_key += &quot;&quot;+teal.nested_delimiter;\n  }\n  //Format the new key name and take out any whitespace\n  var new_key_name = teal.getKeyName((teal.prefix+parent_key).replace(/\\s/g, ''));\n  for(var n = 0; n &lt; objLength; n++){\n    var key_type = teal.typeOf(obj[n]);\n    if(key_type.match(/boolean|string|number|date/)){\n      //If obj[n] is a date, convert to ISOString\n      if(key_type === 'date'){\n        obj[n] = obj[n].toISOString();\n      }\n      //First check to see if this key exists\n      if(teal.typeOf(new_obj[new_key_name]) !== &quot;array&quot;){\n        //Make the key an array\n        new_obj[new_key_name] = [];\n      }\n      //If the value of the key is a boolean or a string or a number and\n      //the key shouldn't be ignored add to the data layer\n      new_obj[new_key_name].push(&quot;&quot;+obj[n]);\n    }else if(key_type === 'object'){\n      teal.processDataObject(obj[n],new_obj,new_key_name,1);\n    }\n  }\n}\n\nteal.typeOf = function(e){return ({}).toString.call(e).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();}\n\nteal.flattenObject = function(obj,new_obj){\n  //Make sure object exists\n  if(typeof obj === 'undefined'){\n    return false;\n  }\n  //Check to see if we want to flatten the same object and keep the reference\n  var mergeObject = false;\n  if(obj === new_obj){\n    mergeObject = true;\n    //Start off a clean copy of the object\n    new_obj = {};\n  }\n  //Make sure new object exists\n  if(typeof new_obj === 'undefined'){\n    new_obj = {};\n  }\n  //Check to see if this object is an array\n  if(teal.typeOf(obj) === 'array'){\n    //Store a safe copy of this object in case we are processing the b object\n    var temp_array = JSON.parse(JSON.stringify(obj));\n    var temp_array_length = temp_array.length;\n    //Clean up the object\n    obj = {};\n    //Let's see if the obj and new_obj are the same.  If so, going to assume we are using the b object\n    if(obj == new_obj){\n      //Let's ensure that we have the a object\n      if(typeof a === 'undefined'){\n        var a = 'view';\n      }\n      //Add the automatic utag data points\n      utag.loader.RD(new_obj,a);\n    }\n    for(var i = 0; i &lt; temp_array_length; i++){\n        teal.processDataObject(temp_array[i],new_obj);\n    }\n  }else{\n    teal.processDataObject(obj,new_obj);\n  }\n  if(mergeObject){\n    //Need to delete everything out of obj and replace with new_obj\n    Object.keys(obj).forEach(function(key){\n      delete obj[key];\n    });\n    //Now that we have a clean original object, add everything from new_obj which allows the reference to be kept\n    Object.keys(new_obj).forEach(function(key){\n      obj[key] = new_obj[key];\n    });\n  }\n\n  return new_obj;\n}","name":"prod"},"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"promotedTimestamp":"202009300932","promotedDraftName":"Draft 1","promotedBy":"caleb.jaquith@tealium.com","code":"//Define the teal global namespace\nwindow.teal = window.teal || {};\nteal.ignore_keys = {};\nteal.replace_keys = {};\nteal.prefix = &quot;&quot;;\n\n//In cases of a nested object, what should join the parent key and child key\nteal.nested_delimiter = &quot;.&quot;;\n\n//Ignore keys in the data layer that start with the following text.\n//Expecting an object of strings\n/*\nteal.ignore_keys = {\n  &quot;user&quot; : 1,\n  &quot;util&quot; : 1\n};\n*/\n\n//Specify a prefix for data layer elements being sent to the utag_data object.\n//Instead of utag_data.productID, it could be utag_data.dl_productID\n// teal.prefix = &quot;dl_&quot;;\n\n//Keys to be removed from the new flattened key name\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.page.pi.pageName\n/* teal.replace_keys = {\n    &quot;pageInfo&quot;:&quot;pi&quot;\n  };\n*/\n\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.page.pageName\n/* teal.replace_keys = {\n    &quot;pageInfo&quot;:&quot;&quot;\n  };\n*/\n\n//For a flattened key, you have digitalData.page.pageInfo.pageName and you want digitalData.pageName\n/* teal.replace_keys = {\n    &quot;page&quot;:&quot;&quot;,\n    &quot;pageInfo&quot;:&quot;&quot;\n  };\n*/\n\n/*****************DO NOT MODIFY BELOW***********************/\n\nteal.flattener_version = 1.4;\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\n// Add the Object.keys method for older versions of IE\nObject.keys||(Object.keys=function(){&quot;use strict&quot;;var a=Object.prototype.hasOwnProperty,b=!{toString:null}.propertyIsEnumerable(&quot;toString&quot;),c=[&quot;toString&quot;,&quot;toLocaleString&quot;,&quot;valueOf&quot;,&quot;hasOwnProperty&quot;,&quot;isPrototypeOf&quot;,&quot;propertyIsEnumerable&quot;,&quot;constructor&quot;],d=c.length;return function(e){if(&quot;object&quot;!=typeof e&amp;&amp;(&quot;function&quot;!=typeof e||null===e))throw new TypeError(&quot;Object.keys called on non-object&quot;);var g,h,f=[];for(g in e)a.call(e,g)&amp;&amp;f.push(g);if(b)for(h=0;h&lt;d;h++)a.call(e,c[h])&amp;&amp;f.push(c[h]);return f}}());\n\nteal.ignoreKey = function(key,re){\n  var should_ignore_key = 0;\n  //Build a new array to avoid running through Object.keys multiple times\n  if(typeof teal.ignore_keys_list === 'undefined'){\n    teal.ignore_keys_list = Object.keys(teal.ignore_keys);\n    teal.ignore_keys_list.forEach(function(name){\n      //Store a copy of the regex in the object\n      teal.ignore_keys[name] = new RegExp(&quot;^&quot;+name);\n      if(key.match(teal.ignore_keys[name])){\n        should_ignore_key = 1;\n      }\n    });\n  }else{\n    //Loop through the ignore_keys object to see if we should ignore this key\n    teal.ignore_keys_list.forEach(function(name){\n      if(key.match(teal.ignore_keys[name])){\n        should_ignore_key = 1;\n      }\n    });\n  }\n  return should_ignore_key;\n}\n\nteal.getKeyName = function(key,re){\n  //Create a new object to store regexs or use existing one\n  teal.replace_keys_regex = teal.replace_keys_regex || {};\n  //Build a new array to avoid running through Object.keys multiple times\n  if(typeof teal.replace_keys_list === 'undefined'){\n    teal.replace_keys_list = Object.keys(teal.replace_keys);\n    //Make a start of string and end of string regex\n    teal.replace_keys_regex.startOfString = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n    teal.replace_keys_regex.endOfString = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]$&quot;);\n    teal.replace_keys_list.forEach(function(name){\n      //Store a copy of the regex in the teal.replace_keys_regex object so that the regexs are only built once\n      teal.replace_keys_regex[name] = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]?&quot; + name + &quot;[&quot; + teal.nested_delimiter + &quot;]?&quot;, &quot;g&quot;);\n      key = teal.keyReplace(key,name,teal.replace_keys_regex[name]);\n    });\n  }else{\n    //Loop through the replace_keys object to see what we should be replacing\n    teal.replace_keys_list.forEach(function(name){\n      key = teal.keyReplace(key,name,teal.replace_keys_regex[name]);\n    });\n  }\n  return key;\n}\n\nteal.keyReplace = function(key,name,re){\n  //Check to see if we are replacing the key name with a new value or if we are removing the key altogether\n  if(teal.replace_keys[name] === ''){\n    //The key needs to be removed completely\n    key = key.replace(re,teal.nested_delimiter);\n    //Check to see if the key starts with the nested delimiter and if so, remove it\n    if(key.indexOf(teal.nested_delimiter) === 0){\n      var cleanRegEx = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n  }else{\n    //Make a copy of the original key to see how we need to update the key name\n    var origKey = key;\n    //Replace the key name\n    key = key.replace(re,teal.nested_delimiter + teal.replace_keys[name] + teal.nested_delimiter);\n    //Check for the start of the origKey to see of the nested delimiter is there\n    if(!origKey.match(teal.replace_keys_regex.startOfString)){\n      //Remove the nested delimiter from the start of the string\n      var cleanRegEx = new RegExp(&quot;^[&quot; + teal.nested_delimiter + &quot;]&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n    //Check for the end of the origKey to see of the nested delimiter is there\n    if(!origKey.match(teal.replace_keys_regex.endOfString)){\n      //Add the nested delimiter to the end of the string\n      var cleanRegEx = new RegExp(&quot;[&quot; + teal.nested_delimiter + &quot;]$&quot;);\n      key = key.replace(cleanRegEx,'');\n    }\n  }\n  return key;\n}\n\nteal.processDataObject = function(obj,new_obj,parent_key,create_array){\n  if(typeof parent_key === &quot;undefined&quot;){\n    //This object isn't nested in another object\n    parent_key = &quot;&quot;;\n  }else{\n    //Add the nested_delimiter to the parent key if the delimiter isn't already at the end\n    teal.nested_delimiter_regex = teal.nested_delimiter_regex || new RegExp(&quot;[&quot;+teal.nested_delimiter+&quot;]$&quot;);\n    if(!parent_key.match(teal.nested_delimiter_regex)){\n      parent_key += &quot;&quot;+teal.nested_delimiter;\n    }\n  }\n  Object.keys(obj).forEach(function(key){\n    var nested_key_name = parent_key+key;\n    //Format the new key name and take out any whitespace\n    var new_key_name = teal.getKeyName((teal.prefix+parent_key+key).replace(/\\s/g, ''));\n    //Set the key_type to limit the number of typeof checks\n    var key_type = teal.typeOf(obj[key]);\n    if(key_type !== 'undefined' &amp;&amp; key_type != null){\n      if(key_type.match(/boolean|string|number|date/) &amp;&amp; !teal.ignoreKey(key)){\n        //If obj[key] is a date, convert to ISOString\n        if(teal.typeOf(obj[key]) === 'date'){\n          obj[key] = obj[key].toISOString();\n        }\n        //Check to see if we need to create an array for this data point\n        if(create_array){\n          //First check to see if this key exists\n          if(teal.typeOf(new_obj[new_key_name]) !== &quot;array&quot;){\n            //Make the key an array\n            new_obj[new_key_name] = [];\n          }\n          new_obj[new_key_name].push(&quot;&quot;+obj[key]); //Force value to be a string\n        }else{\n          //If the value of the key is a boolean or a string or a number and\n          //the key shouldn't be ignored add to the data layer\n          new_obj[new_key_name] = &quot;&quot;+obj[key]; //Force value to be a string\n        }\n      }else if(key_type === 'object' &amp;&amp; !teal.ignoreKey(key)){\n        //Process this piece of the data layer and merge it\n        teal.processDataObject(obj[key],new_obj,nested_key_name,create_array);\n      }else if(key_type === 'array'){\n        teal.processDataArray(obj[key],new_obj,nested_key_name);\n      }\n    }\n  });\n}\n\nteal.processDataArray = function(obj,new_obj,parent_key){\n  var objLength = obj.length;\n  if(typeof parent_key === &quot;undefined&quot;){\n    //This object isn't nested in another object\n    parent_key = &quot;&quot;;\n  }else if(objLength &gt; 0 &amp;&amp; teal.typeOf(obj[0]).match(/boolean|string|number|date/)){\n    //This is a normal array that doesn't need a nested delimiter\n  }else{\n    //Add the nested_delimiter to the parent key\n    parent_key += &quot;&quot;+teal.nested_delimiter;\n  }\n  //Format the new key name and take out any whitespace\n  var new_key_name = teal.getKeyName((teal.prefix+parent_key).replace(/\\s/g, ''));\n  for(var n = 0; n &lt; objLength; n++){\n    var key_type = teal.typeOf(obj[n]);\n    if(key_type.match(/boolean|string|number|date/)){\n      //If obj[n] is a date, convert to ISOString\n      if(key_type === 'date'){\n        obj[n] = obj[n].toISOString();\n      }\n      //First check to see if this key exists\n      if(teal.typeOf(new_obj[new_key_name]) !== &quot;array&quot;){\n        //Make the key an array\n        new_obj[new_key_name] = [];\n      }\n      //If the value of the key is a boolean or a string or a number and\n      //the key shouldn't be ignored add to the data layer\n      new_obj[new_key_name].push(&quot;&quot;+obj[n]);\n    }else if(key_type === 'object'){\n      teal.processDataObject(obj[n],new_obj,new_key_name,1);\n    }\n  }\n}\n\nteal.typeOf = function(e){return ({}).toString.call(e).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();}\n\nteal.flattenObject = function(obj,new_obj){\n  //Make sure object exists\n  if(typeof obj === 'undefined'){\n    return false;\n  }\n  //Check to see if we want to flatten the same object and keep the reference\n  var mergeObject = false;\n  if(obj === new_obj){\n    mergeObject = true;\n    //Start off a clean copy of the object\n    new_obj = {};\n  }\n  //Make sure new object exists\n  if(typeof new_obj === 'undefined'){\n    new_obj = {};\n  }\n  //Check to see if this object is an array\n  if(teal.typeOf(obj) === 'array'){\n    //Store a safe copy of this object in case we are processing the b object\n    var temp_array = JSON.parse(JSON.stringify(obj));\n    var temp_array_length = temp_array.length;\n    //Clean up the object\n    obj = {};\n    //Let's see if the obj and new_obj are the same.  If so, going to assume we are using the b object\n    if(obj == new_obj){\n      //Let's ensure that we have the a object\n      if(typeof a === 'undefined'){\n        var a = 'view';\n      }\n      //Add the automatic utag data points\n      utag.loader.RD(new_obj,a);\n    }\n    for(var i = 0; i &lt; temp_array_length; i++){\n        teal.processDataObject(temp_array[i],new_obj);\n    }\n  }else{\n    teal.processDataObject(obj,new_obj);\n  }\n  if(mergeObject){\n    //Need to delete everything out of obj and replace with new_obj\n    Object.keys(obj).forEach(function(key){\n      delete obj[key];\n    });\n    //Now that we have a clean original object, add everything from new_obj which allows the reference to be kept\n    Object.keys(new_obj).forEach(function(key){\n      obj[key] = new_obj[key];\n    });\n  }\n\n  return new_obj;\n}","name":"qa"}},"draftSeq":"1"},"initialize":"","labels":"","id":"100040","title":"DataLayer Listener 3 - Add flattener library","_id":"18","extType":"Javascript Code","selectedTargets":{"prod":"true","dev":"true","qa":"true"},"notes":"","sort":"2","publishedTargets":"dev","blockPubTargetsLogic":"true","type":"new"},"19":{"id":"100040","title":"DataLayer Listener 4 - Attach listener function","codeDevData":{"draftSeq":"1","promotedSnippets":{"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"promotedDraftName":"Draft 1","promotedTimestamp":"202010021035","promotedBy":"caleb.jaquith@tealium.com","code":"/**\n * Scope       : DOM Ready (run once)\n * Execution   : n/a\n * Condition   : n/a\n * Description : GTM Listener - Attach listener function using the DataLayer Helper\n */\n \n// define listener function, will be called for each element in the dataLayer array\nvar processEvent = function(model, message) {\n    // exit if the flattener function isn't present on the page\n    if (!teal || typeof teal.flattenObject !== &quot;function&quot;) {\n        return;\n    }\n\n    /**\n     * Process the model, once per page on (or after) DOM Load\n     */\n    var flat = {};\n    \n    // utag.view on gtm.load to ensure GTM and iQ timing matches, assumes non-SPA\n    // processes the 'model', built by the helper based on all past events on the page\n    if (message.event === &quot;virtual_view&quot; || message.event === &quot;pageview&quot;) {\n        //console.log(teal.flattenObject(message, message));\n        flat = teal.flattenObject(model, model);\n        flat.tealium_event = flat.page_type || flat.pageType || &quot;other-view&quot;;\n        utag.DB(&quot;View / &quot; + flat.tealium_event, flat);\n        utag.view(flat);\n    } else if (typeof message.event === &quot;string&quot; &amp;&amp; message.event !== &quot;consents_initialized&quot; &amp;&amp; message.event.indexOf('consent_changed') === -1) {\n        //flat = teal.flattenObject(message, message);        \n        \n        flat = teal.flattenObject(message, message);\n        flat.tealium_event = flat.event;\n        utag.DB(&quot;Link / &quot; + flat.tealium_event, flat);\n        utag.link(flat);\n    }\n};\n\n// make sure the object is actually defined\nwindow.dataLayer = window.dataLayer || [];\n\n// attach the listener (and process any historical events on attachment)\nif (typeof processEvent === &quot;function&quot;) {\n    var helper = new DataLayerHelper(window.dataLayer, processEvent, true);\n};","name":"dev"},"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"name":"prod","code":"/**\n * Scope       : DOM Ready (run once)\n * Execution   : n/a\n * Condition   : n/a\n * Description : GTM Listener - Attach listener function using the DataLayer Helper\n */\n \n// define listener function, will be called for each element in the dataLayer array\nvar processEvent = function(model, message) {\n    // exit if the flattener function isn't present on the page\n    if (!teal || typeof teal.flattenObject !== &quot;function&quot;) {\n        return;\n    }\n\n    /**\n     * Process the model, once per page on (or after) DOM Load\n     */\n    var flat = {};\n    \n    // utag.view on gtm.load to ensure GTM and iQ timing matches, assumes non-SPA\n    // processes the 'model', built by the helper based on all past events on the page\n    if (message.event === &quot;virtual_view&quot; || message.event === &quot;pageview&quot;) {\n        //console.log(teal.flattenObject(message, message));\n        flat = teal.flattenObject(model, model);\n        flat.tealium_event = flat.page_type || flat.pageType || &quot;other-view&quot;;\n        utag.DB(&quot;View / &quot; + flat.tealium_event, flat);\n        utag.view(flat);\n    } else if (typeof message.event === &quot;string&quot; &amp;&amp; message.event !== &quot;consents_initialized&quot; &amp;&amp; message.event.indexOf('consent_changed') === -1) {\n        //flat = teal.flattenObject(message, message);        \n        \n        flat = teal.flattenObject(message, message);\n        flat.tealium_event = flat.event;\n        utag.DB(&quot;Link / &quot; + flat.tealium_event, flat);\n        utag.link(flat);\n    }\n};\n\n// make sure the object is actually defined\nwindow.dataLayer = window.dataLayer || [];\n\n// attach the listener (and process any historical events on attachment)\nif (typeof processEvent === &quot;function&quot;) {\n    var helper = new DataLayerHelper(window.dataLayer, processEvent, true);\n};","promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202010021035","promotedDraftName":"Draft 1"},"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"code":"/**\n * Scope       : DOM Ready (run once)\n * Execution   : n/a\n * Condition   : n/a\n * Description : GTM Listener - Attach listener function using the DataLayer Helper\n */\n \n// define listener function, will be called for each element in the dataLayer array\nvar processEvent = function(model, message) {\n    // exit if the flattener function isn't present on the page\n    if (!teal || typeof teal.flattenObject !== &quot;function&quot;) {\n        return;\n    }\n\n    /**\n     * Process the model, once per page on (or after) DOM Load\n     */\n    var flat = {};\n    \n    // utag.view on gtm.load to ensure GTM and iQ timing matches, assumes non-SPA\n    // processes the 'model', built by the helper based on all past events on the page\n    if (message.event === &quot;virtual_view&quot; || message.event === &quot;pageview&quot;) {\n        //console.log(teal.flattenObject(message, message));\n        flat = teal.flattenObject(model, model);\n        flat.tealium_event = flat.page_type || flat.pageType || &quot;other-view&quot;;\n        utag.DB(&quot;View / &quot; + flat.tealium_event, flat);\n        utag.view(flat);\n    } else if (typeof message.event === &quot;string&quot; &amp;&amp; message.event !== &quot;consents_initialized&quot; &amp;&amp; message.event.indexOf('consent_changed') === -1) {\n        //flat = teal.flattenObject(message, message);        \n        \n        flat = teal.flattenObject(message, message);\n        flat.tealium_event = flat.event;\n        utag.DB(&quot;Link / &quot; + flat.tealium_event, flat);\n        utag.link(flat);\n    }\n};\n\n// make sure the object is actually defined\nwindow.dataLayer = window.dataLayer || [];\n\n// attach the listener (and process any historical events on attachment)\nif (typeof processEvent === &quot;function&quot;) {\n    var helper = new DataLayerHelper(window.dataLayer, processEvent, true);\n};","name":"qa","promotedTimestamp":"202010021035","promotedDraftName":"Draft 1","promotedBy":"caleb.jaquith@tealium.com"}},"draftSnippets":{"156e808776455eb7fb3231a67b22d1d38ab0ed941db5b8d157735eea6c9da88b":{"code":"/**\n * Scope       : DOM Ready (run once)\n * Execution   : n/a\n * Condition   : n/a\n * Description : GTM Listener - Attach listener function using the DataLayer Helper\n */\n \n// define listener function, will be called for each element in the dataLayer array\nvar processEvent = function(model, message) {\n    // exit if the flattener function isn't present on the page\n    if (!teal || typeof teal.flattenObject !== &quot;function&quot;) {\n        return;\n    }\n\n    /**\n     * Process the model, once per page on (or after) DOM Load\n     */\n    var flat = {};\n    \n    // utag.view on gtm.load to ensure GTM and iQ timing matches, assumes non-SPA\n    // processes the 'model', built by the helper based on all past events on the page\n    if (message.event === &quot;virtual_view&quot; || message.event === &quot;pageview&quot;) {\n        //console.log(teal.flattenObject(message, message));\n        flat = teal.flattenObject(model, model);\n        flat.tealium_event = flat.page_type || flat.pageType || &quot;other-view&quot;;\n        utag.DB(&quot;View / &quot; + flat.tealium_event, flat);\n        utag.view(flat);\n    } else if (typeof message.event === &quot;string&quot; &amp;&amp; message.event !== &quot;consents_initialized&quot; &amp;&amp; message.event.indexOf('consent_changed') === -1) {\n        //flat = teal.flattenObject(message, message);        \n        \n        flat = teal.flattenObject(message, message);\n        flat.tealium_event = flat.event;\n        utag.DB(&quot;Link / &quot; + flat.tealium_event, flat);\n        utag.link(flat);\n    }\n};\n\n// make sure the object is actually defined\nwindow.dataLayer = window.dataLayer || [];\n\n// attach the listener (and process any historical events on attachment)\nif (typeof processEvent === &quot;function&quot;) {\n    var helper = new DataLayerHelper(window.dataLayer, processEvent, true);\n};","name":"Draft 1","creationDate":"202009300930","updateDate":"202010021035","updatedBy":"caleb.jaquith@tealium.com"}},"queueSeq":"5"},"initialize":"","labels":"","advExecOption":"alr","scope":"domready","constructor":"","status":"active","type":"new","publishedTargets":"dev","blockPubTargetsLogic":"true","selectedTargets":{"qa":"true","dev":"true","prod":"true"},"sort":"3","notes":"","extType":"Javascript Code","_id":"19"},"20":{"blockPubTargetsLogic":"true","publishedTargets":"dev","type":"new","extType":"Javascript Code","_id":"20","sort":"11","notes":"","selectedTargets":{"dev":"true","prod":"true","qa":"true"},"title":"Add dataLayer pageview pushes","id":"100040","scope":"domready","constructor":"","status":"active","advExecOption":"alr","labels":"","codeDevData":{"draftSeq":"1","promotedSnippets":{"6754af9632a2745e85c293e5aac0863370d9bd3330b9938c00cadfd215227d77":{"promotedDraftName":"Draft 1","promotedTimestamp":"202010051139","promotedBy":"caleb.jaquith@tealium.com","code":"// set page load event and trigger tealium\nwindow.dataLayer = window.dataLayer || []\ndataLayer.push({'event' : 'pageview'})\n\n/*\n// trigger event after 3 seconds\nsetTimeout(function() {\n    dataLayer.push({'event' : '3sekunden'})\n}, 3000);\n*/\n\nwindow.addEventListener('hashchange', function () {\n    dataLayer.push({'event' : 'virtual_view'})\n});","name":"prod"},"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"promotedTimestamp":"202010051139","promotedDraftName":"Draft 1","promotedBy":"caleb.jaquith@tealium.com","code":"// set page load event and trigger tealium\nwindow.dataLayer = window.dataLayer || []\ndataLayer.push({'event' : 'pageview'})\n\n/*\n// trigger event after 3 seconds\nsetTimeout(function() {\n    dataLayer.push({'event' : '3sekunden'})\n}, 3000);\n*/\n\nwindow.addEventListener('hashchange', function () {\n    dataLayer.push({'event' : 'virtual_view'})\n});","name":"qa"},"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"code":"// set page load event and trigger tealium\nwindow.dataLayer = window.dataLayer || []\ndataLayer.push({'event' : 'pageview'})\n\n/*\n// trigger event after 3 seconds\nsetTimeout(function() {\n    dataLayer.push({'event' : '3sekunden'})\n}, 3000);\n*/\n\nwindow.addEventListener('hashchange', function () {\n    dataLayer.push({'event' : 'virtual_view'})\n});","name":"dev","promotedDraftName":"Draft 1","promotedTimestamp":"202010051139","promotedBy":"caleb.jaquith@tealium.com"}},"draftSnippets":{"156e808776455eb7fb3231a67b22d1d38ab0ed941db5b8d157735eea6c9da88b":{"updatedBy":"caleb.jaquith@tealium.com","updateDate":"202010051139","creationDate":"202010011208","name":"Draft 1","code":"// set page load event and trigger tealium\nwindow.dataLayer = window.dataLayer || []\ndataLayer.push({'event' : 'pageview'})\n\n/*\n// trigger event after 3 seconds\nsetTimeout(function() {\n    dataLayer.push({'event' : '3sekunden'})\n}, 3000);\n*/\n\nwindow.addEventListener('hashchange', function () {\n    dataLayer.push({'event' : 'virtual_view'})\n});"}},"queueSeq":"3"},"initialize":""},"21":{"advExecOption":"alr","status":"active","constructor":"","scope":"preload","codeDevData":{"promotedSnippets":{"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"name":"qa","code":"/**\n *  Scope       : Pre Loader\n *  Condition   : n/a\n *  Description : CMP 1/2 - Preloader component - prevent TiQ from loading if no consent, queue implicitly consented events to retrigger (for new tags only) if explicit decision is made.\n */\n\n/**\n  * @module extension-1\n  *\n  * @description The 'Pre Loader' extension component of the CMP integration, responsible for stopping Tealium iQ from loading/running as appropriate, and making certain\n  * window-scoped functions available to the other components.\n  */\n\n// Tealium iQ runs Pre Loader extensions in global scope, which would make all variables global. We don't want to do that.\n(function avoidGlobalScopeUnlessExplicit () {\n  // set names for key objects and variables to make them easy to change if needed\n\n  var version = 'v0.10-beta'\n\n  // for the consent information in the b object\n  var nameOfVendorOptInArray = 'usercentrics_services_with_consent'\n  var nameOfConsentTypeString = 'usercentrics_consent_type'\n\n  // for the name in the queue\n  var nameOfImplicitConsentArray = '_usercentrics_services_already_processed'\n\n  // name to use when calling utag.handler.trigger to indicate a consent polling call\n  var nameOfConsentPollingEvent = 'tiq_usercentrics_consent_polling'\n\n  var consentTimeoutInterval = 400 // setTimeout interval in MS - rate to poll for new (explicit) consent decision or correctly formed object\n\n  // check for the Tealium Debug cookie, see https://docs.tealium.com/platforms/javascript/debugging/\n  var tiqInDebugMode = /utagdb=true/.test(document.cookie)\n  var tealiumEnvironment = getTealiumEnvironment() || 'prod' // fall back to prod (stops logging) if something goes wrong with the function\n\n  /**\n   * A window-scoped (global) object used to expose selected functionality.\n   *\n   * @namespace tealiumCmpIntegration\n   * @type {object}\n   * @memberof! &lt;global&gt;\n   */\n  window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\n\n  /**\n   * The name of the CMP (&quot;Usercentrics Vanilla App&quot; in this case).\n   * @name cmpName\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.cmpName = 'Usercentrics Vanilla App'\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link ServiceToTagMap ServiceToTagMap}\n   * @name map\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  var map = window.tealiumCmpIntegration.map || {}\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link TagToServiceMap TagToServiceMap}\n   * @name tagBasedMap\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  generateTagBasedMap() // populates the window-level object for you as well\n\n  /**\n   * The Service Name for Tealium iQ in Usercentrics (used to decide if the TMS is allowed to run).  Uses the Usercentrics standard name if not provided.\n   * @name tiqServiceName\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   * @default 'Tealium iQ Tag Management'\n   * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.tiqServiceName = &quot;Tealium iQ Tag Management&quot;\n   */\n  var tiqServiceName = window.tealiumCmpIntegration.tiqServiceName || 'Tealium iQ Tag Management' // use the standard name here if not set\n\n  /**\n   * The current version designation.\n   * @name version\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.version = version\n\n  /**\n   * A [logger helper function]{@link module:extension-1~logger}, to help Tealium iQ users understand and troubleshoot this CMP integration without unneeded logging in production.\n   * @name logger\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.logger = logger\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentConsentDecision} that returns the current [ConsentDecision]{@link ConsentDecision}.\n   * @name getCurrentConsentDecision\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentConsentDecision = getCurrentConsentDecision\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentUsercentricsSettingsId} that returns the current Usercentrics settingsId.\n   * @name getCurrentUsercentricsSettingsId\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentUsercentricsSettingsId = getCurrentUsercentricsSettingsId\n\n  /**\n   * Records the status of the [noview]{@link https://docs.tealium.com/platforms/javascript/settings/#noview} setting on page load.\n   * @name isNoviewSet\n   * @type {boolean}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.isNoviewSet = window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noview === true\n\n  /**\n   * The name to use for the [ConsentDecision]{@link ConsentDecision} array when adding it to Tealium's b object on each event.\n   * @name nameOfVendorOptInArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfVendorOptInArray = nameOfVendorOptInArray\n\n  /**\n   * The name to use for the current [ConsentDecision]{@link ConsentDecision}'s 'type' attribute when adding it to Tealium's b object on each event.\n   * @name nameOfConsentTypeString\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfConsentTypeString = nameOfConsentTypeString\n\n  /**\n   * The name to use for the array of implicit tags (which have already been fired) in the 'data' property of {@link QueuedEvent QueuedEvent} objects.\n   * @name nameOfImplicitConsentArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfImplicitConsentArray = nameOfImplicitConsentArray\n\n  /**\n   * A [helper function]{@link module:extension-1~overrideUtagFunctions} that overrides certain utag functions to allow tags to be blocked based on CMP response.\n   *\n   * Must be called directly after the '##UTGEN##' reference by [editing]{@link https://community.tealiumiq.com/t5/iQ-Tag-Management/Managing-Tag-Templates/ta-p/21713} the 'utag loader' template, as shown in the example.\n   * @name overrideUtagFunctions\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   * @example\n// ... utag loader template ...\n\n##UTGEN##\n// override two utag functions for the Usercentrics CMP Integration, to allow tags to be blocked as needed\nwindow.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions()\n\n// ... utag loader template continues...\n\n   */\n  window.tealiumCmpIntegration.overrideUtagFunctions = overrideUtagFunctions\n\n  /**\n   * A queue for any events that Tealium iQ processes with IMPLICIT consent (to allow those events to be re-processed for new Services in the event of an EXPLICIT consent choice by the user).\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name implicitEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n\n  /**\n   * A queue for any events that are triggered before Tealium iQ AND Usercentrics have both loaded.\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name earlyEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n\n  /**\n   * Allows us to make sure we don't log certain messages more than once, especially useful while polling to avoid overwhelming the user.\n   * @function messageNotLoggedYet\n   * @param {*} messageId a string or number to uniquely identify a message for the purposes of deduplication\n   * @returns {boolean} 'true' if the message hasn't been logged yet (and should be logged), otherwise 'false'\n   */\n  var alreadyLoggedMessageIds = {}\n  function messageNotLoggedYet (messageId) {\n    var output = false\n    if (typeof alreadyLoggedMessageIds[messageId] === 'undefined') {\n      alreadyLoggedMessageIds[messageId] = true\n      output = true\n    }\n    return output\n  }\n\n  // if noload is set to 'true', don't interfere, just return to exit this function and allow that setting to stop TiQ load as usual.\n  if (window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noload === true) return false\n\n  logger('CMP integration active - Usercentrics/TiQ' + (tiqInDebugMode ? &quot;\\n\\nDEBUGGING TIP: Use /SENDING|\\\\*\\\\*\\\\*\\\\*/ in the browser console as the 'filter' to show only CMP and tag send notifications.&quot; : '\\n\\nActivate TiQ Debug Mode for more details: https://docs.tealium.com/platforms/javascript/debugging/'), true)\n  var cmpResponse = cmpConsentCheck()\n  // core business/GDPR logic, decides if TiQ should load at all\n  reactToCmpResponse(cmpResponse)\n\n  /**\n   * The core CMP integration logic, which decides if Tealium iQ should be allowed to run, or if it needs to be stopped\n   * until an understandable response that includes permission for Tealium iQ to run is found.\n   *\n   * @function reactToCmpResponse\n   * @param {object} cmpResponse The response from the Usercentrics Vanilla App\n   */\n  function reactToCmpResponse (cmpResponse) {\n    var usercentricsFound = typeof cmpResponse === 'object'\n    var foundWellFormedConsentDecision = checkForWellFormedDecision(cmpResponse)\n    var tagBasedMap = generateTagBasedMap()\n    var foundMapEntryForActiveSetting = Object.keys(tagBasedMap).length &gt; 0\n    var foundExplicitConsent = checkForExplicitConsentDecision(cmpResponse)\n    var tiqIsAllowedToFire = checkForTiqConsent(cmpResponse)\n    var tiqIsLoaded = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!usercentricsFound) {\n      /**\n       * CASE A1: no Usercentrics CMS found\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(1)) logger('No Usercentrics CMP found on page.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundMapEntryForActiveSetting) {\n      /**\n        * CASE A7: No map found for the current settingsId\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(2)) logger('No map found for current Usercentrics Setting ID.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    } else if (!foundWellFormedConsentDecision) {\n      /**\n       * CASE A2: Usercentrics CMS found but consent response wasn't well-formed/complete/understandable\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(3)) logger('Found Usercentrics CMP and got response, but didn\\'t understand the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!tiqIsAllowedToFire) {\n      /**\n       * CASE A3: Usercentrics CMS found and consent response was well-formed, BUT TiQ didn't have an opt-in\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(4)) logger('Found Usercentrics CMP and got well-formed response, but TiQ isn\\'t allowed to run based on the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundExplicitConsent) {\n      /**\n       * CASE A4: Usercentrics CMS found AND response was understandable (AND includes an implicit TiQ consent), BUT the user hasn't made an explicit decision yet\n       *\n       * ALLOW TO LOAD for any 'default opt-in' tags (filter logic in Extension B)\n       * RETRY after a delay (in case there's an explicit decision, since implicit decisions usually mean the prompt is displayed)\n       */\n      if (messageNotLoggedYet(5)) logger('Found Usercentrics CMP and got well-formed IMPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on IMPLICIT consent.\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else if (foundExplicitConsent) {\n      /**\n       * CASE A5: Usercentrics CMS found AND response was understandable, AND the user has made an explicit consent decision AND TiQ is allowed\n       *\n       * ALLOW TO LOAD for any opted-in tags (filter logic in Extension B), do not retry.\n       */\n      if (messageNotLoggedYet(6)) logger('Found Usercentrics CMP and got well-formed EXPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on EXPLICIT consent.\\n\\nNo further polling.')\n      // only call if we've been polling (on initial load, it will load automatically)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n        processImplicitQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else {\n      /**\n        * CASE A6: Something went wrong with this extension.\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(7)) logger('Something unexpected went wrong.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    }\n  }\n\n  /**\n   * Override utag.loader.initdata and utag.handler.trigger to allow Tealium iQ Tags to be blocked if the user hasn't consented.\n   *\n   * @function overrideUtagFunctions\n   * @returns {boolean} 'true' if the function was overridden successfully by this request, 'false' if not (because it was already overridden)\n   */\n  function overrideUtagFunctions () {\n    // don't override more than once, assume that if one function has been overridden, both have\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    // the initial view is handled differently than subsequent events\n    // this is safe to to override even if noview is set (because it will never be called in that case)\n    window.utag.loader.initdata_old = window.utag.loader.initdata\n    window.utag.loader.initdata = newUtagLoaderInitdata\n\n    window.utag.handler.trigger_old = window.utag.handler.trigger\n    window.utag.handler.trigger = newUtagHandlerTrigger\n    logger('Overrode utag functions!')\n\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * An overridden version of the Tealium iQ function utag.loader.initdata.\n   *\n   * Calls the original function, respects possible noview settings, rechecks the user consent, and calls queueEventWithoutFiringImplicitServices\n   * if only an IMPLICIT consent is found (after recording the IMPLICIT services, to avoid double-firing).\n   *\n   * That same event can then be re-processed for any new Services if an EXPLICIT consent decision later made.\n   *\n   * @function newUtagLoaderInitdata\n   */\n  function newUtagLoaderInitdata () {\n    window.utag.loader.initdata_old()\n    // make sure we don't queue this initial page load twice, and respect the configured noview setting\n    if (!window.tealiumCmpIntegration.isNoviewSet &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n      window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n      var consentedServices = getCurrentConsentDecision()\n      if (consentedServices.type === 'implicit') {\n        window.tealiumCmpIntegration.implicitServices = consentedServices\n        // we don't need to fire implicit services in this case, because TiQ's loading process will fire them\n        queueEventWithoutFiringImplicitServices({\n          event: 'view',\n          data: window.utag.handler.C(window.utag.data)\n        })\n      }\n    }\n  }\n\n  /**\n   * Refresh [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration.tagBasedMap} and return that new map, helps smooth out any timing issues between Usercentrics and Tealium iQ load.\n   *\n   * @function generateTagBasedMap\n   * @returns a [TagToServiceMap]{@link TagToServiceMap}\n   */\n  function generateTagBasedMap () {\n    var tagBasedMap = getTagBasedMap(map)\n    window.tealiumCmpIntegration.tagBasedMap = tagBasedMap\n    return tagBasedMap\n  }\n\n  /**\n   * Tealium iQ's utag.handler.trigger normally causes tags to fire. For this integration, we override that function to support blocking tags without consent.\n   *\n   * @function newUtagHandlerTrigger\n   *\n   * @param {*} a can be an object or a string\n   * @param {*} b\n   * @param {*} c\n   */\n  function newUtagHandlerTrigger (a, b, c) {\n    /**\n     * Trigger CASES (utag.handler.trigger override)\n     *\n     * We need to queue the events if we only have implicit consent, to allow a selective retrigger if/when we get an explicit decision.\n     */\n    var isPureConsentEvent = (a === nameOfConsentPollingEvent &amp;&amp; !b &amp;&amp; !c)\n    var isNoviewSet = window.tealiumCmpIntegration.isNoviewSet || true // assume noview if something went wrong with the global, to avoid firing tracking in error\n\n    var consentedServices = getCurrentConsentDecision()\n    var consentType = (consentedServices &amp;&amp; consentedServices.type) || 'none'\n\n    var isUsercentricsReady = consentType === 'implicit' || consentType === 'explicit'\n    var isTealiumReady = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!isPureConsentEvent) {\n      logger('utag.handler.trigger called with:\\n\\n' + JSON.stringify(arguments, null, 2))\n    }\n\n    if (!isUsercentricsReady &amp;&amp; !isTealiumReady) {\n      consentedServices.type = 'tealium-and-usercentrics-loading'\n      logger('Waiting for Usercentrics and Tealium to be ready, queueing early event.')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isUsercentricsReady) {\n      consentedServices.type = 'usercentrics-loading'\n      logger('Usercentrics is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isTealiumReady) {\n      consentedServices.type = 'tealium-still-loading'\n      logger('Tealium iQ is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    }\n\n    // if an array of tagUids is passed, that forces them to fire regardless of load rules\n    // or consent, so we need to filter that array before allowing it to be processed\n    var hasTagUidArray = c &amp;&amp; typeof c === 'object' &amp;&amp; c.uids &amp;&amp; c.uids &amp;&amp; window.utag.ut.typeOf(c.uids) === 'array'\n    var uidMap = generateTagBasedMap()\n    var allowedTagUids = []\n    var blockedTagUids = []\n    var serviceName\n    var tagUid\n    if (hasTagUidArray) {\n      for (var i = 0; i &lt; c.uids.length; i++) {\n        tagUid = c.uids[i]\n        serviceName = uidMap[tagUid] || '(missing)'\n        // only push consented services into the new array\n        if (consentedServices.indexOf(serviceName) !== -1) {\n          allowedTagUids.push(tagUid)\n        } else {\n          blockedTagUids.push(tagUid)\n        }\n      }\n      // replace the original with the filtered array (can also be empty, if none of them were allowed)\n      logger('Call included tagUid array:\\n\\n' + JSON.stringify(c.uids) + '\\n\\nwhich was replaced by the filtered version:\\n\\n' + JSON.stringify(allowedTagUids))\n      c.originalUids = c.uids.slice() // make a shallow copy\n      c.uids = allowedTagUids\n      c.blockedTagUids = blockedTagUids\n    }\n\n    if (consentType === 'explicit') {\n      /**\n       * CASE T2: expected globals are populated, consent is EXPLICIT\n       *\n       * FIRE allowed tags (explicit)\n       * utag.handler.trigger override PROCESSES the queue, which will include any queued events from CASE A4, making sure not to re-fire any default\n       *   opt-in tags that were already fired for the queued events\n       */\n      // make sure TiQ loads\n      processEarlyQueue()\n      processImplicitQueue()\n      triggerTiqLoad()\n      // fire the current event if it's not just a polling event\n      if (!isPureConsentEvent) {\n        return window.utag.handler.trigger_old(a, b, c)\n      }\n    } else if (consentType === 'implicit') {\n      /**\n       * CASE T3: expected globals are populated, consent is IMPLICIT\n       *\n       * FIRE allowed tags (implicit)\n       * utag.handler.trigger override KEEPS a queue/record that includes\n       *  - the event(s) that were processed based on implicit consent\n       *  - which tags were allowed to process each event (are set to implicit opt-in)\n       */\n      processEarlyQueue()\n      // fire the initial view if appropriate, and queue it\n      triggerTiqLoad()\n      window.tealiumCmpIntegration.implicitServices = consentedServices\n\n      // queue the initial 'view' on pageload if appropriate\n      if (!isNoviewSet &amp;&amp; isTealiumReady &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n        window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n        queueEventAndFireImplicitServices('view', window.utag.handler.C(window.utag.data))\n      }\n      // queue the current event if it exists (and this isn't just consent polling)\n      if (!isPureConsentEvent) {\n        return queueEventAndFireImplicitServices(a, b, c)\n      }\n    } else if (consentType === 'missing-map') {\n      logger('Something went wrong - all tags were blocked because no consent map was found for the active setting ID.')\n      return false\n    } else if (consentType === 'missing-tiq-consent') {\n      logger('Something went wrong - all tags were blocked because no consent was found for &quot;' + tiqServiceName + '&quot;, configured Tealium iQ name.\\n\\nConsent found: ' + JSON.stringify(consentedServices, null, 2))\n      return false\n    } else {\n      /**\n       * CASE T1: expected variables not populated (misconfiguration/error case)\n       *\n       * STOP and fire nothing at all. Do not retry or queue the event.\n       */\n      logger('Something went wrong - all tags were blocked because the consent response was not understood.')\n      return false\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the early event queue]{@link tealiumCmpIntegration.earlyEventQueue} (can include pageviews) for any currently-consented Services.\n   *\n   * Intended to be called first understandable implicit consent.\n   *\n   * @function processEarlyQueue\n   */\n  function processEarlyQueue () {\n    var queuedEvent\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    while (window.tealiumCmpIntegration.earlyEventQueue.length &gt; 0) {\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.earlyEventQueue.shift()\n      logger('Processing queued early event for currently consented tags: ' + JSON.stringify(queuedEvent, null, 2))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the global queue]{@link tealiumCmpIntegration.implicitEventQueue} (can include pageviews) for any newly-consented Services.\n   *\n   * Intended to be called on new EXPLICIT consent decision - queued events have already had IMPLICTLY consented tags fired, so those need to be excluded.\n   *\n   * @function processImplicitQueue\n   */\n  function processImplicitQueue () {\n    var alreadyLogged = false\n    var queuedEvent\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    while (window.tealiumCmpIntegration.implicitEventQueue.length &gt; 0) {\n      if (!alreadyLogged) {\n        alreadyLogged = true\n        logger('Explicit consent tracking request received - processing past implicitly tracked events (' + window.tealiumCmpIntegration.implicitEventQueue.length + ') for any new explicit tags.')\n      }\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.implicitEventQueue.shift()\n      logger('Triggering event for explicitly-consented tags: ' + JSON.stringify(queuedEvent))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the early queue]{@link tealiumCmpIntegration.earlyEventQueue}, without firing any tags.\n   *\n   * Intended to be called for events that triggered before we get an understandable response from Usercentrics.\n   *\n   * @function queueEarlyEvent\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEarlyEvent (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    // nothing will be allowed to fire\n    a.data[nameOfImplicitConsentArray] = []\n\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    window.tealiumCmpIntegration.earlyEventQueue.push(a)\n    logger('Queued early event!')\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration.implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for the initial pageview on load, since the load process will have already fired the implicit services.\n   *\n   * @function queueEventWithoutFiringImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventWithoutFiringImplicitServices (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    a.data[nameOfImplicitConsentArray] = window.tealiumCmpIntegration.implicitServices || []\n\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    window.tealiumCmpIntegration.implicitEventQueue.push(a)\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration~implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for all events other than the initial page load.\n   *\n   * @function queueEventAndFireImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventAndFireImplicitServices (a, b, c) {\n    // fire the implicit tags\n    window.utag.handler.trigger_old(a, b, c)\n    logger('Implicit consent tracking request fired (or queued, if utag hasn\\'t loaded).')\n    return queueEventWithoutFiringImplicitServices(a, b, c)\n  }\n\n  /**\n   * Generate a {@link TagToServiceMap TagToServiceMap} based on a {@link ServiceToTagMap ServiceToTagMap}\n   *\n   * @function getTagBasedMap\n   * @param {object} map a {@link ServiceToTagMap ServiceToTagMap} object\n   * @return {object} a {@link TagToServiceMap TagToServiceMap}\n   */\n  function getTagBasedMap (map) {\n    // generate a lookup based on the tagUid\n    if (typeof map !== 'object') return {}\n    var settingsId = getCurrentUsercentricsSettingsId() || ''\n    if (typeof settingsId !== 'string' || settingsId === '') return {}\n    var settingSpecificMap = map[settingsId] || {}\n    var serviceNames = Object.keys(settingSpecificMap)\n    var uidMap = {}\n    for (var i = 0; i &lt; serviceNames.length; i++) {\n      for (var j = 0; j &lt; settingSpecificMap[serviceNames[i]].length; j++) {\n        uidMap[settingSpecificMap[serviceNames[i]][j]] = serviceNames[i]\n      }\n    }\n    return uidMap\n  }\n\n  /**\n   * Get the current Usercentrics settingsId from the page.\n   *\n   * @returns {string} the Usercentrics settingsId, defaults to an empty string if none is found\n   */\n  function getCurrentUsercentricsSettingsId () {\n    return (window.usercentrics &amp;&amp; window.usercentrics.settingsId) || ''\n  }\n\n  /**\n   * Trigger the core logic with an up-to-date array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   * @function recheckForCmpAndConsent\n   */\n  function recheckForCmpAndConsent () {\n    var newConsentResponse = cmpConsentCheck()\n    reactToCmpResponse(newConsentResponse)\n  }\n\n  /**\n   * Call [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents} to get the current consent decision.\n   * @function cmpConsentCheck\n   */\n  function cmpConsentCheck () {\n    if (!window.usercentrics || typeof window.usercentrics.getConsents !== 'function') return false\n    var cmpConsentArray = window.usercentrics.getConsents()\n    return cmpConsentArray\n  }\n\n  /**\n   * Indicates if Usercentrics has loaded and returned a well-formed indication of user consent.\n   * @function checkForWellFormedDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is well-formed, otherwise 'false'\n   */\n  function checkForWellFormedDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; typeof cmpConsentArray[0].dataProcessingService === 'string') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if the user has made an EXPLICIT decision\n   * @function checkForExplicitConsentDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is EXPLICIT otherwise 'false'\n   */\n  function checkForExplicitConsentDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; cmpConsentArray[0].updatedBy === 'explicit') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if Tealium iQ has permission to run (and fire tags).\n   * @function checkForTiqConsent\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if TiQ is allowed to run, otherwise 'false'\n   */\n  function checkForTiqConsent (cmpConsentArray) {\n    var foundOptIn = false\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // check vendors if there's an object, look for at least one\n    cmpConsentArray.forEach(function (tagInfo) {\n      if (tagInfo.consentStatus === true &amp;&amp; tagInfo.dataProcessingService === tiqServiceName) {\n        foundOptIn = true\n      }\n    })\n    return foundOptIn\n  }\n\n  /**\n   * Create an instance of\n   * @param {array} cmpConsentArray the array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   */\n  function getVendorConsentsFromCmpConsentArray (cmpConsentArray) {\n    var vendorArray = []\n\n    var isWellFormed = checkForWellFormedDecision(cmpConsentArray)\n\n    if (!isWellFormed) {\n      vendorArray.type = 'missing-well-formed-response'\n      return []\n    }\n\n    var tagBasedMap = generateTagBasedMap()\n\n    // if there is no mapping for the settings id, we need to change the console output\n    var currentSettingsIdHasMapping = (typeof tagBasedMap === 'object' &amp;&amp; Object.keys(tagBasedMap).length &gt; 0)\n\n    if (!currentSettingsIdHasMapping) {\n      vendorArray.type = 'missing-map'\n      return []\n    }\n\n    cmpConsentArray &amp;&amp; cmpConsentArray.forEach(function (tagConsent) {\n      if (tagConsent.consentStatus === true) {\n        vendorArray.push(tagConsent.dataProcessingService)\n      }\n    })\n    vendorArray.type = checkForExplicitConsentDecision(cmpConsentArray) ? 'explicit' : 'implicit'\n\n    if (checkForTiqConsent(cmpConsentArray) === false) {\n      // change the consent type, but leave the array for debugging purposes\n      vendorArray.type = 'missing-tiq-consent'\n    }\n\n    return vendorArray\n  }\n\n  /**\n   * Get the current consent decision from the CMP for the active Setting\n   * @function getCurrentConsentDecision\n   * @returns a {@link ConsentDecision ConsentDecision}\n   */\n  function getCurrentConsentDecision () {\n    var freshConsent = cmpConsentCheck()\n\n    return getVendorConsentsFromCmpConsentArray(freshConsent)\n  }\n\n  /**\n   *  A conditional logging function - we can't use utag.DB directly because some of our logic needs to be preloader, but we can mimic the same logic so that our logging only displays when TiQ is in debug mode and/or not in Prod, or is explicitly forced.\n   * @function logger\n   * @param {string} message the message to be conditionally shown\n   * @param {boolean} showOutsideDebugMode if 'true', forces the message to shown outside of debug mode, except on Prod\n   */\n  function logger (message, showOutsideDebugMode) {\n    if (typeof tealiumEnvironment === 'undefined' || tealiumEnvironment === 'prod') {\n      // don't allow anything outside of debug mode on prod (disable this flag)\n      showOutsideDebugMode = false\n    }\n\n    if (showOutsideDebugMode || tiqInDebugMode) {\n      message = '\\n' + message + '\\n'\n      var formattedArr = []\n      formattedArr.push('****************')\n      var messageArr = message.split('\\n')\n      messageArr.forEach(function (messageLine) {\n        formattedArr.push('*  ' + messageLine)\n      })\n      formattedArr.push('****************')\n      var outputString = formattedArr.join('\\n')\n      console.log(outputString)\n    }\n  }\n\n  /**\n   * Stops Tealium iQ from loading (the TMS will not load tags or set a cookie if this function is called in Pre Loader), using the {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} setting\n   * @function stopTiq\n   */\n  function stopTiq () {\n    // logger(&quot;stopTiq function fired&quot;)\n    window.utag_cfg_ovrd = window.utag_cfg_ovrd || {}\n    window.utag_cfg_ovrd.noload = true\n  }\n\n  /**\n   * Allows TiQ to finish loading, intended to be called when a well-formed consent response is received, and that response allows Tealium iQ to run.\n   *\n   * Works by setting {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} to 'false' and calling Tealium iQ's utag.loader.PINIT method.\n   *\n   * If noload was 'true' and this function runs it must've been set to true by our own {@link module:extension-1~stopTiq stopTiq} function, because otherwise Tealium iQ wouldn't have been allowed to load/poll in the first place.\n   * @function triggerTiqLoad\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function triggerTiqLoad () {\n    // if usercentrics is ready on the first request, TiQ won't have loaded yet at all - let it load naturally\n    if (!window.utag) {\n      return true\n    }\n    // if TiQ has already loaded but these flags aren't truthy, we've interrupted the load and should retrigger it\n    // initial load / view (noview logic handled in utag.handler.trigger function itself)\n    if (!window.utag.handler || !window.utag.handler.iflag) {\n      // we don't need to reload actually, just allow it to finish loading\n      window.utag.cfg.noload = false // safe because this code only runs if it was set to false originally\n      window.utag.loader.PINIT()\n      return true\n    }\n    // already loaded\n    return false\n  }\n\n  /**\n   * If Tealium iQ hasn't loaded, load it (calling utag.handler.trigger in the process), otherwise call utag.handler.trigger.\n   * @function triggerOrQueue\n   */\n  function triggerOrQueue () {\n    var successfullyTriggeredLoadIfNeeded = triggerTiqLoad()\n    if (!successfullyTriggeredLoadIfNeeded) {\n      // explicit consent from polling, but load has already been triggered\n      return window.utag.handler.trigger(nameOfConsentPollingEvent)\n    }\n  }\n  /**\n   * Get the the current Tealium iQ environment.\n   *\n   * Since this runs in Pre Loader, it needs to use regex to recognize the utag.js file in the DOM and read the environment from the file name (there are no utag functions or objects at this point in the load).\n   *\n   * NOTE: This doesn't work correctly when using the the Environment Switcher (because the original script is added to the DOM instead of the new one, and the 307 redirect that's used to pull the new file(s) only changes the response, not the script element itself).\n   *\n   * If you're using the Environment Switcher on Prod and would like to see console output, set the [debug cookie]{@link https://docs.tealium.com/platforms/javascript/debugging/}.\n   *\n   * @function getTealiumEnvironment\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function getTealiumEnvironment () {\n    var allScripts = document.getElementsByTagName('script')\n    var re = /\\/([^/]*)\\/utag\\.js(\\?.*)*$/\n    for (var i = 0; i &lt; allScripts.length; i++) {\n      var result = re.exec(allScripts[i].src) // can be null\n      if (result &amp;&amp; result[1]) { // [1] is the result of the match\n        return result[1]\n      }\n    }\n    return 'prod' // default to guessing we're in prod, just in case we're actually in prod (to avoid logging in Prod)\n  }\n})()\n\n// Document key data structures here for clarity.\n\n/**\n * An array of Usercentrics Service Names that have permission to run (uses the 'dataProcessingService' property from [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}).\n *\n * Also includes a 'type' property that indicates whether the consent decision is IMPLICIT or EXPLICT.\n *\n * @static\n * @type {array}\n * @name ConsentDecision\n * @memberof! &lt;global&gt;\n * @property {string} type the type of consent, will be either 'implicit' or 'explicit'\n * @example\nvar exampleConsentDecision = window.tealiumCmpIntegration.getCurrentConsentDecision()\n\nJSON.stringify(exampleConsentDecision)\n// [&quot;Google Analytics&quot;,&quot;Another Tag&quot;,&quot;Tealium iQ Tag Management&quot;]\n\nexampleConsentDecision.type\n// &quot;explicit&quot;\n\nexampleConsentDecision.length\n// 3\n */\n\n/**\n * Assigns Tealium iQ Tags to Usercentrics Service Names. Each service can have multiple tags, but each tag can only have one service.  If the same tag UID appears in multiple Service arrays, only one will be used.\n *\n * The keys for the main object are Setting-IDs from Usercentrics, inside that are key/value pairs where the key is a Service Name from Usercentrics, and the value is an array of TagUIDs from Tealium iQ.\n *\n * This needs to be provided as per the example below, in [tealiumCmpIntegration.map]{@link namespace:tealiumCmpIntegration~map}.\n *\n * An [example Tealium iQ extension]{@link module:example-map} is provided as well.\n *\n * @static\n * @type {object}\n * @name ServiceToTagMap\n * @memberof! &lt;global&gt;\n * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n  'yPyIAIIxY': {\n    'Google Analytics': [6, 8, 10],\n    'Mouseflow': [7, 9],\n    'Another Tag': [11]\n  }\n}\n */\n\n/**\n * A simple lookup, with Tealium iQ tag UIDs as keys and the associated Usercentrics service name as strings as values. Each service can be associated with multiple tags, but each tag can be associated with one service.\n *\n * The example is based on the {@link ServiceToTagMap ServiceToTagMap} example, where the Usercentrics settingsId on the active page is 'yPyIAIIxY'.\n *\n * This object is automatically generated by the [getTagBasedMap]{@link module:extension-1~getTagbasedMap} method, and made available globally in [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration~tagBasedMap} for debugging and use within the extensions.\n *\n * @static\n * @type {object}\n * @name TagToServiceMap\n * @memberof! &lt;global&gt;\n * @example\n{\n  6: 'Google Analytics',\n  7: 'Mouseflow',\n  8: 'Google Analytics',\n  9: 'Mouseflow',\n  10: 'Google Analytics',\n  11: 'Another Tag'\n}\n */\n\n/**\n * An object from the [implicitEventQueue]{@link tealiumCmpIntegration.implicitEventQueue} or [earlyEventQueue]{@link tealiumCmpIntegration.earlyEventQueue}, which represents a Tealium iQ tracking event that's been processed based on an IMPLICIT [ConsentDecision]{@link ConsentDecision}\n *\n * Heavily based on the argument passed to [utag.track]{@link https://community.tealiumiq.com/t5/Tealium-iQ-Tag-Management/utag-track-method/td-p/24578}, since it's designed to be processed by that method.\n *\n * Initial pageviews (handled in the [utag.loader.initdata override]{@link module:extension-1~newUtagLoaderInitdata}) will NOT have metadata like cookies, qps, etc - utag.track calls (handled in the [utag.handler.trigger override]{@link module:extension-1~newUtagHandlerTrigger}) will. That's a byproduct of using utag.handler.trigger, which is later in the load - those metadata will be re-read when the queue is processed, and since this queue isn't persisted between pages, it should be fine like that - the only strange behavior will be that any metadata that aren't present on re-read will still be present after the re-read - only values that are still present will be replaced with new values.\n *\n * An alternative approach could be to manually remove 'cp.\\*', 'dom.\\*', 'ut.\\*', 'qp.\\*', 'meta.\\*' and possibly 'tealium_\\*' (except 'tealium_event') from the 'data' object before queueing - that hasn't been done so far.\n *\n * @static\n * @type {array}\n * @name QueuedEvent\n * @memberof! &lt;global&gt;\n * @property {string} event the type of tracking event, generally 'view' for pageviews or 'link' for other events\n * @property {object} data the Universal Data Object associated with the event (from utag_data or the b object)\n * @property {object} cfg an optional configuration object that can have a 'cb' property (for a callback function) and a 'uids' array, which is a list of tag UIDs that should be triggered by the event, regardless of whether load rules are met.\n * @example\n{\n  &quot;event&quot;: &quot;view&quot;,\n  &quot;data&quot;: {\n    &quot;page_type&quot;: &quot;test_virtual_view&quot;,\n    &quot;cp.utag_main_v_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;cp.utag_main__sn&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__se&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__ss&quot;: &quot;0&quot;,\n    &quot;cp.utag_main__st&quot;: &quot;1598990152209&quot;,\n    &quot;cp.utag_main_ses_id&quot;: &quot;1598988112353&quot;,\n    &quot;cp.utag_main__pn&quot;: &quot;3&quot;,\n    &quot;cp.utagdb&quot;: &quot;true&quot;,\n    &quot;dom.referrer&quot;: &quot;&quot;,\n    &quot;dom.title&quot;: &quot;Usercentrics Test&quot;,\n    &quot;dom.domain&quot;: &quot;solutions.tealium.net&quot;,\n    &quot;dom.query_string&quot;: &quot;&quot;,\n    &quot;dom.hash&quot;: &quot;&quot;,\n    &quot;dom.url&quot;: &quot;https://solutions.tealium.net/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.pathname&quot;: &quot;/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.viewport_height&quot;: 456,\n    &quot;dom.viewport_width&quot;: 1825,\n    &quot;ut.domain&quot;: &quot;tealium.net&quot;,\n    &quot;ut.version&quot;: &quot;ut4.46.202009011921&quot;,\n    &quot;ut.event&quot;: &quot;view&quot;,\n    &quot;ut.visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;ut.session_id&quot;: &quot;1598988112353&quot;,\n    &quot;ut.account&quot;: &quot;services-caleb&quot;,\n    &quot;ut.profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;ut.env&quot;: &quot;prod&quot;,\n    &quot;tealium_event&quot;: &quot;view&quot;,\n    &quot;tealium_visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;tealium_session_id&quot;: &quot;1598988112353&quot;,\n    &quot;tealium_session_number&quot;: &quot;4&quot;,\n    &quot;tealium_session_event_number&quot;: &quot;4&quot;,\n    &quot;tealium_datasource&quot;: &quot;&quot;,\n    &quot;tealium_account&quot;: &quot;services-caleb&quot;,\n    &quot;tealium_profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;tealium_environment&quot;: &quot;prod&quot;,\n    &quot;tealium_random&quot;: &quot;2085060854215077&quot;,\n    &quot;tealium_library_name&quot;: &quot;utag.js&quot;,\n    &quot;tealium_library_version&quot;: &quot;4.46.0&quot;,\n    &quot;tealium_timestamp_epoch&quot;: 1598988352,\n    &quot;tealium_timestamp_utc&quot;: &quot;2020-09-01T19:25:52.211Z&quot;,\n    &quot;tealium_timestamp_local&quot;: &quot;2020-09-01T21:25:52.211&quot;,\n    &quot;usercentrics_services_with_consent&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ],\n    &quot;usercentrics_consent_type&quot;: &quot;implicit&quot;,\n    &quot;_usercentrics_services_already_processed&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ]\n  },\n  &quot;cfg&quot;: {\n    &quot;cb&quot;: function myCallback () {console.log(&quot;Callback fired!&quot;)},\n    &quot;uids&quot;: [\n      11\n    ],\n    &quot;originalUids&quot;: [\n      7,\n      11\n    ],\n    &quot;blockedTagUids&quot;: [\n      11\n    ]\n  }\n}\n*/\n","promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202010290930","promotedDraftName":"extension-1.js"},"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"name":"dev","code":"/**\n *  Scope       : Pre Loader\n *  Condition   : n/a\n *  Description : CMP 1/2 - Preloader component - prevent TiQ from loading if no consent, queue implicitly consented events to retrigger (for new tags only) if explicit decision is made.\n */\n\n/**\n  * @module extension-1\n  *\n  * @description The 'Pre Loader' extension component of the CMP integration, responsible for stopping Tealium iQ from loading/running as appropriate, and making certain\n  * window-scoped functions available to the other components.\n  */\n\n// Tealium iQ runs Pre Loader extensions in global scope, which would make all variables global. We don't want to do that.\n(function avoidGlobalScopeUnlessExplicit () {\n  // set names for key objects and variables to make them easy to change if needed\n\n  var version = 'v0.10-beta'\n\n  // for the consent information in the b object\n  var nameOfVendorOptInArray = 'usercentrics_services_with_consent'\n  var nameOfConsentTypeString = 'usercentrics_consent_type'\n\n  // for the name in the queue\n  var nameOfImplicitConsentArray = '_usercentrics_services_already_processed'\n\n  // name to use when calling utag.handler.trigger to indicate a consent polling call\n  var nameOfConsentPollingEvent = 'tiq_usercentrics_consent_polling'\n\n  var consentTimeoutInterval = 400 // setTimeout interval in MS - rate to poll for new (explicit) consent decision or correctly formed object\n\n  // check for the Tealium Debug cookie, see https://docs.tealium.com/platforms/javascript/debugging/\n  var tiqInDebugMode = /utagdb=true/.test(document.cookie)\n  var tealiumEnvironment = getTealiumEnvironment() || 'prod' // fall back to prod (stops logging) if something goes wrong with the function\n\n  /**\n   * A window-scoped (global) object used to expose selected functionality.\n   *\n   * @namespace tealiumCmpIntegration\n   * @type {object}\n   * @memberof! &lt;global&gt;\n   */\n  window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\n\n  /**\n   * The name of the CMP (&quot;Usercentrics Vanilla App&quot; in this case).\n   * @name cmpName\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.cmpName = 'Usercentrics Vanilla App'\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link ServiceToTagMap ServiceToTagMap}\n   * @name map\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  var map = window.tealiumCmpIntegration.map || {}\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link TagToServiceMap TagToServiceMap}\n   * @name tagBasedMap\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  generateTagBasedMap() // populates the window-level object for you as well\n\n  /**\n   * The Service Name for Tealium iQ in Usercentrics (used to decide if the TMS is allowed to run).  Uses the Usercentrics standard name if not provided.\n   * @name tiqServiceName\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   * @default 'Tealium iQ Tag Management'\n   * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.tiqServiceName = &quot;Tealium iQ Tag Management&quot;\n   */\n  var tiqServiceName = window.tealiumCmpIntegration.tiqServiceName || 'Tealium iQ Tag Management' // use the standard name here if not set\n\n  /**\n   * The current version designation.\n   * @name version\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.version = version\n\n  /**\n   * A [logger helper function]{@link module:extension-1~logger}, to help Tealium iQ users understand and troubleshoot this CMP integration without unneeded logging in production.\n   * @name logger\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.logger = logger\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentConsentDecision} that returns the current [ConsentDecision]{@link ConsentDecision}.\n   * @name getCurrentConsentDecision\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentConsentDecision = getCurrentConsentDecision\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentUsercentricsSettingsId} that returns the current Usercentrics settingsId.\n   * @name getCurrentUsercentricsSettingsId\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentUsercentricsSettingsId = getCurrentUsercentricsSettingsId\n\n  /**\n   * Records the status of the [noview]{@link https://docs.tealium.com/platforms/javascript/settings/#noview} setting on page load.\n   * @name isNoviewSet\n   * @type {boolean}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.isNoviewSet = window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noview === true\n\n  /**\n   * The name to use for the [ConsentDecision]{@link ConsentDecision} array when adding it to Tealium's b object on each event.\n   * @name nameOfVendorOptInArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfVendorOptInArray = nameOfVendorOptInArray\n\n  /**\n   * The name to use for the current [ConsentDecision]{@link ConsentDecision}'s 'type' attribute when adding it to Tealium's b object on each event.\n   * @name nameOfConsentTypeString\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfConsentTypeString = nameOfConsentTypeString\n\n  /**\n   * The name to use for the array of implicit tags (which have already been fired) in the 'data' property of {@link QueuedEvent QueuedEvent} objects.\n   * @name nameOfImplicitConsentArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfImplicitConsentArray = nameOfImplicitConsentArray\n\n  /**\n   * A [helper function]{@link module:extension-1~overrideUtagFunctions} that overrides certain utag functions to allow tags to be blocked based on CMP response.\n   *\n   * Must be called directly after the '##UTGEN##' reference by [editing]{@link https://community.tealiumiq.com/t5/iQ-Tag-Management/Managing-Tag-Templates/ta-p/21713} the 'utag loader' template, as shown in the example.\n   * @name overrideUtagFunctions\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   * @example\n// ... utag loader template ...\n\n##UTGEN##\n// override two utag functions for the Usercentrics CMP Integration, to allow tags to be blocked as needed\nwindow.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions()\n\n// ... utag loader template continues...\n\n   */\n  window.tealiumCmpIntegration.overrideUtagFunctions = overrideUtagFunctions\n\n  /**\n   * A queue for any events that Tealium iQ processes with IMPLICIT consent (to allow those events to be re-processed for new Services in the event of an EXPLICIT consent choice by the user).\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name implicitEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n\n  /**\n   * A queue for any events that are triggered before Tealium iQ AND Usercentrics have both loaded.\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name earlyEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n\n  /**\n   * Allows us to make sure we don't log certain messages more than once, especially useful while polling to avoid overwhelming the user.\n   * @function messageNotLoggedYet\n   * @param {*} messageId a string or number to uniquely identify a message for the purposes of deduplication\n   * @returns {boolean} 'true' if the message hasn't been logged yet (and should be logged), otherwise 'false'\n   */\n  var alreadyLoggedMessageIds = {}\n  function messageNotLoggedYet (messageId) {\n    var output = false\n    if (typeof alreadyLoggedMessageIds[messageId] === 'undefined') {\n      alreadyLoggedMessageIds[messageId] = true\n      output = true\n    }\n    return output\n  }\n\n  // if noload is set to 'true', don't interfere, just return to exit this function and allow that setting to stop TiQ load as usual.\n  if (window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noload === true) return false\n\n  logger('CMP integration active - Usercentrics/TiQ' + (tiqInDebugMode ? &quot;\\n\\nDEBUGGING TIP: Use /SENDING|\\\\*\\\\*\\\\*\\\\*/ in the browser console as the 'filter' to show only CMP and tag send notifications.&quot; : '\\n\\nActivate TiQ Debug Mode for more details: https://docs.tealium.com/platforms/javascript/debugging/'), true)\n  var cmpResponse = cmpConsentCheck()\n  // core business/GDPR logic, decides if TiQ should load at all\n  reactToCmpResponse(cmpResponse)\n\n  /**\n   * The core CMP integration logic, which decides if Tealium iQ should be allowed to run, or if it needs to be stopped\n   * until an understandable response that includes permission for Tealium iQ to run is found.\n   *\n   * @function reactToCmpResponse\n   * @param {object} cmpResponse The response from the Usercentrics Vanilla App\n   */\n  function reactToCmpResponse (cmpResponse) {\n    var usercentricsFound = typeof cmpResponse === 'object'\n    var foundWellFormedConsentDecision = checkForWellFormedDecision(cmpResponse)\n    var tagBasedMap = generateTagBasedMap()\n    var foundMapEntryForActiveSetting = Object.keys(tagBasedMap).length &gt; 0\n    var foundExplicitConsent = checkForExplicitConsentDecision(cmpResponse)\n    var tiqIsAllowedToFire = checkForTiqConsent(cmpResponse)\n    var tiqIsLoaded = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!usercentricsFound) {\n      /**\n       * CASE A1: no Usercentrics CMS found\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(1)) logger('No Usercentrics CMP found on page.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundMapEntryForActiveSetting) {\n      /**\n        * CASE A7: No map found for the current settingsId\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(2)) logger('No map found for current Usercentrics Setting ID.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    } else if (!foundWellFormedConsentDecision) {\n      /**\n       * CASE A2: Usercentrics CMS found but consent response wasn't well-formed/complete/understandable\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(3)) logger('Found Usercentrics CMP and got response, but didn\\'t understand the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!tiqIsAllowedToFire) {\n      /**\n       * CASE A3: Usercentrics CMS found and consent response was well-formed, BUT TiQ didn't have an opt-in\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(4)) logger('Found Usercentrics CMP and got well-formed response, but TiQ isn\\'t allowed to run based on the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundExplicitConsent) {\n      /**\n       * CASE A4: Usercentrics CMS found AND response was understandable (AND includes an implicit TiQ consent), BUT the user hasn't made an explicit decision yet\n       *\n       * ALLOW TO LOAD for any 'default opt-in' tags (filter logic in Extension B)\n       * RETRY after a delay (in case there's an explicit decision, since implicit decisions usually mean the prompt is displayed)\n       */\n      if (messageNotLoggedYet(5)) logger('Found Usercentrics CMP and got well-formed IMPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on IMPLICIT consent.\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else if (foundExplicitConsent) {\n      /**\n       * CASE A5: Usercentrics CMS found AND response was understandable, AND the user has made an explicit consent decision AND TiQ is allowed\n       *\n       * ALLOW TO LOAD for any opted-in tags (filter logic in Extension B), do not retry.\n       */\n      if (messageNotLoggedYet(6)) logger('Found Usercentrics CMP and got well-formed EXPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on EXPLICIT consent.\\n\\nNo further polling.')\n      // only call if we've been polling (on initial load, it will load automatically)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n        processImplicitQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else {\n      /**\n        * CASE A6: Something went wrong with this extension.\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(7)) logger('Something unexpected went wrong.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    }\n  }\n\n  /**\n   * Override utag.loader.initdata and utag.handler.trigger to allow Tealium iQ Tags to be blocked if the user hasn't consented.\n   *\n   * @function overrideUtagFunctions\n   * @returns {boolean} 'true' if the function was overridden successfully by this request, 'false' if not (because it was already overridden)\n   */\n  function overrideUtagFunctions () {\n    // don't override more than once, assume that if one function has been overridden, both have\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    // the initial view is handled differently than subsequent events\n    // this is safe to to override even if noview is set (because it will never be called in that case)\n    window.utag.loader.initdata_old = window.utag.loader.initdata\n    window.utag.loader.initdata = newUtagLoaderInitdata\n\n    window.utag.handler.trigger_old = window.utag.handler.trigger\n    window.utag.handler.trigger = newUtagHandlerTrigger\n    logger('Overrode utag functions!')\n\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * An overridden version of the Tealium iQ function utag.loader.initdata.\n   *\n   * Calls the original function, respects possible noview settings, rechecks the user consent, and calls queueEventWithoutFiringImplicitServices\n   * if only an IMPLICIT consent is found (after recording the IMPLICIT services, to avoid double-firing).\n   *\n   * That same event can then be re-processed for any new Services if an EXPLICIT consent decision later made.\n   *\n   * @function newUtagLoaderInitdata\n   */\n  function newUtagLoaderInitdata () {\n    window.utag.loader.initdata_old()\n    // make sure we don't queue this initial page load twice, and respect the configured noview setting\n    if (!window.tealiumCmpIntegration.isNoviewSet &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n      window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n      var consentedServices = getCurrentConsentDecision()\n      if (consentedServices.type === 'implicit') {\n        window.tealiumCmpIntegration.implicitServices = consentedServices\n        // we don't need to fire implicit services in this case, because TiQ's loading process will fire them\n        queueEventWithoutFiringImplicitServices({\n          event: 'view',\n          data: window.utag.handler.C(window.utag.data)\n        })\n      }\n    }\n  }\n\n  /**\n   * Refresh [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration.tagBasedMap} and return that new map, helps smooth out any timing issues between Usercentrics and Tealium iQ load.\n   *\n   * @function generateTagBasedMap\n   * @returns a [TagToServiceMap]{@link TagToServiceMap}\n   */\n  function generateTagBasedMap () {\n    var tagBasedMap = getTagBasedMap(map)\n    window.tealiumCmpIntegration.tagBasedMap = tagBasedMap\n    return tagBasedMap\n  }\n\n  /**\n   * Tealium iQ's utag.handler.trigger normally causes tags to fire. For this integration, we override that function to support blocking tags without consent.\n   *\n   * @function newUtagHandlerTrigger\n   *\n   * @param {*} a can be an object or a string\n   * @param {*} b\n   * @param {*} c\n   */\n  function newUtagHandlerTrigger (a, b, c) {\n    /**\n     * Trigger CASES (utag.handler.trigger override)\n     *\n     * We need to queue the events if we only have implicit consent, to allow a selective retrigger if/when we get an explicit decision.\n     */\n    var isPureConsentEvent = (a === nameOfConsentPollingEvent &amp;&amp; !b &amp;&amp; !c)\n    var isNoviewSet = window.tealiumCmpIntegration.isNoviewSet || true // assume noview if something went wrong with the global, to avoid firing tracking in error\n\n    var consentedServices = getCurrentConsentDecision()\n    var consentType = (consentedServices &amp;&amp; consentedServices.type) || 'none'\n\n    var isUsercentricsReady = consentType === 'implicit' || consentType === 'explicit'\n    var isTealiumReady = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!isPureConsentEvent) {\n      logger('utag.handler.trigger called with:\\n\\n' + JSON.stringify(arguments, null, 2))\n    }\n\n    if (!isUsercentricsReady &amp;&amp; !isTealiumReady) {\n      consentedServices.type = 'tealium-and-usercentrics-loading'\n      logger('Waiting for Usercentrics and Tealium to be ready, queueing early event.')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isUsercentricsReady) {\n      consentedServices.type = 'usercentrics-loading'\n      logger('Usercentrics is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isTealiumReady) {\n      consentedServices.type = 'tealium-still-loading'\n      logger('Tealium iQ is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    }\n\n    // if an array of tagUids is passed, that forces them to fire regardless of load rules\n    // or consent, so we need to filter that array before allowing it to be processed\n    var hasTagUidArray = c &amp;&amp; typeof c === 'object' &amp;&amp; c.uids &amp;&amp; c.uids &amp;&amp; window.utag.ut.typeOf(c.uids) === 'array'\n    var uidMap = generateTagBasedMap()\n    var allowedTagUids = []\n    var blockedTagUids = []\n    var serviceName\n    var tagUid\n    if (hasTagUidArray) {\n      for (var i = 0; i &lt; c.uids.length; i++) {\n        tagUid = c.uids[i]\n        serviceName = uidMap[tagUid] || '(missing)'\n        // only push consented services into the new array\n        if (consentedServices.indexOf(serviceName) !== -1) {\n          allowedTagUids.push(tagUid)\n        } else {\n          blockedTagUids.push(tagUid)\n        }\n      }\n      // replace the original with the filtered array (can also be empty, if none of them were allowed)\n      logger('Call included tagUid array:\\n\\n' + JSON.stringify(c.uids) + '\\n\\nwhich was replaced by the filtered version:\\n\\n' + JSON.stringify(allowedTagUids))\n      c.originalUids = c.uids.slice() // make a shallow copy\n      c.uids = allowedTagUids\n      c.blockedTagUids = blockedTagUids\n    }\n\n    if (consentType === 'explicit') {\n      /**\n       * CASE T2: expected globals are populated, consent is EXPLICIT\n       *\n       * FIRE allowed tags (explicit)\n       * utag.handler.trigger override PROCESSES the queue, which will include any queued events from CASE A4, making sure not to re-fire any default\n       *   opt-in tags that were already fired for the queued events\n       */\n      // make sure TiQ loads\n      processEarlyQueue()\n      processImplicitQueue()\n      triggerTiqLoad()\n      // fire the current event if it's not just a polling event\n      if (!isPureConsentEvent) {\n        return window.utag.handler.trigger_old(a, b, c)\n      }\n    } else if (consentType === 'implicit') {\n      /**\n       * CASE T3: expected globals are populated, consent is IMPLICIT\n       *\n       * FIRE allowed tags (implicit)\n       * utag.handler.trigger override KEEPS a queue/record that includes\n       *  - the event(s) that were processed based on implicit consent\n       *  - which tags were allowed to process each event (are set to implicit opt-in)\n       */\n      processEarlyQueue()\n      // fire the initial view if appropriate, and queue it\n      triggerTiqLoad()\n      window.tealiumCmpIntegration.implicitServices = consentedServices\n\n      // queue the initial 'view' on pageload if appropriate\n      if (!isNoviewSet &amp;&amp; isTealiumReady &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n        window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n        queueEventAndFireImplicitServices('view', window.utag.handler.C(window.utag.data))\n      }\n      // queue the current event if it exists (and this isn't just consent polling)\n      if (!isPureConsentEvent) {\n        return queueEventAndFireImplicitServices(a, b, c)\n      }\n    } else if (consentType === 'missing-map') {\n      logger('Something went wrong - all tags were blocked because no consent map was found for the active setting ID.')\n      return false\n    } else if (consentType === 'missing-tiq-consent') {\n      logger('Something went wrong - all tags were blocked because no consent was found for &quot;' + tiqServiceName + '&quot;, configured Tealium iQ name.\\n\\nConsent found: ' + JSON.stringify(consentedServices, null, 2))\n      return false\n    } else {\n      /**\n       * CASE T1: expected variables not populated (misconfiguration/error case)\n       *\n       * STOP and fire nothing at all. Do not retry or queue the event.\n       */\n      logger('Something went wrong - all tags were blocked because the consent response was not understood.')\n      return false\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the early event queue]{@link tealiumCmpIntegration.earlyEventQueue} (can include pageviews) for any currently-consented Services.\n   *\n   * Intended to be called first understandable implicit consent.\n   *\n   * @function processEarlyQueue\n   */\n  function processEarlyQueue () {\n    var queuedEvent\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    while (window.tealiumCmpIntegration.earlyEventQueue.length &gt; 0) {\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.earlyEventQueue.shift()\n      logger('Processing queued early event for currently consented tags: ' + JSON.stringify(queuedEvent, null, 2))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the global queue]{@link tealiumCmpIntegration.implicitEventQueue} (can include pageviews) for any newly-consented Services.\n   *\n   * Intended to be called on new EXPLICIT consent decision - queued events have already had IMPLICTLY consented tags fired, so those need to be excluded.\n   *\n   * @function processImplicitQueue\n   */\n  function processImplicitQueue () {\n    var alreadyLogged = false\n    var queuedEvent\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    while (window.tealiumCmpIntegration.implicitEventQueue.length &gt; 0) {\n      if (!alreadyLogged) {\n        alreadyLogged = true\n        logger('Explicit consent tracking request received - processing past implicitly tracked events (' + window.tealiumCmpIntegration.implicitEventQueue.length + ') for any new explicit tags.')\n      }\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.implicitEventQueue.shift()\n      logger('Triggering event for explicitly-consented tags: ' + JSON.stringify(queuedEvent))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the early queue]{@link tealiumCmpIntegration.earlyEventQueue}, without firing any tags.\n   *\n   * Intended to be called for events that triggered before we get an understandable response from Usercentrics.\n   *\n   * @function queueEarlyEvent\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEarlyEvent (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    // nothing will be allowed to fire\n    a.data[nameOfImplicitConsentArray] = []\n\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    window.tealiumCmpIntegration.earlyEventQueue.push(a)\n    logger('Queued early event!')\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration.implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for the initial pageview on load, since the load process will have already fired the implicit services.\n   *\n   * @function queueEventWithoutFiringImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventWithoutFiringImplicitServices (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    a.data[nameOfImplicitConsentArray] = window.tealiumCmpIntegration.implicitServices || []\n\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    window.tealiumCmpIntegration.implicitEventQueue.push(a)\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration~implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for all events other than the initial page load.\n   *\n   * @function queueEventAndFireImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventAndFireImplicitServices (a, b, c) {\n    // fire the implicit tags\n    window.utag.handler.trigger_old(a, b, c)\n    logger('Implicit consent tracking request fired (or queued, if utag hasn\\'t loaded).')\n    return queueEventWithoutFiringImplicitServices(a, b, c)\n  }\n\n  /**\n   * Generate a {@link TagToServiceMap TagToServiceMap} based on a {@link ServiceToTagMap ServiceToTagMap}\n   *\n   * @function getTagBasedMap\n   * @param {object} map a {@link ServiceToTagMap ServiceToTagMap} object\n   * @return {object} a {@link TagToServiceMap TagToServiceMap}\n   */\n  function getTagBasedMap (map) {\n    // generate a lookup based on the tagUid\n    if (typeof map !== 'object') return {}\n    var settingsId = getCurrentUsercentricsSettingsId() || ''\n    if (typeof settingsId !== 'string' || settingsId === '') return {}\n    var settingSpecificMap = map[settingsId] || {}\n    var serviceNames = Object.keys(settingSpecificMap)\n    var uidMap = {}\n    for (var i = 0; i &lt; serviceNames.length; i++) {\n      for (var j = 0; j &lt; settingSpecificMap[serviceNames[i]].length; j++) {\n        uidMap[settingSpecificMap[serviceNames[i]][j]] = serviceNames[i]\n      }\n    }\n    return uidMap\n  }\n\n  /**\n   * Get the current Usercentrics settingsId from the page.\n   *\n   * @returns {string} the Usercentrics settingsId, defaults to an empty string if none is found\n   */\n  function getCurrentUsercentricsSettingsId () {\n    return (window.usercentrics &amp;&amp; window.usercentrics.settingsId) || ''\n  }\n\n  /**\n   * Trigger the core logic with an up-to-date array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   * @function recheckForCmpAndConsent\n   */\n  function recheckForCmpAndConsent () {\n    var newConsentResponse = cmpConsentCheck()\n    reactToCmpResponse(newConsentResponse)\n  }\n\n  /**\n   * Call [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents} to get the current consent decision.\n   * @function cmpConsentCheck\n   */\n  function cmpConsentCheck () {\n    if (!window.usercentrics || typeof window.usercentrics.getConsents !== 'function') return false\n    var cmpConsentArray = window.usercentrics.getConsents()\n    return cmpConsentArray\n  }\n\n  /**\n   * Indicates if Usercentrics has loaded and returned a well-formed indication of user consent.\n   * @function checkForWellFormedDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is well-formed, otherwise 'false'\n   */\n  function checkForWellFormedDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; typeof cmpConsentArray[0].dataProcessingService === 'string') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if the user has made an EXPLICIT decision\n   * @function checkForExplicitConsentDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is EXPLICIT otherwise 'false'\n   */\n  function checkForExplicitConsentDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; cmpConsentArray[0].updatedBy === 'explicit') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if Tealium iQ has permission to run (and fire tags).\n   * @function checkForTiqConsent\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if TiQ is allowed to run, otherwise 'false'\n   */\n  function checkForTiqConsent (cmpConsentArray) {\n    var foundOptIn = false\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // check vendors if there's an object, look for at least one\n    cmpConsentArray.forEach(function (tagInfo) {\n      if (tagInfo.consentStatus === true &amp;&amp; tagInfo.dataProcessingService === tiqServiceName) {\n        foundOptIn = true\n      }\n    })\n    return foundOptIn\n  }\n\n  /**\n   * Create an instance of\n   * @param {array} cmpConsentArray the array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   */\n  function getVendorConsentsFromCmpConsentArray (cmpConsentArray) {\n    var vendorArray = []\n\n    var isWellFormed = checkForWellFormedDecision(cmpConsentArray)\n\n    if (!isWellFormed) {\n      vendorArray.type = 'missing-well-formed-response'\n      return []\n    }\n\n    var tagBasedMap = generateTagBasedMap()\n\n    // if there is no mapping for the settings id, we need to change the console output\n    var currentSettingsIdHasMapping = (typeof tagBasedMap === 'object' &amp;&amp; Object.keys(tagBasedMap).length &gt; 0)\n\n    if (!currentSettingsIdHasMapping) {\n      vendorArray.type = 'missing-map'\n      return []\n    }\n\n    cmpConsentArray &amp;&amp; cmpConsentArray.forEach(function (tagConsent) {\n      if (tagConsent.consentStatus === true) {\n        vendorArray.push(tagConsent.dataProcessingService)\n      }\n    })\n    vendorArray.type = checkForExplicitConsentDecision(cmpConsentArray) ? 'explicit' : 'implicit'\n\n    if (checkForTiqConsent(cmpConsentArray) === false) {\n      // change the consent type, but leave the array for debugging purposes\n      vendorArray.type = 'missing-tiq-consent'\n    }\n\n    return vendorArray\n  }\n\n  /**\n   * Get the current consent decision from the CMP for the active Setting\n   * @function getCurrentConsentDecision\n   * @returns a {@link ConsentDecision ConsentDecision}\n   */\n  function getCurrentConsentDecision () {\n    var freshConsent = cmpConsentCheck()\n\n    return getVendorConsentsFromCmpConsentArray(freshConsent)\n  }\n\n  /**\n   *  A conditional logging function - we can't use utag.DB directly because some of our logic needs to be preloader, but we can mimic the same logic so that our logging only displays when TiQ is in debug mode and/or not in Prod, or is explicitly forced.\n   * @function logger\n   * @param {string} message the message to be conditionally shown\n   * @param {boolean} showOutsideDebugMode if 'true', forces the message to shown outside of debug mode, except on Prod\n   */\n  function logger (message, showOutsideDebugMode) {\n    if (typeof tealiumEnvironment === 'undefined' || tealiumEnvironment === 'prod') {\n      // don't allow anything outside of debug mode on prod (disable this flag)\n      showOutsideDebugMode = false\n    }\n\n    if (showOutsideDebugMode || tiqInDebugMode) {\n      message = '\\n' + message + '\\n'\n      var formattedArr = []\n      formattedArr.push('****************')\n      var messageArr = message.split('\\n')\n      messageArr.forEach(function (messageLine) {\n        formattedArr.push('*  ' + messageLine)\n      })\n      formattedArr.push('****************')\n      var outputString = formattedArr.join('\\n')\n      console.log(outputString)\n    }\n  }\n\n  /**\n   * Stops Tealium iQ from loading (the TMS will not load tags or set a cookie if this function is called in Pre Loader), using the {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} setting\n   * @function stopTiq\n   */\n  function stopTiq () {\n    // logger(&quot;stopTiq function fired&quot;)\n    window.utag_cfg_ovrd = window.utag_cfg_ovrd || {}\n    window.utag_cfg_ovrd.noload = true\n  }\n\n  /**\n   * Allows TiQ to finish loading, intended to be called when a well-formed consent response is received, and that response allows Tealium iQ to run.\n   *\n   * Works by setting {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} to 'false' and calling Tealium iQ's utag.loader.PINIT method.\n   *\n   * If noload was 'true' and this function runs it must've been set to true by our own {@link module:extension-1~stopTiq stopTiq} function, because otherwise Tealium iQ wouldn't have been allowed to load/poll in the first place.\n   * @function triggerTiqLoad\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function triggerTiqLoad () {\n    // if usercentrics is ready on the first request, TiQ won't have loaded yet at all - let it load naturally\n    if (!window.utag) {\n      return true\n    }\n    // if TiQ has already loaded but these flags aren't truthy, we've interrupted the load and should retrigger it\n    // initial load / view (noview logic handled in utag.handler.trigger function itself)\n    if (!window.utag.handler || !window.utag.handler.iflag) {\n      // we don't need to reload actually, just allow it to finish loading\n      window.utag.cfg.noload = false // safe because this code only runs if it was set to false originally\n      window.utag.loader.PINIT()\n      return true\n    }\n    // already loaded\n    return false\n  }\n\n  /**\n   * If Tealium iQ hasn't loaded, load it (calling utag.handler.trigger in the process), otherwise call utag.handler.trigger.\n   * @function triggerOrQueue\n   */\n  function triggerOrQueue () {\n    var successfullyTriggeredLoadIfNeeded = triggerTiqLoad()\n    if (!successfullyTriggeredLoadIfNeeded) {\n      // explicit consent from polling, but load has already been triggered\n      return window.utag.handler.trigger(nameOfConsentPollingEvent)\n    }\n  }\n  /**\n   * Get the the current Tealium iQ environment.\n   *\n   * Since this runs in Pre Loader, it needs to use regex to recognize the utag.js file in the DOM and read the environment from the file name (there are no utag functions or objects at this point in the load).\n   *\n   * NOTE: This doesn't work correctly when using the the Environment Switcher (because the original script is added to the DOM instead of the new one, and the 307 redirect that's used to pull the new file(s) only changes the response, not the script element itself).\n   *\n   * If you're using the Environment Switcher on Prod and would like to see console output, set the [debug cookie]{@link https://docs.tealium.com/platforms/javascript/debugging/}.\n   *\n   * @function getTealiumEnvironment\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function getTealiumEnvironment () {\n    var allScripts = document.getElementsByTagName('script')\n    var re = /\\/([^/]*)\\/utag\\.js(\\?.*)*$/\n    for (var i = 0; i &lt; allScripts.length; i++) {\n      var result = re.exec(allScripts[i].src) // can be null\n      if (result &amp;&amp; result[1]) { // [1] is the result of the match\n        return result[1]\n      }\n    }\n    return 'prod' // default to guessing we're in prod, just in case we're actually in prod (to avoid logging in Prod)\n  }\n})()\n\n// Document key data structures here for clarity.\n\n/**\n * An array of Usercentrics Service Names that have permission to run (uses the 'dataProcessingService' property from [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}).\n *\n * Also includes a 'type' property that indicates whether the consent decision is IMPLICIT or EXPLICT.\n *\n * @static\n * @type {array}\n * @name ConsentDecision\n * @memberof! &lt;global&gt;\n * @property {string} type the type of consent, will be either 'implicit' or 'explicit'\n * @example\nvar exampleConsentDecision = window.tealiumCmpIntegration.getCurrentConsentDecision()\n\nJSON.stringify(exampleConsentDecision)\n// [&quot;Google Analytics&quot;,&quot;Another Tag&quot;,&quot;Tealium iQ Tag Management&quot;]\n\nexampleConsentDecision.type\n// &quot;explicit&quot;\n\nexampleConsentDecision.length\n// 3\n */\n\n/**\n * Assigns Tealium iQ Tags to Usercentrics Service Names. Each service can have multiple tags, but each tag can only have one service.  If the same tag UID appears in multiple Service arrays, only one will be used.\n *\n * The keys for the main object are Setting-IDs from Usercentrics, inside that are key/value pairs where the key is a Service Name from Usercentrics, and the value is an array of TagUIDs from Tealium iQ.\n *\n * This needs to be provided as per the example below, in [tealiumCmpIntegration.map]{@link namespace:tealiumCmpIntegration~map}.\n *\n * An [example Tealium iQ extension]{@link module:example-map} is provided as well.\n *\n * @static\n * @type {object}\n * @name ServiceToTagMap\n * @memberof! &lt;global&gt;\n * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n  'yPyIAIIxY': {\n    'Google Analytics': [6, 8, 10],\n    'Mouseflow': [7, 9],\n    'Another Tag': [11]\n  }\n}\n */\n\n/**\n * A simple lookup, with Tealium iQ tag UIDs as keys and the associated Usercentrics service name as strings as values. Each service can be associated with multiple tags, but each tag can be associated with one service.\n *\n * The example is based on the {@link ServiceToTagMap ServiceToTagMap} example, where the Usercentrics settingsId on the active page is 'yPyIAIIxY'.\n *\n * This object is automatically generated by the [getTagBasedMap]{@link module:extension-1~getTagbasedMap} method, and made available globally in [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration~tagBasedMap} for debugging and use within the extensions.\n *\n * @static\n * @type {object}\n * @name TagToServiceMap\n * @memberof! &lt;global&gt;\n * @example\n{\n  6: 'Google Analytics',\n  7: 'Mouseflow',\n  8: 'Google Analytics',\n  9: 'Mouseflow',\n  10: 'Google Analytics',\n  11: 'Another Tag'\n}\n */\n\n/**\n * An object from the [implicitEventQueue]{@link tealiumCmpIntegration.implicitEventQueue} or [earlyEventQueue]{@link tealiumCmpIntegration.earlyEventQueue}, which represents a Tealium iQ tracking event that's been processed based on an IMPLICIT [ConsentDecision]{@link ConsentDecision}\n *\n * Heavily based on the argument passed to [utag.track]{@link https://community.tealiumiq.com/t5/Tealium-iQ-Tag-Management/utag-track-method/td-p/24578}, since it's designed to be processed by that method.\n *\n * Initial pageviews (handled in the [utag.loader.initdata override]{@link module:extension-1~newUtagLoaderInitdata}) will NOT have metadata like cookies, qps, etc - utag.track calls (handled in the [utag.handler.trigger override]{@link module:extension-1~newUtagHandlerTrigger}) will. That's a byproduct of using utag.handler.trigger, which is later in the load - those metadata will be re-read when the queue is processed, and since this queue isn't persisted between pages, it should be fine like that - the only strange behavior will be that any metadata that aren't present on re-read will still be present after the re-read - only values that are still present will be replaced with new values.\n *\n * An alternative approach could be to manually remove 'cp.\\*', 'dom.\\*', 'ut.\\*', 'qp.\\*', 'meta.\\*' and possibly 'tealium_\\*' (except 'tealium_event') from the 'data' object before queueing - that hasn't been done so far.\n *\n * @static\n * @type {array}\n * @name QueuedEvent\n * @memberof! &lt;global&gt;\n * @property {string} event the type of tracking event, generally 'view' for pageviews or 'link' for other events\n * @property {object} data the Universal Data Object associated with the event (from utag_data or the b object)\n * @property {object} cfg an optional configuration object that can have a 'cb' property (for a callback function) and a 'uids' array, which is a list of tag UIDs that should be triggered by the event, regardless of whether load rules are met.\n * @example\n{\n  &quot;event&quot;: &quot;view&quot;,\n  &quot;data&quot;: {\n    &quot;page_type&quot;: &quot;test_virtual_view&quot;,\n    &quot;cp.utag_main_v_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;cp.utag_main__sn&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__se&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__ss&quot;: &quot;0&quot;,\n    &quot;cp.utag_main__st&quot;: &quot;1598990152209&quot;,\n    &quot;cp.utag_main_ses_id&quot;: &quot;1598988112353&quot;,\n    &quot;cp.utag_main__pn&quot;: &quot;3&quot;,\n    &quot;cp.utagdb&quot;: &quot;true&quot;,\n    &quot;dom.referrer&quot;: &quot;&quot;,\n    &quot;dom.title&quot;: &quot;Usercentrics Test&quot;,\n    &quot;dom.domain&quot;: &quot;solutions.tealium.net&quot;,\n    &quot;dom.query_string&quot;: &quot;&quot;,\n    &quot;dom.hash&quot;: &quot;&quot;,\n    &quot;dom.url&quot;: &quot;https://solutions.tealium.net/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.pathname&quot;: &quot;/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.viewport_height&quot;: 456,\n    &quot;dom.viewport_width&quot;: 1825,\n    &quot;ut.domain&quot;: &quot;tealium.net&quot;,\n    &quot;ut.version&quot;: &quot;ut4.46.202009011921&quot;,\n    &quot;ut.event&quot;: &quot;view&quot;,\n    &quot;ut.visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;ut.session_id&quot;: &quot;1598988112353&quot;,\n    &quot;ut.account&quot;: &quot;services-caleb&quot;,\n    &quot;ut.profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;ut.env&quot;: &quot;prod&quot;,\n    &quot;tealium_event&quot;: &quot;view&quot;,\n    &quot;tealium_visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;tealium_session_id&quot;: &quot;1598988112353&quot;,\n    &quot;tealium_session_number&quot;: &quot;4&quot;,\n    &quot;tealium_session_event_number&quot;: &quot;4&quot;,\n    &quot;tealium_datasource&quot;: &quot;&quot;,\n    &quot;tealium_account&quot;: &quot;services-caleb&quot;,\n    &quot;tealium_profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;tealium_environment&quot;: &quot;prod&quot;,\n    &quot;tealium_random&quot;: &quot;2085060854215077&quot;,\n    &quot;tealium_library_name&quot;: &quot;utag.js&quot;,\n    &quot;tealium_library_version&quot;: &quot;4.46.0&quot;,\n    &quot;tealium_timestamp_epoch&quot;: 1598988352,\n    &quot;tealium_timestamp_utc&quot;: &quot;2020-09-01T19:25:52.211Z&quot;,\n    &quot;tealium_timestamp_local&quot;: &quot;2020-09-01T21:25:52.211&quot;,\n    &quot;usercentrics_services_with_consent&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ],\n    &quot;usercentrics_consent_type&quot;: &quot;implicit&quot;,\n    &quot;_usercentrics_services_already_processed&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ]\n  },\n  &quot;cfg&quot;: {\n    &quot;cb&quot;: function myCallback () {console.log(&quot;Callback fired!&quot;)},\n    &quot;uids&quot;: [\n      11\n    ],\n    &quot;originalUids&quot;: [\n      7,\n      11\n    ],\n    &quot;blockedTagUids&quot;: [\n      11\n    ]\n  }\n}\n*/\n","promotedBy":"caleb.jaquith@tealium.com","promotedDraftName":"extension-1.js","promotedTimestamp":"202010290930"}},"draftSeq":"0","queueSeq":"14","draftSnippets":{"6c3a4d93e5d76b6b1c0a00bfab0af321b9385601e6c79418fac3a5d10efdc9c9":{"versionControl":{"isReadOnly":"true","sourceUrl":"https://github.com/jaquith/usercentrics-integration/blob/test/extensions/extension-1.js","accountName":"jaquith","lastSyncTimeStamp":"202010290929","sourceName":"GitHub","lastSyncSuccess":"true","isOutdated":"false","hashValue":"a33123fde5698c23d941d5c8fdf32dff4bf62e6f"},"updatedBy":"caleb.jaquith@tealium.com","creationDate":"202010050842","updateDate":"202010290901","name":"extension-1.js","code":"/**\n *  Scope       : Pre Loader\n *  Condition   : n/a\n *  Description : CMP 1/2 - Preloader component - prevent TiQ from loading if no consent, queue implicitly consented events to retrigger (for new tags only) if explicit decision is made.\n */\n\n/**\n  * @module extension-1\n  *\n  * @description The 'Pre Loader' extension component of the CMP integration, responsible for stopping Tealium iQ from loading/running as appropriate, and making certain\n  * window-scoped functions available to the other components.\n  */\n\n// Tealium iQ runs Pre Loader extensions in global scope, which would make all variables global. We don't want to do that.\n(function avoidGlobalScopeUnlessExplicit () {\n  // set names for key objects and variables to make them easy to change if needed\n\n  var version = 'v0.10-beta'\n\n  // for the consent information in the b object\n  var nameOfVendorOptInArray = 'usercentrics_services_with_consent'\n  var nameOfConsentTypeString = 'usercentrics_consent_type'\n\n  // for the name in the queue\n  var nameOfImplicitConsentArray = '_usercentrics_services_already_processed'\n\n  // name to use when calling utag.handler.trigger to indicate a consent polling call\n  var nameOfConsentPollingEvent = 'tiq_usercentrics_consent_polling'\n\n  var consentTimeoutInterval = 400 // setTimeout interval in MS - rate to poll for new (explicit) consent decision or correctly formed object\n\n  // check for the Tealium Debug cookie, see https://docs.tealium.com/platforms/javascript/debugging/\n  var tiqInDebugMode = /utagdb=true/.test(document.cookie)\n  var tealiumEnvironment = getTealiumEnvironment() || 'prod' // fall back to prod (stops logging) if something goes wrong with the function\n\n  /**\n   * A window-scoped (global) object used to expose selected functionality.\n   *\n   * @namespace tealiumCmpIntegration\n   * @type {object}\n   * @memberof! &lt;global&gt;\n   */\n  window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\n\n  /**\n   * The name of the CMP (&quot;Usercentrics Vanilla App&quot; in this case).\n   * @name cmpName\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.cmpName = 'Usercentrics Vanilla App'\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link ServiceToTagMap ServiceToTagMap}\n   * @name map\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  var map = window.tealiumCmpIntegration.map || {}\n\n  /**\n   * A map of Usercentrics Data Processing Services to arrays of Tealium iQ tag UIDs, a {@link TagToServiceMap TagToServiceMap}\n   * @name tagBasedMap\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   */\n  generateTagBasedMap() // populates the window-level object for you as well\n\n  /**\n   * The Service Name for Tealium iQ in Usercentrics (used to decide if the TMS is allowed to run).  Uses the Usercentrics standard name if not provided.\n   * @name tiqServiceName\n   * @type {object}\n   * @memberof! tealiumCmpIntegration\n   * @default 'Tealium iQ Tag Management'\n   * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.tiqServiceName = &quot;Tealium iQ Tag Management&quot;\n   */\n  var tiqServiceName = window.tealiumCmpIntegration.tiqServiceName || 'Tealium iQ Tag Management' // use the standard name here if not set\n\n  /**\n   * The current version designation.\n   * @name version\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.version = version\n\n  /**\n   * A [logger helper function]{@link module:extension-1~logger}, to help Tealium iQ users understand and troubleshoot this CMP integration without unneeded logging in production.\n   * @name logger\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.logger = logger\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentConsentDecision} that returns the current [ConsentDecision]{@link ConsentDecision}.\n   * @name getCurrentConsentDecision\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentConsentDecision = getCurrentConsentDecision\n\n  /**\n   * A [helper function]{@link module:extension-1~getCurrentUsercentricsSettingsId} that returns the current Usercentrics settingsId.\n   * @name getCurrentUsercentricsSettingsId\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.getCurrentUsercentricsSettingsId = getCurrentUsercentricsSettingsId\n\n  /**\n   * Records the status of the [noview]{@link https://docs.tealium.com/platforms/javascript/settings/#noview} setting on page load.\n   * @name isNoviewSet\n   * @type {boolean}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.isNoviewSet = window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noview === true\n\n  /**\n   * The name to use for the [ConsentDecision]{@link ConsentDecision} array when adding it to Tealium's b object on each event.\n   * @name nameOfVendorOptInArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfVendorOptInArray = nameOfVendorOptInArray\n\n  /**\n   * The name to use for the current [ConsentDecision]{@link ConsentDecision}'s 'type' attribute when adding it to Tealium's b object on each event.\n   * @name nameOfConsentTypeString\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfConsentTypeString = nameOfConsentTypeString\n\n  /**\n   * The name to use for the array of implicit tags (which have already been fired) in the 'data' property of {@link QueuedEvent QueuedEvent} objects.\n   * @name nameOfImplicitConsentArray\n   * @type {string}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.nameOfImplicitConsentArray = nameOfImplicitConsentArray\n\n  /**\n   * A [helper function]{@link module:extension-1~overrideUtagFunctions} that overrides certain utag functions to allow tags to be blocked based on CMP response.\n   *\n   * Must be called directly after the '##UTGEN##' reference by [editing]{@link https://community.tealiumiq.com/t5/iQ-Tag-Management/Managing-Tag-Templates/ta-p/21713} the 'utag loader' template, as shown in the example.\n   * @name overrideUtagFunctions\n   * @type {function}\n   * @memberof! tealiumCmpIntegration\n   * @example\n// ... utag loader template ...\n\n##UTGEN##\n// override two utag functions for the Usercentrics CMP Integration, to allow tags to be blocked as needed\nwindow.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions &amp;&amp; window.tealiumCmpIntegration.overrideUtagFunctions()\n\n// ... utag loader template continues...\n\n   */\n  window.tealiumCmpIntegration.overrideUtagFunctions = overrideUtagFunctions\n\n  /**\n   * A queue for any events that Tealium iQ processes with IMPLICIT consent (to allow those events to be re-processed for new Services in the event of an EXPLICIT consent choice by the user).\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name implicitEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n\n  /**\n   * A queue for any events that are triggered before Tealium iQ AND Usercentrics have both loaded.\n   *\n   * Each element in the queue is a [QueuedEvent]{@link QueuedEvent}\n   * @name earlyEventQueue\n   * @type {array}\n   * @memberof! tealiumCmpIntegration\n   */\n  window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n\n  /**\n   * Allows us to make sure we don't log certain messages more than once, especially useful while polling to avoid overwhelming the user.\n   * @function messageNotLoggedYet\n   * @param {*} messageId a string or number to uniquely identify a message for the purposes of deduplication\n   * @returns {boolean} 'true' if the message hasn't been logged yet (and should be logged), otherwise 'false'\n   */\n  var alreadyLoggedMessageIds = {}\n  function messageNotLoggedYet (messageId) {\n    var output = false\n    if (typeof alreadyLoggedMessageIds[messageId] === 'undefined') {\n      alreadyLoggedMessageIds[messageId] = true\n      output = true\n    }\n    return output\n  }\n\n  // if noload is set to 'true', don't interfere, just return to exit this function and allow that setting to stop TiQ load as usual.\n  if (window.utag_cfg_ovrd &amp;&amp; window.utag_cfg_ovrd.noload === true) return false\n\n  logger('CMP integration active - Usercentrics/TiQ' + (tiqInDebugMode ? &quot;\\n\\nDEBUGGING TIP: Use /SENDING|\\\\*\\\\*\\\\*\\\\*/ in the browser console as the 'filter' to show only CMP and tag send notifications.&quot; : '\\n\\nActivate TiQ Debug Mode for more details: https://docs.tealium.com/platforms/javascript/debugging/'), true)\n  var cmpResponse = cmpConsentCheck()\n  // core business/GDPR logic, decides if TiQ should load at all\n  reactToCmpResponse(cmpResponse)\n\n  /**\n   * The core CMP integration logic, which decides if Tealium iQ should be allowed to run, or if it needs to be stopped\n   * until an understandable response that includes permission for Tealium iQ to run is found.\n   *\n   * @function reactToCmpResponse\n   * @param {object} cmpResponse The response from the Usercentrics Vanilla App\n   */\n  function reactToCmpResponse (cmpResponse) {\n    var usercentricsFound = typeof cmpResponse === 'object'\n    var foundWellFormedConsentDecision = checkForWellFormedDecision(cmpResponse)\n    var tagBasedMap = generateTagBasedMap()\n    var foundMapEntryForActiveSetting = Object.keys(tagBasedMap).length &gt; 0\n    var foundExplicitConsent = checkForExplicitConsentDecision(cmpResponse)\n    var tiqIsAllowedToFire = checkForTiqConsent(cmpResponse)\n    var tiqIsLoaded = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!usercentricsFound) {\n      /**\n       * CASE A1: no Usercentrics CMS found\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(1)) logger('No Usercentrics CMP found on page.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundMapEntryForActiveSetting) {\n      /**\n        * CASE A7: No map found for the current settingsId\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(2)) logger('No map found for current Usercentrics Setting ID.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    } else if (!foundWellFormedConsentDecision) {\n      /**\n       * CASE A2: Usercentrics CMS found but consent response wasn't well-formed/complete/understandable\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(3)) logger('Found Usercentrics CMP and got response, but didn\\'t understand the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!tiqIsAllowedToFire) {\n      /**\n       * CASE A3: Usercentrics CMS found and consent response was well-formed, BUT TiQ didn't have an opt-in\n       *\n       * STOP and fire nothing at all\n       * RETRY after a delay\n       */\n      if (messageNotLoggedYet(4)) logger('Found Usercentrics CMP and got well-formed response, but TiQ isn\\'t allowed to run based on the response.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      stopTiq()\n    } else if (!foundExplicitConsent) {\n      /**\n       * CASE A4: Usercentrics CMS found AND response was understandable (AND includes an implicit TiQ consent), BUT the user hasn't made an explicit decision yet\n       *\n       * ALLOW TO LOAD for any 'default opt-in' tags (filter logic in Extension B)\n       * RETRY after a delay (in case there's an explicit decision, since implicit decisions usually mean the prompt is displayed)\n       */\n      if (messageNotLoggedYet(5)) logger('Found Usercentrics CMP and got well-formed IMPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on IMPLICIT consent.\\n\\nPolling for changes.')\n      window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else if (foundExplicitConsent) {\n      /**\n       * CASE A5: Usercentrics CMS found AND response was understandable, AND the user has made an explicit consent decision AND TiQ is allowed\n       *\n       * ALLOW TO LOAD for any opted-in tags (filter logic in Extension B), do not retry.\n       */\n      if (messageNotLoggedYet(6)) logger('Found Usercentrics CMP and got well-formed EXPLICIT response which includes TiQ.\\n\\nAllowing certain tags to fire based on EXPLICIT consent.\\n\\nNo further polling.')\n      // only call if we've been polling (on initial load, it will load automatically)\n      if (tiqIsLoaded) {\n        processEarlyQueue()\n        processImplicitQueue()\n      } else {\n        window.setTimeout(recheckForCmpAndConsent, consentTimeoutInterval)\n      }\n      triggerOrQueue()\n    } else {\n      /**\n        * CASE A6: Something went wrong with this extension.\n        *\n        * STOP and fire nothing at all. Do not retry.\n        */\n      if (messageNotLoggedYet(7)) logger('Something unexpected went wrong.\\n\\nStopping TiQ (no cookies set/removed, no tags fired).\\n\\nNo retries.')\n      stopTiq()\n    }\n  }\n\n  /**\n   * Override utag.loader.initdata and utag.handler.trigger to allow Tealium iQ Tags to be blocked if the user hasn't consented.\n   *\n   * @function overrideUtagFunctions\n   * @returns {boolean} 'true' if the function was overridden successfully by this request, 'false' if not (because it was already overridden)\n   */\n  function overrideUtagFunctions () {\n    // don't override more than once, assume that if one function has been overridden, both have\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    // the initial view is handled differently than subsequent events\n    // this is safe to to override even if noview is set (because it will never be called in that case)\n    window.utag.loader.initdata_old = window.utag.loader.initdata\n    window.utag.loader.initdata = newUtagLoaderInitdata\n\n    window.utag.handler.trigger_old = window.utag.handler.trigger\n    window.utag.handler.trigger = newUtagHandlerTrigger\n    logger('Overrode utag functions!')\n\n    if (window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1) {\n      return true\n    }\n\n    return false\n  }\n\n  /**\n   * An overridden version of the Tealium iQ function utag.loader.initdata.\n   *\n   * Calls the original function, respects possible noview settings, rechecks the user consent, and calls queueEventWithoutFiringImplicitServices\n   * if only an IMPLICIT consent is found (after recording the IMPLICIT services, to avoid double-firing).\n   *\n   * That same event can then be re-processed for any new Services if an EXPLICIT consent decision later made.\n   *\n   * @function newUtagLoaderInitdata\n   */\n  function newUtagLoaderInitdata () {\n    window.utag.loader.initdata_old()\n    // make sure we don't queue this initial page load twice, and respect the configured noview setting\n    if (!window.tealiumCmpIntegration.isNoviewSet &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n      window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n      var consentedServices = getCurrentConsentDecision()\n      if (consentedServices.type === 'implicit') {\n        window.tealiumCmpIntegration.implicitServices = consentedServices\n        // we don't need to fire implicit services in this case, because TiQ's loading process will fire them\n        queueEventWithoutFiringImplicitServices({\n          event: 'view',\n          data: window.utag.handler.C(window.utag.data)\n        })\n      }\n    }\n  }\n\n  /**\n   * Refresh [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration.tagBasedMap} and return that new map, helps smooth out any timing issues between Usercentrics and Tealium iQ load.\n   *\n   * @function generateTagBasedMap\n   * @returns a [TagToServiceMap]{@link TagToServiceMap}\n   */\n  function generateTagBasedMap () {\n    var tagBasedMap = getTagBasedMap(map)\n    window.tealiumCmpIntegration.tagBasedMap = tagBasedMap\n    return tagBasedMap\n  }\n\n  /**\n   * Tealium iQ's utag.handler.trigger normally causes tags to fire. For this integration, we override that function to support blocking tags without consent.\n   *\n   * @function newUtagHandlerTrigger\n   *\n   * @param {*} a can be an object or a string\n   * @param {*} b\n   * @param {*} c\n   */\n  function newUtagHandlerTrigger (a, b, c) {\n    /**\n     * Trigger CASES (utag.handler.trigger override)\n     *\n     * We need to queue the events if we only have implicit consent, to allow a selective retrigger if/when we get an explicit decision.\n     */\n    var isPureConsentEvent = (a === nameOfConsentPollingEvent &amp;&amp; !b &amp;&amp; !c)\n    var isNoviewSet = window.tealiumCmpIntegration.isNoviewSet || true // assume noview if something went wrong with the global, to avoid firing tracking in error\n\n    var consentedServices = getCurrentConsentDecision()\n    var consentType = (consentedServices &amp;&amp; consentedServices.type) || 'none'\n\n    var isUsercentricsReady = consentType === 'implicit' || consentType === 'explicit'\n    var isTealiumReady = window.utag &amp;&amp; window.utag.handler &amp;&amp; window.utag.handler.iflag === 1\n\n    if (!isPureConsentEvent) {\n      logger('utag.handler.trigger called with:\\n\\n' + JSON.stringify(arguments, null, 2))\n    }\n\n    if (!isUsercentricsReady &amp;&amp; !isTealiumReady) {\n      consentedServices.type = 'tealium-and-usercentrics-loading'\n      logger('Waiting for Usercentrics and Tealium to be ready, queueing early event.')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isUsercentricsReady) {\n      consentedServices.type = 'usercentrics-loading'\n      logger('Usercentrics is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    } else if (!isTealiumReady) {\n      consentedServices.type = 'tealium-still-loading'\n      logger('Tealium iQ is still loading, queueing early event')\n      queueEarlyEvent(a, b, c)\n      return false\n    }\n\n    // if an array of tagUids is passed, that forces them to fire regardless of load rules\n    // or consent, so we need to filter that array before allowing it to be processed\n    var hasTagUidArray = c &amp;&amp; typeof c === 'object' &amp;&amp; c.uids &amp;&amp; c.uids &amp;&amp; window.utag.ut.typeOf(c.uids) === 'array'\n    var uidMap = generateTagBasedMap()\n    var allowedTagUids = []\n    var blockedTagUids = []\n    var serviceName\n    var tagUid\n    if (hasTagUidArray) {\n      for (var i = 0; i &lt; c.uids.length; i++) {\n        tagUid = c.uids[i]\n        serviceName = uidMap[tagUid] || '(missing)'\n        // only push consented services into the new array\n        if (consentedServices.indexOf(serviceName) !== -1) {\n          allowedTagUids.push(tagUid)\n        } else {\n          blockedTagUids.push(tagUid)\n        }\n      }\n      // replace the original with the filtered array (can also be empty, if none of them were allowed)\n      logger('Call included tagUid array:\\n\\n' + JSON.stringify(c.uids) + '\\n\\nwhich was replaced by the filtered version:\\n\\n' + JSON.stringify(allowedTagUids))\n      c.originalUids = c.uids.slice() // make a shallow copy\n      c.uids = allowedTagUids\n      c.blockedTagUids = blockedTagUids\n    }\n\n    if (consentType === 'explicit') {\n      /**\n       * CASE T2: expected globals are populated, consent is EXPLICIT\n       *\n       * FIRE allowed tags (explicit)\n       * utag.handler.trigger override PROCESSES the queue, which will include any queued events from CASE A4, making sure not to re-fire any default\n       *   opt-in tags that were already fired for the queued events\n       */\n      // make sure TiQ loads\n      processEarlyQueue()\n      processImplicitQueue()\n      triggerTiqLoad()\n      // fire the current event if it's not just a polling event\n      if (!isPureConsentEvent) {\n        return window.utag.handler.trigger_old(a, b, c)\n      }\n    } else if (consentType === 'implicit') {\n      /**\n       * CASE T3: expected globals are populated, consent is IMPLICIT\n       *\n       * FIRE allowed tags (implicit)\n       * utag.handler.trigger override KEEPS a queue/record that includes\n       *  - the event(s) that were processed based on implicit consent\n       *  - which tags were allowed to process each event (are set to implicit opt-in)\n       */\n      processEarlyQueue()\n      // fire the initial view if appropriate, and queue it\n      triggerTiqLoad()\n      window.tealiumCmpIntegration.implicitServices = consentedServices\n\n      // queue the initial 'view' on pageload if appropriate\n      if (!isNoviewSet &amp;&amp; isTealiumReady &amp;&amp; !window.tealiumCmpIntegration.alreadyFiredInitialViewEvent) {\n        window.tealiumCmpIntegration.alreadyFiredInitialViewEvent = true\n        queueEventAndFireImplicitServices('view', window.utag.handler.C(window.utag.data))\n      }\n      // queue the current event if it exists (and this isn't just consent polling)\n      if (!isPureConsentEvent) {\n        return queueEventAndFireImplicitServices(a, b, c)\n      }\n    } else if (consentType === 'missing-map') {\n      logger('Something went wrong - all tags were blocked because no consent map was found for the active setting ID.')\n      return false\n    } else if (consentType === 'missing-tiq-consent') {\n      logger('Something went wrong - all tags were blocked because no consent was found for &quot;' + tiqServiceName + '&quot;, configured Tealium iQ name.\\n\\nConsent found: ' + JSON.stringify(consentedServices, null, 2))\n      return false\n    } else {\n      /**\n       * CASE T1: expected variables not populated (misconfiguration/error case)\n       *\n       * STOP and fire nothing at all. Do not retry or queue the event.\n       */\n      logger('Something went wrong - all tags were blocked because the consent response was not understood.')\n      return false\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the early event queue]{@link tealiumCmpIntegration.earlyEventQueue} (can include pageviews) for any currently-consented Services.\n   *\n   * Intended to be called first understandable implicit consent.\n   *\n   * @function processEarlyQueue\n   */\n  function processEarlyQueue () {\n    var queuedEvent\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    while (window.tealiumCmpIntegration.earlyEventQueue.length &gt; 0) {\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.earlyEventQueue.shift()\n      logger('Processing queued early event for currently consented tags: ' + JSON.stringify(queuedEvent, null, 2))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Process any queued tracking events from [the global queue]{@link tealiumCmpIntegration.implicitEventQueue} (can include pageviews) for any newly-consented Services.\n   *\n   * Intended to be called on new EXPLICIT consent decision - queued events have already had IMPLICTLY consented tags fired, so those need to be excluded.\n   *\n   * @function processImplicitQueue\n   */\n  function processImplicitQueue () {\n    var alreadyLogged = false\n    var queuedEvent\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    while (window.tealiumCmpIntegration.implicitEventQueue.length &gt; 0) {\n      if (!alreadyLogged) {\n        alreadyLogged = true\n        logger('Explicit consent tracking request received - processing past implicitly tracked events (' + window.tealiumCmpIntegration.implicitEventQueue.length + ') for any new explicit tags.')\n      }\n      // process past events\n      queuedEvent = window.tealiumCmpIntegration.implicitEventQueue.shift()\n      logger('Triggering event for explicitly-consented tags: ' + JSON.stringify(queuedEvent))\n      window.utag.track(queuedEvent)\n    }\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the early queue]{@link tealiumCmpIntegration.earlyEventQueue}, without firing any tags.\n   *\n   * Intended to be called for events that triggered before we get an understandable response from Usercentrics.\n   *\n   * @function queueEarlyEvent\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEarlyEvent (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    // nothing will be allowed to fire\n    a.data[nameOfImplicitConsentArray] = []\n\n    window.tealiumCmpIntegration.earlyEventQueue = window.tealiumCmpIntegration.earlyEventQueue || []\n    window.tealiumCmpIntegration.earlyEventQueue.push(a)\n    logger('Queued early event!')\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration.implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for the initial pageview on load, since the load process will have already fired the implicit services.\n   *\n   * @function queueEventWithoutFiringImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventWithoutFiringImplicitServices (a, b, c) {\n    a = a || {}\n\n    // make a copy, in case shared objects are used (like utag_data, or a similar global) - snapshot those\n    if (typeof b === 'object') {\n      b = JSON.parse(JSON.stringify(b))\n    }\n    // convert to a more standard format\n    if (typeof a === 'string') {\n      a = { event: a, data: b || {}, cfg: c }\n    }\n\n    // if there's a tagUid array, don't queue the already-fired tags - instead, swap that with any blocked tags\n    if (a &amp;&amp; a.cfg &amp;&amp; window.utag.ut.typeOf(a.cfg.uids) === 'array') {\n      a.cfg.uids = a.cfg.blockedTagUids.slice()\n    }\n\n    a.data[nameOfImplicitConsentArray] = window.tealiumCmpIntegration.implicitServices || []\n\n    window.tealiumCmpIntegration.implicitEventQueue = window.tealiumCmpIntegration.implicitEventQueue || []\n    window.tealiumCmpIntegration.implicitEventQueue.push(a)\n  }\n\n  /**\n   * Queue a [tracking event]{@link QueuedEvent} in [the global queue]{@link tealiumCmpIntegration~implicitEventQueue}, without firing any implictly consented Services.\n   *\n   * Intended to be called for all events other than the initial page load.\n   *\n   * @function queueEventAndFireImplicitServices\n   * @param {*} a the 'a' argument from utag.handler.trigger\n   * @param {*} b the 'b' argument from utag.handler.trigger\n   * @param {*} c the 'c' argument from utag.handler.trigger\n   *\n   */\n  function queueEventAndFireImplicitServices (a, b, c) {\n    // fire the implicit tags\n    window.utag.handler.trigger_old(a, b, c)\n    logger('Implicit consent tracking request fired (or queued, if utag hasn\\'t loaded).')\n    return queueEventWithoutFiringImplicitServices(a, b, c)\n  }\n\n  /**\n   * Generate a {@link TagToServiceMap TagToServiceMap} based on a {@link ServiceToTagMap ServiceToTagMap}\n   *\n   * @function getTagBasedMap\n   * @param {object} map a {@link ServiceToTagMap ServiceToTagMap} object\n   * @return {object} a {@link TagToServiceMap TagToServiceMap}\n   */\n  function getTagBasedMap (map) {\n    // generate a lookup based on the tagUid\n    if (typeof map !== 'object') return {}\n    var settingsId = getCurrentUsercentricsSettingsId() || ''\n    if (typeof settingsId !== 'string' || settingsId === '') return {}\n    var settingSpecificMap = map[settingsId] || {}\n    var serviceNames = Object.keys(settingSpecificMap)\n    var uidMap = {}\n    for (var i = 0; i &lt; serviceNames.length; i++) {\n      for (var j = 0; j &lt; settingSpecificMap[serviceNames[i]].length; j++) {\n        uidMap[settingSpecificMap[serviceNames[i]][j]] = serviceNames[i]\n      }\n    }\n    return uidMap\n  }\n\n  /**\n   * Get the current Usercentrics settingsId from the page.\n   *\n   * @returns {string} the Usercentrics settingsId, defaults to an empty string if none is found\n   */\n  function getCurrentUsercentricsSettingsId () {\n    return (window.usercentrics &amp;&amp; window.usercentrics.settingsId) || ''\n  }\n\n  /**\n   * Trigger the core logic with an up-to-date array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   * @function recheckForCmpAndConsent\n   */\n  function recheckForCmpAndConsent () {\n    var newConsentResponse = cmpConsentCheck()\n    reactToCmpResponse(newConsentResponse)\n  }\n\n  /**\n   * Call [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents} to get the current consent decision.\n   * @function cmpConsentCheck\n   */\n  function cmpConsentCheck () {\n    if (!window.usercentrics || typeof window.usercentrics.getConsents !== 'function') return false\n    var cmpConsentArray = window.usercentrics.getConsents()\n    return cmpConsentArray\n  }\n\n  /**\n   * Indicates if Usercentrics has loaded and returned a well-formed indication of user consent.\n   * @function checkForWellFormedDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is well-formed, otherwise 'false'\n   */\n  function checkForWellFormedDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; typeof cmpConsentArray[0].dataProcessingService === 'string') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if the user has made an EXPLICIT decision\n   * @function checkForExplicitConsentDecision\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if the consent decision is EXPLICIT otherwise 'false'\n   */\n  function checkForExplicitConsentDecision (cmpConsentArray) {\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // use the first entry as a proxy for all\n    if (cmpConsentArray &amp;&amp; cmpConsentArray[0] &amp;&amp; cmpConsentArray[0].updatedBy === 'explicit') {\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Indicates if Tealium iQ has permission to run (and fire tags).\n   * @function checkForTiqConsent\n   * @param cmpConsentArray the array of objects returned by [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}.\n   * @returns {boolean} 'true' if TiQ is allowed to run, otherwise 'false'\n   */\n  function checkForTiqConsent (cmpConsentArray) {\n    var foundOptIn = false\n    // treat things we don't understand as an opt-out\n    if (toString.call(cmpConsentArray) !== '[object Array]') return false\n    // check vendors if there's an object, look for at least one\n    cmpConsentArray.forEach(function (tagInfo) {\n      if (tagInfo.consentStatus === true &amp;&amp; tagInfo.dataProcessingService === tiqServiceName) {\n        foundOptIn = true\n      }\n    })\n    return foundOptIn\n  }\n\n  /**\n   * Create an instance of\n   * @param {array} cmpConsentArray the array of objects returned by calling [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}\n   */\n  function getVendorConsentsFromCmpConsentArray (cmpConsentArray) {\n    var vendorArray = []\n\n    var isWellFormed = checkForWellFormedDecision(cmpConsentArray)\n\n    if (!isWellFormed) {\n      vendorArray.type = 'missing-well-formed-response'\n      return []\n    }\n\n    var tagBasedMap = generateTagBasedMap()\n\n    // if there is no mapping for the settings id, we need to change the console output\n    var currentSettingsIdHasMapping = (typeof tagBasedMap === 'object' &amp;&amp; Object.keys(tagBasedMap).length &gt; 0)\n\n    if (!currentSettingsIdHasMapping) {\n      vendorArray.type = 'missing-map'\n      return []\n    }\n\n    cmpConsentArray &amp;&amp; cmpConsentArray.forEach(function (tagConsent) {\n      if (tagConsent.consentStatus === true) {\n        vendorArray.push(tagConsent.dataProcessingService)\n      }\n    })\n    vendorArray.type = checkForExplicitConsentDecision(cmpConsentArray) ? 'explicit' : 'implicit'\n\n    if (checkForTiqConsent(cmpConsentArray) === false) {\n      // change the consent type, but leave the array for debugging purposes\n      vendorArray.type = 'missing-tiq-consent'\n    }\n\n    return vendorArray\n  }\n\n  /**\n   * Get the current consent decision from the CMP for the active Setting\n   * @function getCurrentConsentDecision\n   * @returns a {@link ConsentDecision ConsentDecision}\n   */\n  function getCurrentConsentDecision () {\n    var freshConsent = cmpConsentCheck()\n\n    return getVendorConsentsFromCmpConsentArray(freshConsent)\n  }\n\n  /**\n   *  A conditional logging function - we can't use utag.DB directly because some of our logic needs to be preloader, but we can mimic the same logic so that our logging only displays when TiQ is in debug mode and/or not in Prod, or is explicitly forced.\n   * @function logger\n   * @param {string} message the message to be conditionally shown\n   * @param {boolean} showOutsideDebugMode if 'true', forces the message to shown outside of debug mode, except on Prod\n   */\n  function logger (message, showOutsideDebugMode) {\n    if (typeof tealiumEnvironment === 'undefined' || tealiumEnvironment === 'prod') {\n      // don't allow anything outside of debug mode on prod (disable this flag)\n      showOutsideDebugMode = false\n    }\n\n    if (showOutsideDebugMode || tiqInDebugMode) {\n      message = '\\n' + message + '\\n'\n      var formattedArr = []\n      formattedArr.push('****************')\n      var messageArr = message.split('\\n')\n      messageArr.forEach(function (messageLine) {\n        formattedArr.push('*  ' + messageLine)\n      })\n      formattedArr.push('****************')\n      var outputString = formattedArr.join('\\n')\n      console.log(outputString)\n    }\n  }\n\n  /**\n   * Stops Tealium iQ from loading (the TMS will not load tags or set a cookie if this function is called in Pre Loader), using the {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} setting\n   * @function stopTiq\n   */\n  function stopTiq () {\n    // logger(&quot;stopTiq function fired&quot;)\n    window.utag_cfg_ovrd = window.utag_cfg_ovrd || {}\n    window.utag_cfg_ovrd.noload = true\n  }\n\n  /**\n   * Allows TiQ to finish loading, intended to be called when a well-formed consent response is received, and that response allows Tealium iQ to run.\n   *\n   * Works by setting {@link https://docs.tealium.com/platforms/javascript/settings/#noload noload} to 'false' and calling Tealium iQ's utag.loader.PINIT method.\n   *\n   * If noload was 'true' and this function runs it must've been set to true by our own {@link module:extension-1~stopTiq stopTiq} function, because otherwise Tealium iQ wouldn't have been allowed to load/poll in the first place.\n   * @function triggerTiqLoad\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function triggerTiqLoad () {\n    // if usercentrics is ready on the first request, TiQ won't have loaded yet at all - let it load naturally\n    if (!window.utag) {\n      return true\n    }\n    // if TiQ has already loaded but these flags aren't truthy, we've interrupted the load and should retrigger it\n    // initial load / view (noview logic handled in utag.handler.trigger function itself)\n    if (!window.utag.handler || !window.utag.handler.iflag) {\n      // we don't need to reload actually, just allow it to finish loading\n      window.utag.cfg.noload = false // safe because this code only runs if it was set to false originally\n      window.utag.loader.PINIT()\n      return true\n    }\n    // already loaded\n    return false\n  }\n\n  /**\n   * If Tealium iQ hasn't loaded, load it (calling utag.handler.trigger in the process), otherwise call utag.handler.trigger.\n   * @function triggerOrQueue\n   */\n  function triggerOrQueue () {\n    var successfullyTriggeredLoadIfNeeded = triggerTiqLoad()\n    if (!successfullyTriggeredLoadIfNeeded) {\n      // explicit consent from polling, but load has already been triggered\n      return window.utag.handler.trigger(nameOfConsentPollingEvent)\n    }\n  }\n  /**\n   * Get the the current Tealium iQ environment.\n   *\n   * Since this runs in Pre Loader, it needs to use regex to recognize the utag.js file in the DOM and read the environment from the file name (there are no utag functions or objects at this point in the load).\n   *\n   * NOTE: This doesn't work correctly when using the the Environment Switcher (because the original script is added to the DOM instead of the new one, and the 307 redirect that's used to pull the new file(s) only changes the response, not the script element itself).\n   *\n   * If you're using the Environment Switcher on Prod and would like to see console output, set the [debug cookie]{@link https://docs.tealium.com/platforms/javascript/debugging/}.\n   *\n   * @function getTealiumEnvironment\n   * @returns {boolean} 'true' if Tealium iQ was successfully triggered, 'false' if it wasn't triggered because it's already initiated\n   */\n  function getTealiumEnvironment () {\n    var allScripts = document.getElementsByTagName('script')\n    var re = /\\/([^/]*)\\/utag\\.js(\\?.*)*$/\n    for (var i = 0; i &lt; allScripts.length; i++) {\n      var result = re.exec(allScripts[i].src) // can be null\n      if (result &amp;&amp; result[1]) { // [1] is the result of the match\n        return result[1]\n      }\n    }\n    return 'prod' // default to guessing we're in prod, just in case we're actually in prod (to avoid logging in Prod)\n  }\n})()\n\n// Document key data structures here for clarity.\n\n/**\n * An array of Usercentrics Service Names that have permission to run (uses the 'dataProcessingService' property from [usercentrics.getConsents]{@link https://docs.usercentrics.com/#/?id=getconsents}).\n *\n * Also includes a 'type' property that indicates whether the consent decision is IMPLICIT or EXPLICT.\n *\n * @static\n * @type {array}\n * @name ConsentDecision\n * @memberof! &lt;global&gt;\n * @property {string} type the type of consent, will be either 'implicit' or 'explicit'\n * @example\nvar exampleConsentDecision = window.tealiumCmpIntegration.getCurrentConsentDecision()\n\nJSON.stringify(exampleConsentDecision)\n// [&quot;Google Analytics&quot;,&quot;Another Tag&quot;,&quot;Tealium iQ Tag Management&quot;]\n\nexampleConsentDecision.type\n// &quot;explicit&quot;\n\nexampleConsentDecision.length\n// 3\n */\n\n/**\n * Assigns Tealium iQ Tags to Usercentrics Service Names. Each service can have multiple tags, but each tag can only have one service.  If the same tag UID appears in multiple Service arrays, only one will be used.\n *\n * The keys for the main object are Setting-IDs from Usercentrics, inside that are key/value pairs where the key is a Service Name from Usercentrics, and the value is an array of TagUIDs from Tealium iQ.\n *\n * This needs to be provided as per the example below, in [tealiumCmpIntegration.map]{@link namespace:tealiumCmpIntegration~map}.\n *\n * An [example Tealium iQ extension]{@link module:example-map} is provided as well.\n *\n * @static\n * @type {object}\n * @name ServiceToTagMap\n * @memberof! &lt;global&gt;\n * @example\nwindow.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nwindow.tealiumCmpIntegration.map = {\n  'yPyIAIIxY': {\n    'Google Analytics': [6, 8, 10],\n    'Mouseflow': [7, 9],\n    'Another Tag': [11]\n  }\n}\n */\n\n/**\n * A simple lookup, with Tealium iQ tag UIDs as keys and the associated Usercentrics service name as strings as values. Each service can be associated with multiple tags, but each tag can be associated with one service.\n *\n * The example is based on the {@link ServiceToTagMap ServiceToTagMap} example, where the Usercentrics settingsId on the active page is 'yPyIAIIxY'.\n *\n * This object is automatically generated by the [getTagBasedMap]{@link module:extension-1~getTagbasedMap} method, and made available globally in [tealiumCmpIntegration.tagBasedMap]{@link tealiumCmpIntegration~tagBasedMap} for debugging and use within the extensions.\n *\n * @static\n * @type {object}\n * @name TagToServiceMap\n * @memberof! &lt;global&gt;\n * @example\n{\n  6: 'Google Analytics',\n  7: 'Mouseflow',\n  8: 'Google Analytics',\n  9: 'Mouseflow',\n  10: 'Google Analytics',\n  11: 'Another Tag'\n}\n */\n\n/**\n * An object from the [implicitEventQueue]{@link tealiumCmpIntegration.implicitEventQueue} or [earlyEventQueue]{@link tealiumCmpIntegration.earlyEventQueue}, which represents a Tealium iQ tracking event that's been processed based on an IMPLICIT [ConsentDecision]{@link ConsentDecision}\n *\n * Heavily based on the argument passed to [utag.track]{@link https://community.tealiumiq.com/t5/Tealium-iQ-Tag-Management/utag-track-method/td-p/24578}, since it's designed to be processed by that method.\n *\n * Initial pageviews (handled in the [utag.loader.initdata override]{@link module:extension-1~newUtagLoaderInitdata}) will NOT have metadata like cookies, qps, etc - utag.track calls (handled in the [utag.handler.trigger override]{@link module:extension-1~newUtagHandlerTrigger}) will. That's a byproduct of using utag.handler.trigger, which is later in the load - those metadata will be re-read when the queue is processed, and since this queue isn't persisted between pages, it should be fine like that - the only strange behavior will be that any metadata that aren't present on re-read will still be present after the re-read - only values that are still present will be replaced with new values.\n *\n * An alternative approach could be to manually remove 'cp.\\*', 'dom.\\*', 'ut.\\*', 'qp.\\*', 'meta.\\*' and possibly 'tealium_\\*' (except 'tealium_event') from the 'data' object before queueing - that hasn't been done so far.\n *\n * @static\n * @type {array}\n * @name QueuedEvent\n * @memberof! &lt;global&gt;\n * @property {string} event the type of tracking event, generally 'view' for pageviews or 'link' for other events\n * @property {object} data the Universal Data Object associated with the event (from utag_data or the b object)\n * @property {object} cfg an optional configuration object that can have a 'cb' property (for a callback function) and a 'uids' array, which is a list of tag UIDs that should be triggered by the event, regardless of whether load rules are met.\n * @example\n{\n  &quot;event&quot;: &quot;view&quot;,\n  &quot;data&quot;: {\n    &quot;page_type&quot;: &quot;test_virtual_view&quot;,\n    &quot;cp.utag_main_v_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;cp.utag_main__sn&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__se&quot;: &quot;4&quot;,\n    &quot;cp.utag_main__ss&quot;: &quot;0&quot;,\n    &quot;cp.utag_main__st&quot;: &quot;1598990152209&quot;,\n    &quot;cp.utag_main_ses_id&quot;: &quot;1598988112353&quot;,\n    &quot;cp.utag_main__pn&quot;: &quot;3&quot;,\n    &quot;cp.utagdb&quot;: &quot;true&quot;,\n    &quot;dom.referrer&quot;: &quot;&quot;,\n    &quot;dom.title&quot;: &quot;Usercentrics Test&quot;,\n    &quot;dom.domain&quot;: &quot;solutions.tealium.net&quot;,\n    &quot;dom.query_string&quot;: &quot;&quot;,\n    &quot;dom.hash&quot;: &quot;&quot;,\n    &quot;dom.url&quot;: &quot;https://solutions.tealium.net/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.pathname&quot;: &quot;/hosted/usercentrics/test-page-standard.html&quot;,\n    &quot;dom.viewport_height&quot;: 456,\n    &quot;dom.viewport_width&quot;: 1825,\n    &quot;ut.domain&quot;: &quot;tealium.net&quot;,\n    &quot;ut.version&quot;: &quot;ut4.46.202009011921&quot;,\n    &quot;ut.event&quot;: &quot;view&quot;,\n    &quot;ut.visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;ut.session_id&quot;: &quot;1598988112353&quot;,\n    &quot;ut.account&quot;: &quot;services-caleb&quot;,\n    &quot;ut.profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;ut.env&quot;: &quot;prod&quot;,\n    &quot;tealium_event&quot;: &quot;view&quot;,\n    &quot;tealium_visitor_id&quot;: &quot;0174492849d50013581219634d6103079004907101274&quot;,\n    &quot;tealium_session_id&quot;: &quot;1598988112353&quot;,\n    &quot;tealium_session_number&quot;: &quot;4&quot;,\n    &quot;tealium_session_event_number&quot;: &quot;4&quot;,\n    &quot;tealium_datasource&quot;: &quot;&quot;,\n    &quot;tealium_account&quot;: &quot;services-caleb&quot;,\n    &quot;tealium_profile&quot;: &quot;usercentrics-by-tag&quot;,\n    &quot;tealium_environment&quot;: &quot;prod&quot;,\n    &quot;tealium_random&quot;: &quot;2085060854215077&quot;,\n    &quot;tealium_library_name&quot;: &quot;utag.js&quot;,\n    &quot;tealium_library_version&quot;: &quot;4.46.0&quot;,\n    &quot;tealium_timestamp_epoch&quot;: 1598988352,\n    &quot;tealium_timestamp_utc&quot;: &quot;2020-09-01T19:25:52.211Z&quot;,\n    &quot;tealium_timestamp_local&quot;: &quot;2020-09-01T21:25:52.211&quot;,\n    &quot;usercentrics_services_with_consent&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ],\n    &quot;usercentrics_consent_type&quot;: &quot;implicit&quot;,\n    &quot;_usercentrics_services_already_processed&quot;: [\n      &quot;Mouseflow&quot;,\n      &quot;Tealium iQ Tag Management&quot;,\n      &quot;Usercentrics Consent Management Platform&quot;\n    ]\n  },\n  &quot;cfg&quot;: {\n    &quot;cb&quot;: function myCallback () {console.log(&quot;Callback fired!&quot;)},\n    &quot;uids&quot;: [\n      11\n    ],\n    &quot;originalUids&quot;: [\n      7,\n      11\n    ],\n    &quot;blockedTagUids&quot;: [\n      11\n    ]\n  }\n}\n*/\n"}}},"initialize":"","labels":"","id":"100040","title":"TEST 1/2","_id":"21","extType":"Javascript Code","selectedTargets":{"qa":"true","prod":"true","dev":"true"},"notes":"   Force...","sort":"8","publishedTargets":"dev","blockPubTargetsLogic":"true","type":"new"},"22":{"type":"new","blockPubTargetsLogic":"true","publishedTargets":"dev","sort":"9","notes":"Forceeee","selectedTargets":{"prod":"true","dev":"true","qa":"true"},"extType":"Javascript Code","_id":"22","title":"TEST 2/2","id":"100040","codeDevData":{"draftSeq":"0","promotedSnippets":{"3f3ef786b34d6dd716e1812c8b74a7a0e1f05aa5f3230588f6f5bcd00c6c8392":{"name":"qa","code":"/* global b */\n\n/**\n *  Scope       : All Tags - After Load Rules\n *  Condition   : n/a\n *  Description : CMP 2/2 - After Load Rules component - Prevent tags from firing if they don't have an opt-in in the mapping (or there is no mapping)\n *\n */\n\n/**\n * @module extension-2\n * @description The 'All Tags - After Load Rules' component, responsible for blocking tags if consent is missing or this CMP integration is misconfigured.\n */\n\nvar map = (window.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.map) || {}\n\n// get settings from CMP 1 extension, shouldn't need to change these\nvar globals = window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nvar tiqServiceName = globals.tiqServiceName || 'Tealium iQ Tag Management' // the default name for our Service in Usercentrics\n\nvar nameOfVendorOptInArray = globals.nameOfVendorOptInArray || 'missing_opt_in_array_name'\nvar nameOfConsentTypeString = globals.nameOfConsentTypeString || 'missing_consent_type_name'\nvar nameOfImplicitConsentArray = globals.nameOfImplicitConsentArray || 'missing_implicit_queue_array_name'\n\nvar tagBasedMap = globals.tagBasedMap || {}\n\nvar getCurrentConsentDecision = globals.getCurrentConsentDecision || function () { return [] }\nvar getCurrentUsercentricsSettingsId = globals.getCurrentUsercentricsSettingsId || function () { return '' }\n\nvar logger = globals.logger || (window.utag &amp;&amp; window.utag.DB) || function (message) { console.log(message) } // logger function with fallback in case global function is missing\n\n// recheck\nvar currentlyAllowedVendors = getCurrentConsentDecision()\n\n// Add the current ConsentDecision information (allowed Services and consent type) to the UDO for possible use in extensions\nb[nameOfVendorOptInArray] = currentlyAllowedVendors\nb[nameOfConsentTypeString] = currentlyAllowedVendors &amp;&amp; currentlyAllowedVendors.type\n\nvar implicitServices\n\n// only block previous implicit services from reloading if the current consent is explicit\nif (currentlyAllowedVendors.type === 'explicit') {\n  implicitServices = b[nameOfImplicitConsentArray] // use the previously stored array, from the queued event\n}\n\nlogger('Called block logic:\\n\\nAllowed: ' + JSON.stringify(currentlyAllowedVendors, null, 2) + '\\n\\nAlready processed: ' + (implicitServices ? JSON.stringify(implicitServices, null, 2) : '(none)'))\n\nlogger('Map:\\n\\n' + JSON.stringify(map, null, 2) + '\\n\\nActive Usercentrics settingsId: ' + getCurrentUsercentricsSettingsId() + '\\n\\nMap has entry for current settingsId: ' + (typeof map[getCurrentUsercentricsSettingsId()] === 'object' ? 'true' : 'false') + '\\n\\nTag-based map for the active settingsId: ' + JSON.stringify(tagBasedMap, null, 2))\nlogger('Consent confirmed: ' + currentlyAllowedVendors.type + ' : ' + JSON.stringify(currentlyAllowedVendors, null, 2))\n\nvar newCfg = blockTagsBasedOnConsent(tagBasedMap, window.utag.loader.cfg, currentlyAllowedVendors, implicitServices)\n\n// logger('Tag block debug:' + JSON.stringify(newCfg, null, 2))\n\nwindow.utag.loader.cfg = newCfg\n\n/**\n * Blocks tags based on consent by manually setting the 'load' and 'send' flags to 0 for any tags that don't have permission to fire.\n *\n * That logic isn't sufficient to block tracking calls with a 'uids' array (which also circumvents load rules), so additional blocking logic is added in the utag.handler.trigger override.\n * @param {object} tagBasedMap a {@link TagToServiceMap TagToServiceMap}\n * @param {object} configObject the current window.utag.loader.cfg object (which is used to control which tags should load/fire)\n * @param {array} consentedServices a {@link ConsentDecision ConsentDecision}\n * @param {array} alreadyProcessedImplicitServices an array of Service Names that have already been processed, to avoid double-firing those tags.\n */\nfunction blockTagsBasedOnConsent (tagBasedMap, configObject, consentedServices, alreadyProcessedImplicitServices) {\n  // block all tags if the consented services array is missing\n  if (Array.isArray(consentedServices) !== true) {\n    consentedServices = []\n  }\n\n  tagBasedMap = tagBasedMap || {}\n\n  // if the utag template hasn't been edited, this function won't have been overriden, so we gut it\n  // to stop tags from firing\n  var utagFunctionsHaveBeenOverriden = window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1\n  if (utagFunctionsHaveBeenOverriden !== true) {\n    window.utag.handler.trigger = function () {\n      logger('Tags have been disabled because the required utag.loader edit hasn\\'t been done successfully and the tealiumCmpIntegration is active.')\n    }\n    consentedServices = []\n  }\n\n  var deactivatedTags = []\n  // turn the map into an easier-to-query object\n\n  alreadyProcessedImplicitServices = alreadyProcessedImplicitServices || []\n\n  var tiqIsAllowed = tiqServiceName &amp;&amp; consentedServices.indexOf(tiqServiceName) !== -1\n\n  var allTagUids = Object.keys(configObject)\n\n  var assignedServiceName\n  var hasConsent\n\n  // deactivate tags that aren't mapped and consented\n  for (var i = 0; i &lt; allTagUids.length; i++) {\n    hasConsent = false // assume no consent\n\n    assignedServiceName = tagBasedMap[allTagUids[i]] || false\n\n    if (assignedServiceName) {\n      hasConsent = tiqIsAllowed &amp;&amp; consentedServices.indexOf(assignedServiceName) !== -1 &amp;&amp; alreadyProcessedImplicitServices.indexOf(assignedServiceName) === -1\n    }\n\n    if (hasConsent !== true) {\n      // this isn't enough to stop specified tagUids (in the array) from firing by itself\n      configObject[allTagUids[i]].send = 0\n      configObject[allTagUids[i]].load = 0\n      deactivatedTags.push(allTagUids[i])\n    }\n  }\n  logger('Blocked tags: ' + JSON.stringify(deactivatedTags, null, 2) + (tiqIsAllowed ? '' : '\\n\\nAll tags blocked because TealiumIQ isn\\'t allowed to fire.'))\n  return configObject\n}\n","promotedBy":"caleb.jaquith@tealium.com","promotedTimestamp":"202010070622","promotedDraftName":"extension-2.js"},"ef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567":{"promotedBy":"caleb.jaquith@tealium.com","promotedDraftName":"extension-2.js","promotedTimestamp":"202010070622","name":"dev","code":"/* global b */\n\n/**\n *  Scope       : All Tags - After Load Rules\n *  Condition   : n/a\n *  Description : CMP 2/2 - After Load Rules component - Prevent tags from firing if they don't have an opt-in in the mapping (or there is no mapping)\n *\n */\n\n/**\n * @module extension-2\n * @description The 'All Tags - After Load Rules' component, responsible for blocking tags if consent is missing or this CMP integration is misconfigured.\n */\n\nvar map = (window.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.map) || {}\n\n// get settings from CMP 1 extension, shouldn't need to change these\nvar globals = window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nvar tiqServiceName = globals.tiqServiceName || 'Tealium iQ Tag Management' // the default name for our Service in Usercentrics\n\nvar nameOfVendorOptInArray = globals.nameOfVendorOptInArray || 'missing_opt_in_array_name'\nvar nameOfConsentTypeString = globals.nameOfConsentTypeString || 'missing_consent_type_name'\nvar nameOfImplicitConsentArray = globals.nameOfImplicitConsentArray || 'missing_implicit_queue_array_name'\n\nvar tagBasedMap = globals.tagBasedMap || {}\n\nvar getCurrentConsentDecision = globals.getCurrentConsentDecision || function () { return [] }\nvar getCurrentUsercentricsSettingsId = globals.getCurrentUsercentricsSettingsId || function () { return '' }\n\nvar logger = globals.logger || (window.utag &amp;&amp; window.utag.DB) || function (message) { console.log(message) } // logger function with fallback in case global function is missing\n\n// recheck\nvar currentlyAllowedVendors = getCurrentConsentDecision()\n\n// Add the current ConsentDecision information (allowed Services and consent type) to the UDO for possible use in extensions\nb[nameOfVendorOptInArray] = currentlyAllowedVendors\nb[nameOfConsentTypeString] = currentlyAllowedVendors &amp;&amp; currentlyAllowedVendors.type\n\nvar implicitServices\n\n// only block previous implicit services from reloading if the current consent is explicit\nif (currentlyAllowedVendors.type === 'explicit') {\n  implicitServices = b[nameOfImplicitConsentArray] // use the previously stored array, from the queued event\n}\n\nlogger('Called block logic:\\n\\nAllowed: ' + JSON.stringify(currentlyAllowedVendors, null, 2) + '\\n\\nAlready processed: ' + (implicitServices ? JSON.stringify(implicitServices, null, 2) : '(none)'))\n\nlogger('Map:\\n\\n' + JSON.stringify(map, null, 2) + '\\n\\nActive Usercentrics settingsId: ' + getCurrentUsercentricsSettingsId() + '\\n\\nMap has entry for current settingsId: ' + (typeof map[getCurrentUsercentricsSettingsId()] === 'object' ? 'true' : 'false') + '\\n\\nTag-based map for the active settingsId: ' + JSON.stringify(tagBasedMap, null, 2))\nlogger('Consent confirmed: ' + currentlyAllowedVendors.type + ' : ' + JSON.stringify(currentlyAllowedVendors, null, 2))\n\nvar newCfg = blockTagsBasedOnConsent(tagBasedMap, window.utag.loader.cfg, currentlyAllowedVendors, implicitServices)\n\n// logger('Tag block debug:' + JSON.stringify(newCfg, null, 2))\n\nwindow.utag.loader.cfg = newCfg\n\n/**\n * Blocks tags based on consent by manually setting the 'load' and 'send' flags to 0 for any tags that don't have permission to fire.\n *\n * That logic isn't sufficient to block tracking calls with a 'uids' array (which also circumvents load rules), so additional blocking logic is added in the utag.handler.trigger override.\n * @param {object} tagBasedMap a {@link TagToServiceMap TagToServiceMap}\n * @param {object} configObject the current window.utag.loader.cfg object (which is used to control which tags should load/fire)\n * @param {array} consentedServices a {@link ConsentDecision ConsentDecision}\n * @param {array} alreadyProcessedImplicitServices an array of Service Names that have already been processed, to avoid double-firing those tags.\n */\nfunction blockTagsBasedOnConsent (tagBasedMap, configObject, consentedServices, alreadyProcessedImplicitServices) {\n  // block all tags if the consented services array is missing\n  if (Array.isArray(consentedServices) !== true) {\n    consentedServices = []\n  }\n\n  tagBasedMap = tagBasedMap || {}\n\n  // if the utag template hasn't been edited, this function won't have been overriden, so we gut it\n  // to stop tags from firing\n  var utagFunctionsHaveBeenOverriden = window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1\n  if (utagFunctionsHaveBeenOverriden !== true) {\n    window.utag.handler.trigger = function () {\n      logger('Tags have been disabled because the required utag.loader edit hasn\\'t been done successfully and the tealiumCmpIntegration is active.')\n    }\n    consentedServices = []\n  }\n\n  var deactivatedTags = []\n  // turn the map into an easier-to-query object\n\n  alreadyProcessedImplicitServices = alreadyProcessedImplicitServices || []\n\n  var tiqIsAllowed = tiqServiceName &amp;&amp; consentedServices.indexOf(tiqServiceName) !== -1\n\n  var allTagUids = Object.keys(configObject)\n\n  var assignedServiceName\n  var hasConsent\n\n  // deactivate tags that aren't mapped and consented\n  for (var i = 0; i &lt; allTagUids.length; i++) {\n    hasConsent = false // assume no consent\n\n    assignedServiceName = tagBasedMap[allTagUids[i]] || false\n\n    if (assignedServiceName) {\n      hasConsent = tiqIsAllowed &amp;&amp; consentedServices.indexOf(assignedServiceName) !== -1 &amp;&amp; alreadyProcessedImplicitServices.indexOf(assignedServiceName) === -1\n    }\n\n    if (hasConsent !== true) {\n      // this isn't enough to stop specified tagUids (in the array) from firing by itself\n      configObject[allTagUids[i]].send = 0\n      configObject[allTagUids[i]].load = 0\n      deactivatedTags.push(allTagUids[i])\n    }\n  }\n  logger('Blocked tags: ' + JSON.stringify(deactivatedTags, null, 2) + (tiqIsAllowed ? '' : '\\n\\nAll tags blocked because TealiumIQ isn\\'t allowed to fire.'))\n  return configObject\n}\n"}},"queueSeq":"7","draftSnippets":{"62fde09df4e41bb302fba9c118fe703c4ea4c613f6a85295442d6eb64a21535b":{"versionControl":{"hashValue":"8da85ba6458591f80d894fdf7ffc0890a66d7594","isOutdated":"false","lastSyncSuccess":"true","lastSyncTimeStamp":"202010070728","sourceName":"GitHub","accountName":"jaquith","sourceUrl":"https://github.com/jaquith/usercentrics-integration/blob/test/extensions/extension-2.js","isReadOnly":"true"},"updatedBy":"caleb.jaquith@tealium.com","creationDate":"202010050849","updateDate":"202010050849","name":"extension-2.js","code":"/* global b */\n\n/**\n *  Scope       : All Tags - After Load Rules\n *  Condition   : n/a\n *  Description : CMP 2/2 - After Load Rules component - Prevent tags from firing if they don't have an opt-in in the mapping (or there is no mapping)\n *\n */\n\n/**\n * @module extension-2\n * @description The 'All Tags - After Load Rules' component, responsible for blocking tags if consent is missing or this CMP integration is misconfigured.\n */\n\nvar map = (window.tealiumCmpIntegration &amp;&amp; window.tealiumCmpIntegration.map) || {}\n\n// get settings from CMP 1 extension, shouldn't need to change these\nvar globals = window.tealiumCmpIntegration = window.tealiumCmpIntegration || {}\nvar tiqServiceName = globals.tiqServiceName || 'Tealium iQ Tag Management' // the default name for our Service in Usercentrics\n\nvar nameOfVendorOptInArray = globals.nameOfVendorOptInArray || 'missing_opt_in_array_name'\nvar nameOfConsentTypeString = globals.nameOfConsentTypeString || 'missing_consent_type_name'\nvar nameOfImplicitConsentArray = globals.nameOfImplicitConsentArray || 'missing_implicit_queue_array_name'\n\nvar tagBasedMap = globals.tagBasedMap || {}\n\nvar getCurrentConsentDecision = globals.getCurrentConsentDecision || function () { return [] }\nvar getCurrentUsercentricsSettingsId = globals.getCurrentUsercentricsSettingsId || function () { return '' }\n\nvar logger = globals.logger || (window.utag &amp;&amp; window.utag.DB) || function (message) { console.log(message) } // logger function with fallback in case global function is missing\n\n// recheck\nvar currentlyAllowedVendors = getCurrentConsentDecision()\n\n// Add the current ConsentDecision information (allowed Services and consent type) to the UDO for possible use in extensions\nb[nameOfVendorOptInArray] = currentlyAllowedVendors\nb[nameOfConsentTypeString] = currentlyAllowedVendors &amp;&amp; currentlyAllowedVendors.type\n\nvar implicitServices\n\n// only block previous implicit services from reloading if the current consent is explicit\nif (currentlyAllowedVendors.type === 'explicit') {\n  implicitServices = b[nameOfImplicitConsentArray] // use the previously stored array, from the queued event\n}\n\nlogger('Called block logic:\\n\\nAllowed: ' + JSON.stringify(currentlyAllowedVendors, null, 2) + '\\n\\nAlready processed: ' + (implicitServices ? JSON.stringify(implicitServices, null, 2) : '(none)'))\n\nlogger('Map:\\n\\n' + JSON.stringify(map, null, 2) + '\\n\\nActive Usercentrics settingsId: ' + getCurrentUsercentricsSettingsId() + '\\n\\nMap has entry for current settingsId: ' + (typeof map[getCurrentUsercentricsSettingsId()] === 'object' ? 'true' : 'false') + '\\n\\nTag-based map for the active settingsId: ' + JSON.stringify(tagBasedMap, null, 2))\nlogger('Consent confirmed: ' + currentlyAllowedVendors.type + ' : ' + JSON.stringify(currentlyAllowedVendors, null, 2))\n\nvar newCfg = blockTagsBasedOnConsent(tagBasedMap, window.utag.loader.cfg, currentlyAllowedVendors, implicitServices)\n\n// logger('Tag block debug:' + JSON.stringify(newCfg, null, 2))\n\nwindow.utag.loader.cfg = newCfg\n\n/**\n * Blocks tags based on consent by manually setting the 'load' and 'send' flags to 0 for any tags that don't have permission to fire.\n *\n * That logic isn't sufficient to block tracking calls with a 'uids' array (which also circumvents load rules), so additional blocking logic is added in the utag.handler.trigger override.\n * @param {object} tagBasedMap a {@link TagToServiceMap TagToServiceMap}\n * @param {object} configObject the current window.utag.loader.cfg object (which is used to control which tags should load/fire)\n * @param {array} consentedServices a {@link ConsentDecision ConsentDecision}\n * @param {array} alreadyProcessedImplicitServices an array of Service Names that have already been processed, to avoid double-firing those tags.\n */\nfunction blockTagsBasedOnConsent (tagBasedMap, configObject, consentedServices, alreadyProcessedImplicitServices) {\n  // block all tags if the consented services array is missing\n  if (Array.isArray(consentedServices) !== true) {\n    consentedServices = []\n  }\n\n  tagBasedMap = tagBasedMap || {}\n\n  // if the utag template hasn't been edited, this function won't have been overriden, so we gut it\n  // to stop tags from firing\n  var utagFunctionsHaveBeenOverriden = window.utag.handler.trigger.toString().indexOf('tealiumCmpIntegration') !== -1\n  if (utagFunctionsHaveBeenOverriden !== true) {\n    window.utag.handler.trigger = function () {\n      logger('Tags have been disabled because the required utag.loader edit hasn\\'t been done successfully and the tealiumCmpIntegration is active.')\n    }\n    consentedServices = []\n  }\n\n  var deactivatedTags = []\n  // turn the map into an easier-to-query object\n\n  alreadyProcessedImplicitServices = alreadyProcessedImplicitServices || []\n\n  var tiqIsAllowed = tiqServiceName &amp;&amp; consentedServices.indexOf(tiqServiceName) !== -1\n\n  var allTagUids = Object.keys(configObject)\n\n  var assignedServiceName\n  var hasConsent\n\n  // deactivate tags that aren't mapped and consented\n  for (var i = 0; i &lt; allTagUids.length; i++) {\n    hasConsent = false // assume no consent\n\n    assignedServiceName = tagBasedMap[allTagUids[i]] || false\n\n    if (assignedServiceName) {\n      hasConsent = tiqIsAllowed &amp;&amp; consentedServices.indexOf(assignedServiceName) !== -1 &amp;&amp; alreadyProcessedImplicitServices.indexOf(assignedServiceName) === -1\n    }\n\n    if (hasConsent !== true) {\n      // this isn't enough to stop specified tagUids (in the array) from firing by itself\n      configObject[allTagUids[i]].send = 0\n      configObject[allTagUids[i]].load = 0\n      deactivatedTags.push(allTagUids[i])\n    }\n  }\n  logger('Blocked tags: ' + JSON.stringify(deactivatedTags, null, 2) + (tiqIsAllowed ? '' : '\\n\\nAll tags blocked because TealiumIQ isn\\'t allowed to fire.'))\n  return configObject\n}\n"}}},"initialize":"","labels":"","scope":"global","constructor":"","status":"active","advExecOption":"alr"}},"loadrules":{"2":{"0":{"input_1":"js.test","filter_1":"test123","filter_0":"","operator_1":"equals","input_0":"js.test","operator_0":"populated"},"title":"test123","containerId":"loadrules_content_160447458202900013","id":"2","startDate":"------------","editable":"true","sort":"1","labels":"","initialize":"","constructor":"","status":"active","_id":"2","endDate":"------------"}},"createManifest":"false","settings":{"profileid":"usercentrics-by-tag-datalayer-listener","account":"services-caleb","lastcustomizeid":"0","lastdefineid":"333","datacloud_revision":"1600247595895","library":"NONE","minorrevision":"202011040723","lastloadruleid":"2","datacloud_profile":"main","creation":"202010061215","revision":"202011040723","lastmanageid":"11"},"versionorigin":"202010290930","define":{"80":{"_id":"80","name":"test","labels":"","type":"js","title":"","description":""},"239":{"_id":"239","title":"","description":"","name":"event","labels":"","type":"js"},"240":{"labels":"","type":"cp","name":"utag_main__ss","description":"(Cookie) A flag that indicates whether or not a page view is the start of a session. A value of 1 means yes and 0 means no.","title":"(UTAG) is_start_of_session","_id":"240"},"241":{"title":"(UTAG) session_page_view_count","description":"(Cookie) The number of pages viewed during the current session","name":"utag_main__pn","type":"cp","labels":"","_id":"241"},"242":{"name":"utag_main__sn","type":"cp","labels":"","title":"(UTAG) session_count","description":"(Cookie) The number of sessions for this unique visitor","_id":"242"},"243":{"_id":"243","name":"utag_main_v_id","labels":"","type":"cp","title":"(UTAG) visitor_id","description":"(Cookie) A unique identifier for each visitor"},"244":{"title":"(UTAG) timestamp","description":"(Cookie) The Unix/Epoch time stamp in milliseconds.","name":"utag_main__st","type":"cp","labels":"","_id":"244"},"245":{"_id":"245","title":"(UTAG) session_id","description":"(Cookie) A unique identifier for the session.","name":"utag_main_ses_id","type":"cp","labels":""},"246":{"_id":"246","name":"ut.event","labels":"","type":"js","title":"(UTAG) event","description":"The name of the event being tracked. (view, link, etc.)"},"247":{"_id":"247","labels":"","type":"js","name":"ut.account","description":"The account associated with this utag.js file.","title":"(UTAG) account"},"248":{"description":"The profile associated with this utag.js file.","title":"(UTAG) profile","type":"js","labels":"","name":"ut.profile","_id":"248"},"249":{"labels":"","type":"js","name":"ut.env","description":"The publish environment associated with this utag.js file.","title":"(UTAG) environment","_id":"249"},"250":{"labels":"","type":"js","name":"ut.version","description":"The version number of the utag.js file. This is a combination of the utag.js template version number and the time stamp of its publish.","title":"(UTAG) version","_id":"250"},"251":{"name":"ut.domain","labels":"","type":"js","title":"(UTAG) domain","description":"The top-level domain of the currently loaded web page.","_id":"251"},"252":{"_id":"252","name":"page_type","type":"js","labels":"","title":"","description":""},"253":{"_id":"253","description":"","title":"","type":"js","labels":"","name":"eventValue"},"334":{"_id":"334","name":"Account Value Strings","type":"va","description":"Should contain account numbers and their value band","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5217","origin_name":"Account Value Strings","origin_type":"property_lists","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"335":{"_id":"335","name":"Active browser type","type":"va","description":"The browser actively being used by the visitor","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"44","origin_name":"Active browser type","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"336":{"_id":"336","name":"Active browser version","type":"va","description":"The browser version actively being used by the visitor","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"48","origin_name":"Active browser version","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"337":{"_id":"337","name":"Active device","type":"va","description":"The device actively being used by the visitor","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"46","origin_name":"Active device","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"338":{"_id":"338","name":"Active operating system","type":"va","description":"The operating system actively being used by the visitor","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"45","origin_name":"Active operating system","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"339":{"_id":"339","name":"Active platform","type":"va","description":"The platform actively being used by the visitor","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"47","origin_name":"Active platform","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"340":{"_id":"340","name":"Average visit duration in minutes","type":"va","description":"Average visit duration in minutes","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"26","origin_name":"Average visit duration in minutes","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"341":{"_id":"341","name":"Average visits per week","type":"va","description":"Average visits per week","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"29","origin_name":"Average visits per week","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"342":{"_id":"342","name":"Batch Tester","type":"va","description":"Testing the batch webhook","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5189","origin_name":"Batch Tester","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"343":{"_id":"343","name":"Blue","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5067","origin_name":"Blue","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"344":{"_id":"344","name":"Brown","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5055","origin_name":"Brown","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"345":{"_id":"345","name":"Cookie Sync ID - Assigned Rule","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5075","origin_name":"Cookie Sync ID - Assigned Rule","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"346":{"_id":"346","name":"Cookie Sync ID - No Rule","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5079","origin_name":"Cookie Sync ID - No Rule","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"347":{"_id":"347","name":"Counter (Last Seen)","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5193","origin_name":"Counter (Last Seen)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"348":{"_id":"348","name":"Direct visit","type":"va","description":"The user navigated directly to the site","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"14","origin_name":"Direct visit","origin_type":"flags","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"349":{"_id":"349","name":"Entry URL","type":"va","description":"URL of the first page visited","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"5","origin_name":"Entry URL","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"350":{"_id":"350","name":"Event count","type":"va","description":"Total number of events in visit","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"7","origin_name":"Event count","origin_type":"metrics","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"351":{"_id":"351","name":"Exit URL","type":"va","description":"URL of the last page visited","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"6","origin_name":"Exit URL","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"352":{"_id":"352","name":"Fan","type":"va","description":"More than two total visits and more direct visits than refers","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"30","origin_name":"Fan","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"353":{"_id":"353","name":"First 'test_value' only","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5183","origin_name":"First 'test_value' only","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"354":{"_id":"354","name":"First visit","type":"va","description":"Date of first visit","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"23","origin_name":"First visit","origin_type":"dates","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"355":{"_id":"355","name":"Frequent visitor","type":"va","description":"Two or more average visits per week","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"31","origin_name":"Frequent visitor","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"356":{"_id":"356","name":"Full entry URL (with attribution)","type":"va","description":"","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"5090","origin_name":"Full entry URL (with attribution)","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"357":{"_id":"357","name":"Google GID","type":"va","description":"From the Google Cookie Match, saved here as string ","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5038","origin_name":"Google GID","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"358":{"_id":"358","name":"Green","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5063","origin_name":"Green","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"359":{"_id":"359","name":"GUID - Compromised Profile","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5179","origin_name":"GUID - Compromised Profile","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"360":{"_id":"360","name":"GUID - Compromised profile and a new visit [bln]","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5340","origin_name":"GUID - Compromised profile and a new visit [bln]","origin_type":"flags","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"361":{"_id":"361","name":"GUID - Count Has Changed This Visit","type":"va","description":"","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"5332","origin_name":"GUID - Count Has Changed This Visit","origin_type":"flags","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"362":{"_id":"362","name":"GUID - Count of seen [num]","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5175","origin_name":"GUID - Count of seen [num]","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"363":{"_id":"363","name":"GUID - Healthy Profile","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5177","origin_name":"GUID - Healthy Profile","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"364":{"_id":"364","name":"GUID - Incomplete Profile","type":"va","description":"Should not use this profile, it's been used on a shared device and only contains partial information","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5334","origin_name":"GUID - Incomplete Profile","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"365":{"_id":"365","name":"GUID - Last seen [str]","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5169","origin_name":"GUID - Last seen [str]","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"366":{"_id":"366","name":"GUID - None","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5181","origin_name":"GUID - None","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"367":{"_id":"367","name":"Has Cookie Sync ID - With Rule","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5077","origin_name":"Has Cookie Sync ID - With Rule","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"368":{"_id":"368","name":"Has Cookie Sync ID - Without Rule","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5081","origin_name":"Has Cookie Sync ID - Without Rule","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"369":{"_id":"369","name":"Hyphen Lover","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5088","origin_name":"Hyphen Lover","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"370":{"_id":"370","name":"Import - Age","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5165","origin_name":"Import - Age","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"371":{"_id":"371","name":"Import - Alpha","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5161","origin_name":"Import - Alpha","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"372":{"_id":"372","name":"Import - Bool","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5167","origin_name":"Import - Bool","origin_type":"flags","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"373":{"_id":"373","name":"Import - Row Number","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5163","origin_name":"Import - Row Number","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"374":{"_id":"374","name":"Last 'test_value'","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5187","origin_name":"Last 'test_value'","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"375":{"_id":"375","name":"Last conversion partner name","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5034","origin_name":"Last conversion partner name","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"376":{"_id":"376","name":"Last event time","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5318","origin_name":"Last event time","origin_type":"dates","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"377":{"_id":"377","name":"Last event URL","type":"va","description":"Last event URL for visitor","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"17","origin_name":"Last event URL","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"378":{"_id":"378","name":"Last UDO String","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5145","origin_name":"Last UDO String","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"379":{"_id":"379","name":"Last visit","type":"va","description":"Date of last visit","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"24","origin_name":"Last visit","origin_type":"dates","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"380":{"_id":"380","name":"Last-seen tealium_event [str]","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5324","origin_name":"Last-seen tealium_event [str]","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"381":{"_id":"381","name":"Last-seen Trace Id","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5320","origin_name":"Last-seen Trace Id","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"382":{"_id":"382","name":"Lifetime browser types used (favorite)","type":"va","description":"Captures the favorite metric for Metric Set: Lifetime browser types used","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"56","origin_name":"Lifetime browser types used (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"383":{"_id":"383","name":"Lifetime browser versions used (favorite)","type":"va","description":"Captures the favorite metric for Metric Set: Lifetime browser versions used","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"62","origin_name":"Lifetime browser versions used (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"384":{"_id":"384","name":"Lifetime devices used (favorite)","type":"va","description":"Captures the favorite metric for Metric Set: Lifetime devices used","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"54","origin_name":"Lifetime devices used (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"385":{"_id":"385","name":"Lifetime event count","type":"va","description":"Total number of events triggered by user","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"22","origin_name":"Lifetime event count","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"386":{"_id":"386","name":"Lifetime operating systems used (favorite)","type":"va","description":"Captures the favorite metric for Metric Set: Lifetime operating systems used","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"58","origin_name":"Lifetime operating systems used (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"387":{"_id":"387","name":"Lifetime order total","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5028","origin_name":"Lifetime order total","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"388":{"_id":"388","name":"Lifetime order total by partner name (favorite)","type":"va","description":"Captures the favorite number for Tally: Lifetime order total by partner name","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5031","origin_name":"Lifetime order total by partner name (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"389":{"_id":"389","name":"Lifetime platforms used (favorite)","type":"va","description":"Captures the favorite metric for Metric Set: Lifetime platforms used","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"60","origin_name":"Lifetime platforms used (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"390":{"_id":"390","name":"LIfetime Test Stream Values (favorite)","type":"va","description":"Captures the favorite number for Tally: LIfetime Test Stream Values","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5132","origin_name":"LIfetime Test Stream Values (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"391":{"_id":"391","name":"Lifetime visit count","type":"va","description":"Total number of times user has visited site","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"21","origin_name":"Lifetime visit count","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"392":{"_id":"392","name":"Light Blue","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5065","origin_name":"Light Blue","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"393":{"_id":"393","name":"Most Recent GCLID","type":"va","description":"This setup ignores the edge case where a user could click two ads from this campaign within the same session - it will only send the last GCLID in those cases.","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5312","origin_name":"Most Recent GCLID","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"394":{"_id":"394","name":"Most Recent GCLID has changed this visit","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5314","origin_name":"Most Recent GCLID has changed this visit","origin_type":"flags","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"395":{"_id":"395","name":"NO BOUNCERS HERE","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5322","origin_name":"NO BOUNCERS HERE","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"396":{"_id":"396","name":"Optin (imported)","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5149","origin_name":"Optin (imported)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"397":{"_id":"397","name":"Orange","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5059","origin_name":"Orange","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"398":{"_id":"398","name":"Pink","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5069","origin_name":"Pink","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"399":{"_id":"399","name":"Product Prices Purchases - Last Order Imported (favorite)","type":"va","description":"Captures the favorite number for Tally: Product Prices Purchases - Last Order Imported","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"5120","origin_name":"Product Prices Purchases - Last Order Imported (favorite)","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"400":{"_id":"400","name":"Product Purchase Count (Lifetime) (favorite)","type":"va","description":"Captures the favorite number for Tally: Product Purchase Count (Lifetime)","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5118","origin_name":"Product Purchase Count (Lifetime) (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"401":{"_id":"401","name":"Red","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5057","origin_name":"Red","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"402":{"_id":"402","name":"Referred visit","type":"va","description":"The user was referred from another site","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"13","origin_name":"Referred visit","origin_type":"flags","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"403":{"_id":"403","name":"Referrer","type":"va","description":"","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"5092","origin_name":"Referrer","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"404":{"_id":"404","name":"Returning visitor","type":"va","description":"Return visitor","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"27","origin_name":"Returning visitor","origin_type":"flags","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"405":{"_id":"405","name":"Spend per Product (Lifetime) (favorite)","type":"va","description":"Captures the favorite number for Tally: Spend per Product (Lifetime)","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5122","origin_name":"Spend per Product (Lifetime) (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"406":{"_id":"406","name":"Tealium Test Visit","type":"va","description":"Set via query parameter &quot;tealium_test_visit=true&quot;","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"5125","origin_name":"Tealium Test Visit","origin_type":"flags","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"407":{"_id":"407","name":"Tealium Visitor ID (Last Seen)","type":"va","description":"3rd party wins if present","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5129","origin_name":"Tealium Visitor ID (Last Seen)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"408":{"_id":"408","name":"tealium_cf_visit_ttl","type":"va","description":"","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"82","origin_name":"tealium_cf_visit_ttl","origin_type":"properties","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"409":{"_id":"409","name":"Test Date","type":"va","description":"Expects format 2020-08-27T13:13:47.395Z ","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5195","origin_name":"Test Date","origin_type":"dates","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"410":{"_id":"410","name":"Test Tally (favorite)","type":"va","description":"Captures the favorite number for Tally: Test Tally","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5093","origin_name":"Test Tally (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"411":{"_id":"411","name":"test_tiq_string values (favorite)","type":"va","description":"Captures the favorite number for Tally: test_tiq_string values","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5136","origin_name":"test_tiq_string values (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"412":{"_id":"412","name":"test_udo_string values (favorite)","type":"va","description":"Captures the favorite number for Tally: test_udo_string values","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5138","origin_name":"test_udo_string values (favorite)","origin_type":"properties","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"413":{"_id":"413","name":"Tester","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5141","origin_name":"Tester","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"414":{"_id":"414","name":"Total direct visits","type":"va","description":"Total direct visits","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"15","origin_name":"Total direct visits","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"415":{"_id":"415","name":"Total referred visits","type":"va","description":"Total referred visits","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"16","origin_name":"Total referred visits","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"416":{"_id":"416","name":"Total time spent on site in minutes","type":"va","description":"Sum duration of all user visits","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"25","origin_name":"Total time spent on site in minutes","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"417":{"_id":"417","name":"Unbadged","type":"va","description":"The visitor has not been assigned any badges","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"32","origin_name":"Unbadged","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"418":{"_id":"418","name":"Visit duration","type":"va","description":"Visit duration in minutes","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"12","origin_name":"Visit duration","origin_type":"metrics","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"419":{"_id":"419","name":"Visit end","type":"va","description":"Visit end date","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"11","origin_name":"Visit end","origin_type":"dates","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"420":{"_id":"420","name":"Visit start","type":"va","description":"Visit start date","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"10","origin_name":"Visit start","origin_type":"dates","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"421":{"_id":"421","name":"Weeks since first visit","type":"va","description":"Weeks elapsed since first visit","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"28","origin_name":"Weeks since first visit","origin_type":"metrics","origin_context":"visitor","account":"services-caleb","profileid":"main"}},"422":{"_id":"422","name":"Weeks since first visit temp","type":"va","description":"Temporary store for computer value","context":"current_visit","imported":"AudienceStream","settings":{"origin_id":"80","origin_name":"Weeks since first visit temp","origin_type":"metrics","origin_context":"current_visit","account":"services-caleb","profileid":"main"}},"423":{"_id":"423","name":"Yellow","type":"va","description":"","context":"visitor","imported":"AudienceStream","settings":{"origin_id":"5061","origin_name":"Yellow","origin_type":"badges","origin_context":"visitor","account":"services-caleb","profileid":"main"}}},"manage":{"6":{"status":"active","scope":"all","config_staticparams":"tagUid=6","loadrule_join_operator":"all","advconfig_optout":"yes","advconfig_wait":"yes","config_cachevar":"","advconfig_loadtype":"","config_qsp":"&amp;","config_cachebust":"enabled","tag_name":"Tealium Generic Tag","loadrule":"all","title":"Tealium Generic Tag","config_securebaseurl":"","tag_id":"20067","notes":"","new_flag":"true","selectedTargets":{"qa":"true","dev":"true","prod":"true"},"config_kvp":"=","config_qs":"?","publishedTargets":"dev","config_baseurl":"https://solutions.tealium.net/hosted/i.gif","labels":"","advconfig_bundle":"no","config_requestscriptonce":"disabled","id":"6","_id":"6","publish_revisions":{"last_modified":"202010051319","svr_save_timestamps":{"dev":"202010051320","prod":"202010051320","qa":"202010051320"}},"config_tagtype":"img","map":{"1":{"dsID":"239","key":"event","type":"js","variable":"event"},"2":{"dsID":"246","key":"ut.event","variable":"ut_event","type":"js"},"3":{"variable":"page_type","type":"js","dsID":"252","key":"page_type"},"4":{"key":"eventValue","dsID":"253","type":"js","variable":"event_value"}},"sort":"0","advconfig_send":"yes","advconfig_src":""},"7":{"status":"active","scope":"all","loadrule_join_operator":"all","config_staticparams":"tagUid=7","advconfig_optout":"yes","advconfig_wait":"yes","config_cachevar":"","advconfig_loadtype":"","config_qsp":"&amp;","loadrule":"all","tag_name":"Tealium Generic Tag","config_cachebust":"enabled","config_securebaseurl":"","title":"Tealium Generic Tag Copy 1","tag_id":"20067","notes":"","new_flag":"true","selectedTargets":{"dev":"true","prod":"true","qa":"true"},"config_kvp":"=","config_qs":"?","publishedTargets":"dev","config_baseurl":"https://solutions.tealium.net/hosted/i.gif","labels":"","advconfig_bundle":"no","config_requestscriptonce":"disabled","id":"7","_id":"7","publish_revisions":{"svr_save_timestamps":{"dev":"202010051320","prod":"202010051320","qa":"202010051320"},"last_modified":"202010051319"},"config_tagtype":"img","map":{"1":{"type":"js","variable":"event","dsID":"239","key":"event"},"2":{"dsID":"246","key":"ut.event","type":"js","variable":"ut_event"},"3":{"type":"js","variable":"page_type","dsID":"252","key":"page_type"},"4":{"type":"js","variable":"event_value","key":"eventValue","dsID":"253"}},"sort":"1","advconfig_send":"yes","advconfig_src":"","copiedFromTag":"6"},"8":{"config_kvp":"=","config_qs":"?","publishedTargets":"dev","notes":"","new_flag":"true","selectedTargets":{"qa":"true","dev":"true","prod":"true"},"tag_id":"20067","config_securebaseurl":"","title":"Tealium Generic Tag Copy 2","advconfig_wait":"yes","config_cachevar":"","advconfig_loadtype":"","loadrule":"all","tag_name":"Tealium Generic Tag","config_cachebust":"enabled","config_qsp":"&amp;","advconfig_optout":"yes","status":"active","scope":"all","loadrule_join_operator":"all","config_staticparams":"tagUid=8","advconfig_src":"","copiedFromTag":"6","advconfig_send":"yes","map":{"1":{"key":"event","dsID":"239","variable":"event","type":"js"},"2":{"variable":"page_type","type":"js","key":"page_type","dsID":"252"},"3":{"type":"js","variable":"ut_event","key":"ut.event","dsID":"246"},"4":{"variable":"event_value","type":"js","key":"eventValue","dsID":"253"}},"sort":"2","_id":"8","publish_revisions":{"last_modified":"202010051319","svr_save_timestamps":{"dev":"202010051320","prod":"202010051320","qa":"202010051320"}},"config_tagtype":"img","config_requestscriptonce":"disabled","id":"8","advconfig_bundle":"no","config_baseurl":"https://solutions.tealium.net/hosted/i.gif","labels":""},"9":{"advconfig_src":"","copiedFromTag":"6","advconfig_send":"yes","map":{"1":{"type":"js","variable":"event","key":"event","dsID":"239"},"2":{"type":"js","variable":"ut_event","key":"ut.event","dsID":"246"},"3":{"type":"js","variable":"page_type","dsID":"252","key":"page_type"},"4":{"variable":"event_value","type":"js","key":"eventValue","dsID":"253"}},"sort":"3","_id":"9","config_tagtype":"img","publish_revisions":{"svr_save_timestamps":{"prod":"202010051320","dev":"202010051320","qa":"202010051320"},"last_modified":"202010051319"},"config_requestscriptonce":"enabled","id":"9","advconfig_bundle":"no","config_baseurl":"https://solutions.tealium.net/hosted/i.gif","labels":"","config_kvp":"=","config_qs":"?","publishedTargets":"dev","notes":"","new_flag":"true","selectedTargets":{"qa":"true","prod":"true","dev":"true"},"tag_id":"20067","title":"Tealium Generic Tag Copy 3","config_securebaseurl":"","advconfig_wait":"yes","config_cachevar":"","advconfig_loadtype":"","loadrule":"all","config_cachebust":"enabled","tag_name":"Tealium Generic Tag","config_qsp":"&amp;","advconfig_optout":"yes","status":"active","scope":"all","loadrule_join_operator":"all","config_staticparams":"tagUid=9"},"10":{"labels":"","config_baseurl":"https://solutions.tealium.net/hosted/i.gif","advconfig_bundle":"no","id":"10","config_requestscriptonce":"disabled","config_tagtype":"img","publish_revisions":{"svr_save_timestamps":{"qa":"202010051320","prod":"202010051320","dev":"202010051320"},"last_modified":"202010051319"},"_id":"10","map":{"1":{"dsID":"239","key":"event","variable":"event","type":"js"},"2":{"type":"js","variable":"ut_event","key":"ut.event","dsID":"246"},"3":{"key":"page_type","dsID":"252","variable":"page_type","type":"js"},"4":{"type":"js","variable":"event_value","dsID":"253","key":"eventValue"}},"sort":"4","advconfig_send":"yes","copiedFromTag":"6","advconfig_src":"","config_staticparams":"tagUid=10","loadrule_join_operator":"all","status":"active","scope":"2","advconfig_optout":"yes","config_cachevar":"","advconfig_loadtype":"","loadrule":"2","tag_name":"Tealium Generic Tag","config_qsp":"&amp;","config_cachebust":"enabled","advconfig_wait":"yes","config_securebaseurl":"","title":"Tealium Generic Tag Copy 4","tag_id":"20067","selectedTargets":{"prod":"true","dev":"true","qa":"true"},"notes":"","new_flag":"true","publishedTargets":"dev","config_kvp":"=","config_qs":"?"},"11":{"publishedTargets":"dev","config_kvp":"=","config_qs":"?","tag_id":"20067","selectedTargets":{"prod":"true","dev":"true","qa":"true"},"new_flag":"true","notes":"","tag_name":"Tealium Generic Tag","config_cachebust":"enabled","config_qsp":"&amp;","loadrule":"all","advconfig_loadtype":"","config_cachevar":"","advconfig_wait":"yes","title":"Tealium Generic Tag Copy 5","config_securebaseurl":"","loadrule_join_operator":"all","config_staticparams":"tagUid=11","scope":"all","status":"active","advconfig_optout":"yes","advconfig_send":"yes","copiedFromTag":"6","advconfig_src":"","publish_revisions":{"last_modified":"202010051321","svr_save_timestamps":{"qa":"202010051321","dev":"202010051321","prod":"202010051321"}},"config_tagtype":"img","_id":"11","sort":"5","map":{"1":{"type":"js","variable":"event","dsID":"239","key":"event"},"2":{"type":"js","variable":"page_type","dsID":"252","key":"page_type"},"3":{"dsID":"246","key":"ut.event","variable":"ut_event","type":"js"},"4":{"variable":"event_value","type":"js","key":"eventValue","dsID":"253"}},"advconfig_bundle":"no","id":"11","config_requestscriptonce":"disabled","labels":"","config_baseurl":"https://solutions.tealium.net/hosted/i.gif"}},"lastcustomizeid":"0","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"10\" , \"name\" : \"RELEASE 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_10\" , \"tab_name\" : \"customizations\"}}]","account":"services-caleb","profile_action_type":"SaveAs","profile":"usercentrics-by-tag-datalayer-listener","label_relationships":null,"linkedProfiles":"{ }","publish_history":{"202010070728":{"202010070728":{"linkedProfiles":"{ }","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]","lastcustomizeid":"0","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"21\" , \"name\" : \"TEST 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_21\" , \"tab_name\" : \"customizations\"}}]","title":"Version 2020.10.07.0728","datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","status":"qa,dev","lastmanageid":"11","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","operator":"caleb.jaquith@tealium.com","versionorigin":"202010070622","publishedConsent":"[ ]","notes":"Update","action":"Published to dev"},"title":"Version 2020.10.07.0728","size":"81","status":"Not Published"},"202010290930":{"title":"Version 2020.10.29.0930","202010290930":{"versionorigin":"202010290901","publishedConsent":"[ ]","notes":"Force","action":"Published to dev","lastmanageid":"11","status":"qa,dev","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","operator":"caleb.jaquith@tealium.com","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"21\" , \"name\" : \"TEST 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_21\" , \"tab_name\" : \"customizations\"}}]","lastcustomizeid":"0","title":"Version 2020.10.29.0930","datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","linkedProfiles":"{ }","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]"},"size":"81","status":"prod"},"202010061857":{"size":"81","202010061857":{"action":"Published to dev","notes":"Update","versionorigin":"202010061215","publishedConsent":"[ ]","operator":"caleb.jaquith@tealium.com","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","lastmanageid":"11","status":"qa,dev","datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","lastcustomizeid":"0","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"21\" , \"name\" : \"TEST 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_21\" , \"tab_name\" : \"customizations\"}} , { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"22\" , \"name\" : \"TEST 2/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_22\" , \"tab_name\" : \"customizations\"}}]","title":"Version 2020.10.06.1857","linkedProfiles":"{ }","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]"},"status":"Not Published","title":"Version 2020.10.06.1857"},"202010061215":{"size":"81","status":"Not Published","202010061215":{"datacloudLinkedProfiles":"{}","history":"","lastcustomizeid":"","title":"Initial publish","linkedProfiles":"{ }","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]","action":"Published to dev","publishedConsent":"","notes":"Initial publish on profile creation","versionorigin":"","operator":"caleb.jaquith@tealium.com","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","status":"prod,qa,dev","lastmanageid":""},"title":"Initial publish"},"202010070622":{"size":"81","status":"Not Published","202010070622":{"datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","lastcustomizeid":"0","title":"Version 2020.10.07.0622","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"21\" , \"name\" : \"TEST 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_21\" , \"tab_name\" : \"customizations\"}} , { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"22\" , \"name\" : \"TEST 2/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_22\" , \"tab_name\" : \"customizations\"}}]","linkedProfiles":"{ }","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]","action":"Published to dev","versionorigin":"202010061924","publishedConsent":"[ ]","notes":"Update","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","operator":"caleb.jaquith@tealium.com","status":"qa,dev","lastmanageid":"11"},"title":"Version 2020.10.07.0622"},"202010061859":{"title":"Version 2020.10.06.1859","202010061859":{"versionorigin":"202010061857","publishedConsent":"[ ]","notes":"utag template update","action":"Published to dev","lastmanageid":"11","status":"prod,qa,dev","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","operator":"caleb.jaquith@tealium.com","lastcustomizeid":"0","title":"Version 2020.10.06.1859","history":"[ { \"action\" : \"updated_profile_template\" , \"data\" : { \"id\" : \"loader\" , \"name\" : \"uTag Loader (Profile) UID:loader\" , \"kind\" : \"Template\" , \"operation\" : \"updated\" , \"tab_name\" : \"Template\"}}]","datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]","linkedProfiles":"{ }"},"size":"81","status":"Not Published"},"202010080753":{"title":"Version 2020.10.08.0753","202010080753":{"datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"10\" , \"name\" : \"RELEASE 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_10\" , \"tab_name\" : \"customizations\"}} , { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"11\" , \"name\" : \"RELEASE 2/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_11\" , \"tab_name\" : \"customizations\"}}]","lastcustomizeid":"0","title":"Version 2020.10.08.0753","linkedProfiles":"{ }","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]","action":"Published to dev","publishedConsent":"[ ]","versionorigin":"202010070728","notes":"Update prod","operator":"caleb.jaquith@tealium.com","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","lastmanageid":"11","status":"prod,qa,dev"},"size":"81","status":"Not Published"},"202010290901":{"status":"Not Published","size":"81","202010290901":{"datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"21\" , \"name\" : \"TEST 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_21\" , \"tab_name\" : \"customizations\"}}]","lastcustomizeid":"0","title":"Version 2020.10.29.0901","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]","linkedProfiles":"{ }","action":"Published to dev","versionorigin":"202010290859","publishedConsent":"[ ]","notes":"Update to v0.10-beta","operator":"caleb.jaquith@tealium.com","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","status":"qa,dev","lastmanageid":"11"},"title":"Version 2020.10.29.0901"},"202010290859":{"202010290859":{"publishedConsent":"[ ]","versionorigin":"202010080753","notes":"Update to v0.10-beta","action":"Published to dev","status":"qa,dev","lastmanageid":"11","operator":"caleb.jaquith@tealium.com","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","lastcustomizeid":"0","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"21\" , \"name\" : \"TEST 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_21\" , \"tab_name\" : \"customizations\"}}]","title":"Version 2020.10.29.0859","datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]","linkedProfiles":"{ }"},"title":"Version 2020.10.29.0859","status":"Not Published","size":"81"},"202011040723":{"size":"96","status":"prod,qa,dev","202011040723":{"action":"Published to dev","versionorigin":"202010290930","notes":"v0.10-beta to prod","publishedConsent":"[ ]","operator":"caleb.jaquith@tealium.com","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","lastmanageid":"11","status":"prod,qa,dev","datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","title":"Version 2020.11.04.0723","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"10\" , \"name\" : \"RELEASE 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_10\" , \"tab_name\" : \"customizations\"}}]","lastcustomizeid":"0","linkedProfiles":"{ }","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]"},"title":"Version 2020.11.04.0723"},"202010061924":{"status":"Not Published","size":"81","202010061924":{"datacloudLinkedProfiles":"{&quot;main&quot;:{&quot;rev&quot;:&quot;1600247595895&quot;,&quot;env&quot;:&quot;AudienceStream&quot;}}","title":"Version 2020.10.06.1924","lastcustomizeid":"0","history":"[ { \"action\" : \"updated_extension\" , \"data\" : { \"id\" : \"21\" , \"name\" : \"TEST 1/2\" , \"type\" : \"100040\" , \"kind\" : \"Extension\" , \"operation\" : \"updated\" , \"container\" : \"customizations_21\" , \"tab_name\" : \"customizations\"}}]","publishedExtensions":"[ \"10\" , \"11\" , \"14\" , \"15\" , \"16\" , \"17\" , \"18\" , \"19\" , \"20\" , \"21\" , \"22\"]","linkedProfiles":"{ }","action":"Published to dev","versionorigin":"202010061859","notes":"Update","publishedConsent":"[ ]","publishedTags":"[ \"6\" , \"7\" , \"8\" , \"9\" , \"10\" , \"11\"]","operator":"caleb.jaquith@tealium.com","status":"qa,dev","lastmanageid":"11"},"title":"Version 2020.10.06.1924"}},"publish":{"smartFTP":{"prod":"preMCDN","dev":"preMCDN","qa":"preMCDN"},"minify":"yes","enable_utf8_encoding":"yes"},"test":{},"lastmanageid":"11","importable_library":"NONE","revision":"202010290930","datacloud_merge":"true","datacloud_profile_name":"main","datacloud_revision":"1625226277606","experiments":[{"id":"load_order_manager","enabled":false}]}
